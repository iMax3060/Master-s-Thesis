\chapter[Buffer Manager Page Eviction]{Page Eviction by the Buffer Pool Management} \label{ch:page_evictioners}

\section{DBMS Buffer Management} \label{sec:page_evictioners_purpose}

    The buffer management of a typical disk-based DBMS serves the purpose of providing the higher layers of the DBMS with managed access to data and metadata pages of a database stored in files on the secondary storage. This managed access involves fetching specific pages into specific memory locations---so-called \emph{buffer frames}---inside the buffer pool and write-back changes to pages in memory to database files in secondary storage.

    Today, there are server systems with \SI{48}{\tebi\byte} of cache-coherent shared memory\footnote{\url{https://h20195.www2.hpe.com/v2/gethtml.aspx?docname=c04912781}} that allow \emph{in-memory} management of almost any database of any application. But such expensive systems (\SI{>2000000}{\euro}) do not pay off for most applications even with large databases. Therefore, there will still be many situations in which the main memory of a system is significantly smaller than the database(s) managed on it. Accordingly, the number of buffer frames in the buffer pool is then smaller than the number of pages in the database.

    Therefore, the buffer management must \emph{evict} pages from buffer frames if currently not buffered pages are referenced while there are no more free buffer frames. For this purpose, each buffer manager has a page eviction module---implementing one of the many \emph{page replacement algorithms} developed since the 1960s.

    In \emph{OLTP} (online transaction processing) applications, the majority of database accesses are random accesses, so the access latency of the underlying storage technology (figure \ref{fig:storagehierarchy}) is critical to performance. The main goal of buffer management is to maximize the \emph{hit rate} in the DB buffer by keeping as many pages of the working set (pages referenced in the near future) as possible in relatively fast (\SI{51}{\nano\second}) main memory to avoid expensive (\SI{>100}{\micro\second}) secondary storage accesses.

\begin{@empty}
    \tikzset{%
        changes/.style = { -> , very thick, > = stealth}
    }
    
    \nottoggle{bwmode}{
        \tikzset{%
            volatile/.style = {fill = red!50},
            nonvolatile/.style = {fill = green!50},
            changes/.append style = {color = red}
        }
    }{
        \tikzset{%
            volatile/.style = {pattern = crosshatch, pattern color = black!25},
            nonvolatile/.style = {pattern = crosshatch dots, pattern color = black!25}
        }
    }
    
    \begin{figure}
        \centering
        \begin{minipage}{\linewidth}
            \resizebox{\textwidth}{!}{
                \begin{tikzpicture}[font = \sffamily]
                % Center points of the baseline of each pyramid layer (0: Peak of the pyramid; 1: Center of the baseline of the top layer; ...)
                \node[]  (0)                                                                       {};
                \node[]  (1)   [below = 1.5cm of 0.center, anchor = center]                        {};
                \node[]  (2a)  [below = (1/3)*1.25cm of 1.center, anchor = center]                 {};
                \node[]  (2b)  [below = (1/3)*1.25cm of 2a.center, anchor = center]                {};
                \node[]  (2c)  [below = (1/3)*1.25cm of 2b.center, anchor = center]                {};
                \node[]  (3)   [below = 0.75cm of 2c.center, anchor = center]                      {};
                \node[]  (4)   [below = 0.75cm of 3.center, anchor = center]                       {};
                \node[]  (5)   [below = 0.75cm of 4.center, anchor = center]                       {};
                \node[]  (6)   [below = 0.75cm of 5.center, anchor = center]                       {};
                
                % Anchor points of the pyramid (n0: Left anchor point; n1: Right anchor point):
                \node[]  (10)  [left = (2/3)*1.5cm of 1.center, anchor = center]                   {};
                \node[]  (11)  [right = (2/3)*1.5cm of 1.center, anchor = center]                  {};
                \node[]  (2a0) [left = (2/3)*(1.5cm+(1/3)*1.25cm) of 2a.center, anchor = center]   {};
                \node[]  (2a1) [right = (2/3)*(1.5cm+(1/3)*1.25cm) of 2a.center, anchor = center]  {};
                \node[]  (2b0) [left = (2/3)*(1.5cm+(2/3)*1.25cm) of 2b.center, anchor = center]   {};
                \node[]  (2b1) [right = (2/3)*(1.5cm+(2/3)*1.25cm) of 2b.center, anchor = center]  {};
                \node[]  (2c0) [left = (2/3)*(1.5cm+(3/3)*1.25cm) of 2c.center, anchor = center]   {};
                \node[]  (2c1) [right = (2/3)*(1.5cm+(3/3)*1.25cm) of 2c.center, anchor = center]  {};
                \node[]  (30)  [left = (2/3)*3.5cm of 3.center, anchor = center]                   {};
                \node[]  (31)  [right = (2/3)*3.5cm of 3.center, anchor = center]                  {};
                \node[]  (40)  [left = (2/3)*4.25cm of 4.center, anchor = center]                  {};
                \node[]  (41)  [right = (2/3)*4.25cm of 4.center, anchor = center]                 {};
                \node[]  (50)  [left = (2/3)*5cm of 5.center, anchor = center]                     {};
                \node[]  (51)  [right = (2/3)*5cm of 5.center, anchor = center]                    {};
                \node[]  (60)  [left = (2/3)*5.75cm of 6.center, anchor = center]                  {};
                \node[]  (61)  [right = (2/3)*5.75cm of 6.center, anchor = center]                 {};
                
                % "Center" of the pyramid (shifted towards top) used for the designation of performance measures:
                \node[]  (cen) [below = 2.5cm of 0.center]                                         {};
                
                % Designation of performance measures:
                \node[rotate = 55]  (cpu) [left = 3.5cm of cen.center, anchor = center]  {\footnotesize \textit{\textbf{Capacity per CPU}}};
                \node[rotate = -55] (acc) [right = 4.5cm of cen.center, anchor = center] {\footnotesize \textit{\textbf{Access time}}};
                
                % Fills the pyramid to mark volatile and non-volatile layers:
                \fill[volatile]    (0.center) -- (30.center) -- (31.center) -- cycle;
                \fill[nonvolatile] (30.center) -- (31.center) -- (61.center) -- (60.center) -- cycle;
                
                % Key the markings for volatile and non-volatile layers
                \node[draw, volatile]    (red)      [left = 4cm of 0.center, anchor = north]      {};
                \node[]                  (legred)   [right = 0cm of red.east, anchor = west]      {\footnotesize Volatile};
                \node[draw, nonvolatile] (green)    [below = 0.2cm of red.south, anchor = north]  {};
                \node[]                  (leggreen) [right = 0cm of green.east, anchor = west]    {\footnotesize Non-volatile};
                
                % Storage layer names:
                \node[] (reg) [above = 0cm of 1.center, anchor = south]     {\footnotesize Registers};
                \node[] (l1)  [above = 0cm of 2a.center, anchor = south]    {\footnotesize L1 cache};
                \node[] (l2)  [above = 0cm of 2b.center, anchor = south]    {\footnotesize L2 cache};
                \node[] (l3)  [above = 0cm of 2c.center, anchor = south]    {\footnotesize L3 cache};
                \node[] (mem) [above = 0.05cm of 3.center, anchor = south]  {\small Main memory};
                \node[] (ssd) [above = 0.05cm of 4.center, anchor = south]  {\small Online storage \scriptsize \textit{(secondary s.) - SDD}};
                \node[] (mas) [above = 0.05cm of 5.center, anchor = south]  {\small Online storage \scriptsize \textit{(secondary s.) - HDD}};
                \node[] (mem) [above = 0.05cm of 6.center, anchor = south]  {\small Offline storage \scriptsize \textit{(tertiary storage)}};
                
                % Anchor points for the brace used to mark the example data from Intel Xeon:
                \node[] (0h)        [right = 2.75cm of 0]     {};
                \node[] (31h)       [right = 2.75cm of 31]    {};
                
                % Draw the pyramid:
                \path[ - , thick]
                (0.center)         edge        (10.center)
                (0.center)         edge        (11.center)
                (10.center)        edge        (11.center)
                (10.center)        edge        (2a0.center)
                (11.center)        edge        (2a1.center)
                (2a0.center)       edge        (2a1.center)
                (2a0.center)       edge        (2b0.center)
                (2a1.center)       edge        (2b1.center)
                (2b0.center)       edge        (2b1.center)
                (2b0.center)       edge        (2c0.center)
                (2b1.center)       edge        (2c1.center)
                (2c0.center)       edge        (2c1.center)
                (2c0.center)       edge        (30.center)
                (2c1.center)       edge        (31.center)
                (30.center)        edge        (31.center)
                (30.center)        edge        (40.center)
                (31.center)        edge        (41.center)
                (40.center)        edge        (41.center)
                (40.center)        edge        (50.center)
                (41.center)        edge        (51.center)
                (50.center)        edge        (51.center)
                (50.center)        edge        (60.center)
                (51.center)        edge        (61.center)
                (60.center)        edge        (61.center);
                
                % Draw the connections between the brace used to mark the example data from Intel Xeon and the appropriate pyramid layers:
                \path[dotted]
                (0.center)             edge        (0h.center)
                (31.center)            edge        (31h.center);
                
                % Add the capacities:
                \draw [decorate, decoration = {brace, mirror, amplitude = 3.75pt}]
                (0.center) -- (10.center) node[black, midway, xshift = -0.1cm, yshift = 0.1cm, anchor = east] {\SI{128}{\byte}\protect\footnote{Only general purpose registers are considered}};
                \draw [decorate, decoration = {brace, mirror, amplitude = 3.75pt}]
                (10.center) -- (2a0.center) node[black, midway, xshift = -0.1cm, yshift = 0.1cm, anchor = east] {\small \SI{256}{\kibi\byte}};
                \draw [decorate, decoration = {brace, mirror, amplitude = 3.75pt}]
                (2a0.center) -- (2b0.center) node[black, midway, xshift = -0.1cm, yshift = 0.1cm, anchor = east] {\small \SI{1}{\mebi\byte}};
                \draw [decorate, decoration = {brace, mirror, amplitude = 3.75pt}]
                (2b0.center) -- (2c0.center) node[black, midway, xshift = -0.1cm, yshift = 0.1cm, anchor = east] {\small \SI{8}{\mebi\byte}};
                \draw [decorate, decoration = {brace, mirror, amplitude = 3.75pt}]
                (2c0.center) -- (30.center) node[black, midway, xshift = -0.1cm, yshift = 0.1cm, anchor = east] {\SI{\leq1.5}{\tebi\byte}};
                \draw [decorate, decoration = {brace, mirror, amplitude = 3.75pt}]
                (30.center) -- (40.center) node[black, midway, xshift = 0.3cm, yshift = 0.1cm, anchor = east] {\begin{tabular}{l}many\\\si{\tebi\byte}\end{tabular}};
                \draw [decorate, decoration = {brace, mirror, amplitude = 3.75pt}]
                (40.center) -- (50.center) node[black, midway, xshift = -0.1cm, yshift = 0.1cm, anchor = east] {\si{\tebi\byte}--\si{\pebi\byte}};
                \draw [decorate, decoration = {brace, mirror, amplitude = 3.75pt}]
                (50.center) -- (60.center) node[black, midway, xshift = -0.1cm, yshift = 0.1cm, anchor = east] {\si{\pebi\byte}};
                
                % Add the access times:
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (0.center) -- (11.center) node[black, midway, xshift = 0.1cm, yshift = 0.1cm, anchor = west] {\SI{1}{\cy} $\approx$ \SI{0.25}{\nano\second}};
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (11.center) -- (2a1.center) node[black, midway, xshift = 0.1cm, yshift = 0.1cm, anchor = west] {\small \SI{4}{\cy} $\approx$ \SI{1}{\nano\second}};
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (2a1.center) -- (2b1.center) node[black, midway, xshift = 0.1cm, yshift = 0.1cm, anchor = west] {\small \SI{12}{\cy} $\approx$ \SI{3}{\nano\second}};
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (2b1.center) -- (2c1.center) node[black, midway, xshift = 0.1cm, yshift = 0.1cm, anchor = west] {\small \SI{42}{\cy} $\approx$ \SI{11}{\nano\second}};
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (2c1.center) -- (31.center) node[black, midway, xshift = 0.1cm, yshift = 0.1cm, anchor = west] {\SI{51}{\nano\second}};
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (31.center) -- (41.center) node[black, midway, xshift = 0.1cm, yshift = 0.1cm, anchor = west] {\SI{\approx 0.1}{\milli\second} \tiny \footnote{\url{https://www.samsung.com/semiconductor/global.semi.static/SSD_vs_HDD_Brochure_181001.pdf}}};
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (41.center) -- (51.center) node[black, midway, xshift = 0.1cm, yshift = 0.1cm, anchor = west] {\numrange{5}{20}\si{\milli\second} \tiny \footnote{\url{https://web.archive.org/web/20180509053527/http://www.tomshardware.de:80/enterprise-hdd-sshd,testberichte-241390.html}} \footnote{\url{https://www.computerbase.de/2016-08/seagate-enterprise-capacity-3.5-hdd-10tb-test/}}};
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (51.center) -- (61.center) node[black, midway, xshift = 0.1cm, yshift = 0.1cm, anchor = west] {$s - min$};
                
                % Mark the source of the performance data of the volatile layers:
                \draw [decorate, decoration = {brace, amplitude = 3.75pt}]
                (0h.center) -- (31h.center) node[black, midway, xshift = -0.625cm, yshift = 0.1cm, anchor = west] {\footnotesize \begin{tabular}{r}\textit{\textbf{Example system:}}\\\textit{Intel\textsuperscript{\tiny\textregistered} Xeon\textsuperscript{\tiny\textregistered}}\\\textit{E3-1280 v5}\\\textit{(Skylake)}\footnote{\url{https://www.7-cpu.com/cpu/Skylake.html}}\end{tabular}};
                
                % Orientation of changes of performance data:
                \path[changes]
                ([xshift = (-1/3)*4cm+0.25cm]60.center) edge node[above, rotate = 90]  {\footnotesize Price per capacity} ([xshift = (-1/3)*14cm-0.25cm]0.center)
                ([xshift = (1/3)*18cm+0.5cm]0.center)   edge node[above, rotate = -90] {\footnotesize Access time}        ([xshift = (1/3)*8cm]61.center);
                \end{tikzpicture}
            }
        \end{minipage}
        \vspace{.5em}
        \caption[Storage hierarchy of computer systems]{Storage hierarchy of computer systems}
        \label{fig:storagehierarchy}
        \protect
    \end{figure}
\end{@empty}

    Bélády's optimal page replacement algorithm \cite{Belady:1966} evicts the one\linebreak page from the buffer pool that is \emph{not re-referenced for the longest time in the future}\footnote{The more practical 5 Minute Rule \cite{Gray:1987} which is derived from this algorithm is still valid \cite{Gray:1997}\cite{Graefe:2007}.}. However, this algorithm cannot make this decision at runtime, since this would require knowledge about future requests to the database. Therefore, page replacement algorithms that can be implemented in DBMS must use \emph{heuristics} to approximate the eviction decisions of Bélády's algorithm to achieve a high hit rate. These heuristics are usually based on the assumption that there is a temporal locality of the page references. The management of data in B-tree indices, which were developed 50 years ago to improve the spatial locality of references in order to reduce random disk access in database applications \cite{Bayer:1970}, increases the temporal locality of page references due to the hierarchical structure of B-trees in which higher-level pages are more likely to be referenced.

    The expected performance of these possible page replacement algorithms relative to the buffer pool size is shown in figure \ref{fig:missratebufferpoolsize}. In this diagram, $MR_{CS}$ is the minimum miss rate, which is greater than $0$ due to the page misses that occur when each page is first referenced after a cold start. The maximum miss rate $MR_{\text{max}}$ is less than $1$ due to the fact that there are always some random page hits, even with RANDOM eviction on workloads with no locality of references. $D$ is the database size and $B_{\text{min}}$ is the minimum buffer pool size that will still lead to a working system.

\begin{@empty}%
    \nottoggle{bwmode}{
        \tikzset{%
            plot/.style       = {smooth, mark = \empty},
            optimal/.style    = {very thick, color = green},
            best/.style       = {            color = blue},
            random/.style     = {very thick, color = red},
            noLocality/.style = {very thick, color = purple},
            possible/.style   = {pattern = north east lines, pattern color = blue!75}
        }
    }{
        \tikzset{%
            plot/.style       = {smooth, mark = \empty},
            optimal/.style    = {very thick, color = black},
            best/.style       = {            color = black!75},
            random/.style     = {very thick, dashed},
            noLocality/.style = {very thick, dotted},
            possible/.style   = {pattern = north east lines, pattern color = black!75}
        }
    }

    \begin{figure}[ht!]
        \resizebox{\textwidth}{.5\textwidth}{
            \begin{tikzpicture}
                \begin{axis}[xlabel = Buffer pool size $B$,
                             xmin = 0,
                             xmax = 105,
                             xtick = {5, 100},
                             xticklabels = {$B_{min}$, $D$},
                             ylabel = Miss rate $MR$,
                             ymin = 0,
                             ymax = 105,
                             ytick = {5, 95, 100},
                             yticklabels = {$MR_{CS}$, $MR_{max}$, $1$},
                             legend pos = north east,
                             area legend,
                             axis x line = bottom,
                             axis y line = left,
                             width = \textwidth,
                             height = {.5\textwidth}]
                    \addplot+[plot, optimal, name path = optimal, line legend] coordinates {
                        (5, 95)
                        (20, 25)
                        (50, 7.5)
                        (100, 5)
                    };
                    \addplot+[plot, best, name path = best, empty legend] coordinates {
                        (5, 95)
                        (20, 45)
                        (30, 27.5)
                        (50, 15)
                        (100, 5)
                    };
                    \addplot+[plot, random, name path = random, line legend] coordinates {
                        (5, 95)
                        (20, 60)
                        (35, 34)
                        (50, 22.5)
                        (100, 5)
                    };
                    \addplot+[plot, noLocality, name path = noLocality, line legend] coordinates {
                        (5, 95)
                        (100, 5)
                    };
                    \addplot[possible] fill between [of = best and random];
    
                    \legend{Optimal, , Random, No locality, Possible}
                \end{axis}
            \end{tikzpicture}
        }
        \caption[Connection between miss rate and buffer pool size]{Connection between miss rate and buffer pool size \cite{Effelsberg:1984}}
        \label{fig:missratebufferpoolsize}
    \end{figure}
\end{@empty}

    Besides the impossibility to implement Bélády's optimal page replacement algorithm, there are also technical limitations in the use of the possible page replacement algorithms. The abstract algorithms can \emph{evict any page} from the buffer pool \emph{at any time}. However, in a \emph{real-world system}, there are many reasons why a page that has been selected for eviction by the page replacement algorithm \emph{cannot be immediately evicted}. One reason, for example, is already visible in the typical interface of a buffer pool---a page can be \emph{fixed} and \emph{unfixed} by the higher layers of the DBMS. Between fixing and unfixing a page, it is guaranteed that it remains in the same buffer frame since the fixing thread processes the page during this time. Another problem for some page replacement algorithms is the possibility to explicitly evict pages from the buffer pool---independent from the decisions of the page replacement algorithm.

    The \emph{test system} used for this work knows the following reasons why a page in the buffer pool is either temporarily or permanently unreclaimable:
    \begin{itemize}
        \item Metadata pages can never be evicted.
        \item B-tree root pages can never be evicted.
        \item Inner B-tree pages can never be evicted when pointer swizzling (like in \cite{Graefe:2014}) is used in the buffer pool.
        \item B-tree pages with foster children (the Foster B-Tree from \cite{Graefe:2012} is used) cannot be evicted.
        \item Dirty pages cannot be evicted until they are written back.
        \item Pages pinned to the buffer pool by higher layers of the DBMS cannot be evicted.
    \end{itemize}
    
    All non-trivial page replacement algorithms collect statistics about page references to base their eviction decisions on. Simple implementations of these page replacement algorithms do not reflect in their statistics the fact that certain pages are temporarily or permanently unreclaimable. But treating pages found temporarily unreclaimable as a page reference and excluding pages that are permanently unreclaimable from the eviction could improve future eviction decisions or the runtime of the algorithm.

\section{Page Replacement Strategies} \label{sec:page_replacement_strategies}

    There are two traditional classifications for page replacement algorithms---Bélády's classification from \cite{Belady:1966} and the classification by Effelsberg and Härder from \cite{Effelsberg:1984}.

\begin{@empty}%
    \begin{table}[h!]
        \begin{labeleddescription}
            \item[Class 1] \label{intab:beladyclass1}  These replacement algorithms do not keep any statistics.
            \item[Class 2] \label{intab:beladyclass2}  These replacement algorithms keep statistics about the latest references of \emph{pages in the buffer pool} and use those for their decisions.
            \item[Class 3] \label{intab:beladyclass3}  These replacement algorithms keep statistics about each time \emph{any page} was fetched from the database and each time it was evicted from the buffer pool and use those for their decisions.
        \end{labeleddescription}
        \caption[Bélády's classification]{Bélády's classification of replacement algorithms from \cite{Belady:1966}}
        \label{tab:bclassification}
    \end{table}
\end{@empty}

    \pagebreak

    Bélády grouped the replacement algorithms into the \emph{three classes} described in table \ref{tab:bclassification}. The \nameref{subsec:random}, \nameref{subsec:fifo} and \nameref{subsec:filo} page replacement algorithms belong to \ref{intab:beladyclass1}, the modern (proposed after 2002) ARC \cite{Megiddo:2003}, CAR \cite{Bansal:2004}, CART \cite{Bansal:2004}, LIRS \cite{Jiang:2002}, CLOCK-Pro \cite{Jiang:2005}, DLIRS \cite{Li:2018} and CLOCK-Pro+ \cite{Li:2019} page replacement algorithms belong to \ref{intab:beladyclass3}. All the other page replacement algorithms (\nameref{subsec:lru}, \nameref{subsec:mru}, \nameref{subsec:lru-k} \cite{ONeil:1993}, \nameref{subsec:slru} \cite{Karedla:1994}, \nameref{subsec:clock} \cite{Corbato:1969}, \nameref{subsec:zclock}, \nameref{subsec:gclock} \cite{Effelsberg:1984}, \nameref{subsec:dgclock} \cite{Effelsberg:1984}, \nameref{subsec:lrd} \cite{Effelsberg:1984}, \nameref{subsec:lfu}, LFU-Aging \cite{Arlitt:2000-1}, \nameref{subsec:lfuda} \cite{Arlitt:2000-2}, 2Q \cite{Johnson:1994}, MQ \cite{Zhou:2001} and LeanStore \cite{Leis:2018}) belong to \ref{intab:beladyclass2}.

    The classification by Effelsberg and Härder is \emph{two-dimensional} as it takes into account if a page replacement algorithm considers the time since a certain reference of a page happened---the \emph{age}---and the number of references of a page---the \emph{references}. While this classification is \emph{very detailed}, it only covers the page replacement algorithms from \ref{intab:beladyclass1} and \ref{intab:beladyclass2} of Bélády's classification. Table \ref{tab:ehclassification} shows each page replacement algorithm covered in this thesis, classified in an extended version of the classification by Effelsberg and Härder.

\begin{@empty}%
    \renewcommand{\baselinestretch}{.6}
    \setcellgapes{2pt}
    \setlength\arrayrulewidth{.6pt}
    \makegapedcells
    \begin{table}[h]
        \footnotesize
        \resizebox{\textwidth}{!}{
            \begin{tabular}{|c|c|c|c|c|c|}
                \hline
                \multicolumn{2}{|c|}{%
                    \multirow{2}{*}{%
                        \textbf{%
                            \makecell[c]{%
                                Consideration\\%
                                during selection\\%
                                decision%
                            }%
                        }%
                    }%
                }                                   &
                \multicolumn{4}{c|}{%
                    \textbf{Age}%
                }                                                       \\ \cline{3-6}
%
                \multicolumn{2}{|c|}{}              &
                \makecell[c]{%
                    No\\%
                    consideration%
                }                                   &
                \makecell[c]{%
                    Since most\\%
                    recent reference%
                }                                   &
                \makecell[c]{%
                    Since some\\%
                    recent reference%
                }                                   &
                \makecell[c]{%
                    Since first\\%
                    reference%
                }                                                       \\ \hline
%
                \multirow{4}{*}{%
                    \rotcell[c]{%
                        \textbf{References}%
                    }%
                }                                   &
                \makecell[c]{%
                    No\\%
                    consideration%
                }                                   &
                \nameref{subsec:random}             &
                                                    &
                                                    &
                \makecell[c]{%
                    \nameref{subsec:fifo}\\%
                    \nameref{subsec:filo}%
                }                                                       \\ \cline{2-6}
                                                    &
                \makecell[c]{%
                    Most recent\\%
                    reference%
                }                                   &
                \nameref{subsec:zclock}             &
                \makecell[c]{%
                    \nameref{subsec:lru}\\%
                    \nameref{subsec:mru}\\%
                    \nameref{subsec:clock}\\%
                    \nameref{subsubsec:gclock-v2}\\%
                    \nameref{subsubsec:dgclock-v2}\\%
                    \nameref{subsec:leanstore}%
                }                                   &
                                                    &
                                                                        \\ \cline{2-6}
%
                                                    &
                \makecell[c]{%
                    Some recent\\%
                    references%
                }                                   &
                                                    &
                \nameref{subsec:slru}               &
                \makecell[c]{%
                    \nameref{subsec:lru-k}\\%
                    \nameref{subsubsec:lrd-v2}%
                }                                   &
                                                                        \\ \cline{2-6}
%
                                                    &
                \makecell[c]{%
                    All\\%
                    references%
                }                                   &
                \nameref{subsec:lfu}                &
                \makecell[c]{%
                    \nameref{subsubsec:gclock-v1}\\%
                    \nameref{subsubsec:dgclock-v1}%
                }                                   &       
                                                    &
                \makecell[c]{%
                    \nameref{subsubsec:lrd-v1}\\%
                    \nameref{subsec:lfuda}%
                }                                                       \\ \hline
            \end{tabular}
        }
        \vspace{2pt}
        \caption[Extended classification by Effelsberg and Härder]{Extended page replacement algorithm classification by Effelsberg and Härder from \cite{Effelsberg:1984}}
        \label{tab:ehclassification}
    \end{table}
\end{@empty}

\subsection{RANDOM} \label{subsec:random}

\paragraph{Introduction}

    RANDOM eviction is the \emph{simplest page replacement policy} because it does not keep statistics on past page references---just a random page from the buffer pool is selected for eviction.
    
    In the course of the \emph{history} of computer science many pseudo-random number generators (PRNG) have been developed. A performance evaluation of \emph{98 PRNGs} related to DB buffer page replacement algorithms in my Project Thesis \cite{Gilbert:2020} revealed that each PRNG is suitable for implementing a RANDOM page replacement algorithm. The evaluated PRNGs lead to \emph{identical hit rates} and therefore the one with the \emph{lowest overhead} per generated random number---that is the index of the buffer frame that is reclaimed---should be chosen. Therefore, \emph{SplitMix32} is used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}.

\paragraph{Advantages}

    The main advantage of the RANDOM page replacement policy over the \ref{intab:beladyclass2} and \ref{intab:beladyclass3} competitors is that it does not cause \emph{overhead} for page hits, while the more complex page replacement algorithms always have to update their page reference statistics. In situations where hit rates are high nevertheless, such as when the entire database fits in the buffer pool---which is not uncommon in modern database systems---RANDOM eviction is the \emph{fastest page replacement policy}.

\paragraph{Disadvantages}

    For the RANDOM page replacement policy, none of the pages in the buffer pool are more likely to be referenced again than any other page in it. This results in poor hit rates---compared to more sophisticated page replacement algorithms---but due to the locality of the page references, the hit rate is not even close to \SI{0}{\percent}, because, in general, the pages in the buffer pool are more likely to be referenced than the pages that are currently not in the buffer pool.

    It is, for example, possible that the RANDOM page replacement algorithm selects a B-tree root page, normally located in the DB's working set, for eviction---the possibility is small because there are usually millions of buffer frames in a DB buffer pool, but only a few B-tree indexes---each with only one root page. But due to the fact that a B-tree root page must be fixed for each search in its corresponding B-tree, it is more likely that these pages are fixed at a certain point in time---where they are then not eligible for eviction---than any other page, even though they usually contain fewer keys than the inner B-tree pages and are therefore fixed for a shorter time per search access.

\subsection[FIFO]{First In, First Out (FIFO)} \label{subsec:fifo}

    The FIFO page replacement policy always evicts the \emph{oldest page first}---it organizes the buffer frames in a \emph{FIFO queue}, which is usually implemented as a circular buffer. The idea behind FIFO page eviction is that the more recently fetched pages are more likely to be referenced again than pages fetched a long time ago. An obvious \emph{counterexample} against the optimality of this heuristic is the B-tree root, which is accessed first when searching in a B-tree, but which has the highest probability of being referenced again.

\subsubsection{LOOP} \label{subsubsec:loop}

\paragraph{Introduction}

    FIFO page eviction can be easily implemented in the buffer pool by arranging the buffer frames (\numrange{0}{15} in the example) in a \emph{circular buffer}, as shown in figure \ref{fig:loop}. The oldest page in the buffer pool, $P_{58}$ in the example, is at the head of the FIFO queue and is therefore evicted next. The last page fetched is $P_{6}$ in buffer frame 14. After $P_58$ is evicted, the buffer frame 15 contains the newest page in the buffer pool and is therefore the tail of the FIFO queue. The oldest page in the buffer pool is then $P_{31}$ in buffer frame 0 which is now the head of the FIFO queue.

\begin{@empty}%
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}[>=latex,
                            semithick,
                            scale = 2.5]
            % Draw the buffer frames in the circular buffer:
            \draw [thick, fill = black!10] (0,0) circle (1);
            \foreach \angle in {90, 67.5, ..., -67.5}
                \draw (\angle:1) -- (\angle-180:1);
            \node [circle, thick, fill = white, draw = black, minimum size = 3.75cm] at (0,0) {\Large \shortstack[c]{Buffer\\pool}};

            % Draw the buffer indices:
            \foreach \index/\pageindex in {0/31, 1/52, 2/28, 3/50, 4/11, 5/47, 6/49, 7/23, 8/2, 9/38, 10/43, 11/51, 12/48, 13/56, 14/6, 15/58} {
                \node [] at (90-11.25-\index*22.5:1.1) {\index};
                \node [] at (90-11.25-\index*22.5:0.875) {$P_{\pageindex}$};
            }

            \draw [<-] (123.75:1.2) -- (123.75:1.333) -- +(-.333,0)
                node [right, inner xsep = .125cm, anchor = east] (Tail) {Tail};
            \draw [<-] (101.25:1.2) -- (101.25:1.333) -- +(-.125,0)
                node [right, inner xsep = .125cm, anchor = east] (Head) {Head (evict next)};
            \draw [->, thick] (0,0)+(90:1.333) arc [start angle = 90, end angle = 45, radius = 1.333];
        \end{tikzpicture}
        \vspace{.5em}
        \caption[Buffer pool as circular buffer]{The buffer pool arranged as a circular buffer}
        \label{fig:loop}
        \protect
    \end{figure}
\end{@empty}

\paragraph{Page Eviction}

    The page eviction module of the buffer manager therefore simply reclaims buffer frames based on a cyclic counter---im\-ple\-men\-ted e.g. by taking the modulo of a simple infinite counter. This counter-based implementation---\emph{LOOP}---is therefore comparable to a \nameref{subsec:random} page replacement algorithm with a \emph{trivial "pseudo-random" number generator}:
    \begin{itemize}
        \item State word initialized with $0$ (seed)
        \item Next state generated by simple increment
        \item Identity function is used to map the state word to the returned "pseudo-random" number
    \end{itemize}

    If it is temporarily or permanently \emph{not possible to evict} the page at the head of the FIFO queue, the LOOP page replacement algorithm continues iterating over the circular buffer and suddenly places the oldest page in the buffer pool at the tail of the FIFO queue. This leads to a significant deviation from the algorithmic idea of the \nameref{subsec:fifo} page replacement policy. If there are many non-reclaimable buffer frames, the actual page replacements are rather random.

    An evaluation of different implementations was conducted for my Project Thesis \cite{Gilbert:2020}. The very fast \emph{Local Counter} was used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation} because it scored best in the performance evaluation of my Project Thesis. But this variant \emph{does not properly implement the \nameref{subsec:fifo} page replacement policy} because each working thread uses its thread-local counter. As a result, even in a system with only two working threads---if the counter of one of the threads is only $1$ behind the counter of the other thread---a thread will evict from the buffer pool a page that was just fetched into it by the other thread.

\subsubsection{Quasi-FIFO} \label{subsubsec:quasi-fifo}

\paragraph{Introduction}

    The \emph{Quasi-FIFO} implementation now strives to produce a behavior closer to the \nameref{subsec:fifo} page replacement policy. It does not simply interpret the buffer pool as a circular buffer---like the \nameref{subsubsec:loop} page replacement algorithm---but use more complex data structures for its page reference statistics (figure \ref{fig:fifo}) and more complicated control structures for determining replacement candidates (Algorithm \ref{alg:FIFOselect}).

\paragraph{Data Structures}

    As presented in figure \ref{fig:fifo}, the page reference statistics of the Quasi-FIFO implementation is composed of two queues, the \textit{FIFO queue} and the \textit{retry queue}, and the notExplicitlyEvictedList array, which is used to flag pages that have been explicitly removed from the buffer pool without involving the page replacement algorithm. The currentlyCheckingRetryQueue flag and the currentQueueChecks counter are used by the threads that evict pages to balance page evictions between the \textit{FIFO queue} and the \textit{retry queue}.

\begin{@empty}%
    \tikzset{%
        every picture/.append style = {>=latex,
                                       thick,
                                       scale = 2.5}
    }

    \begin{figure}
        \centering
        \begin{minipage}{.6\columnwidth}
            \begin{tikzpicture}
                % Draw the FIFO queue:
                \draw [fill = black!10] (0,0) circle (1);
                \foreach \angle in {90, 60, ..., -60}
                    \draw (\angle:1) -- (\angle-180:1);
                \node [circle, fill = white, draw = black, minimum size = 3.75cm] at (0,0) {\Large \shortstack[c]{FIFO\\queue}};

                % Draw the buffer indices:
                \node [] at ( 75:0.875)  {0};
                \node [] at  (45:0.875)  {1};
                \node [] at ( 15:0.875)  {2};
                \node [] at (345:0.875)  {3};
                \node [] at (315:0.875)  {5};
                \node [] at (285:0.875)  {6};
                \node [] at (255:0.875)  {8};
                \node [] at (225:0.875) {11};
                \node [] at (195:0.875) {12};
                \node [] at (165:0.875) {13};
                \node [] at (135:0.875) {14};
                \node [] at (105:0.875) {15};

                \draw [<-] (135:1) -- (135:1.2) -- +(-.333,0)
                    node [right, inner xsep = .125cm, anchor = east] (Tail) {Tail};
                \draw [<-] (105:1) -- (105:1.2) -- +(-.125,0)
                    node [right, inner xsep = .125cm, anchor = east] (Head) {Head};
                \draw [->] (0,0)+(90:1.2) arc [start angle = 90, end angle = 30, radius = 1.2];
            \end{tikzpicture}%
        \end{minipage}%
        \begin{minipage}{.4\columnwidth}
            \begin{tikzpicture}
                % Draw the retry queue:
                \draw [fill = black!10] (0,0) circle (.5);
                \foreach \angle in {90, 0}
                    \draw (\angle:.5) -- (\angle-180:.5);
                \node [circle, fill = white, draw = black, minimum size = 1.25cm] at (0,0) {\shortstack[c]{retry\\queue}};
                
                % Draw the buffer indices:
                \node [] at ( 45:0.4)  {7};
                \node [] at (315:0.4)  {9};
                \node [] at (225:0.4) {10};
                \node [] at (135:0.4)  {4};

                \draw [<-] (225:.5) -- (225:.7) -- +(-.125,0)
                    node [right, inner xsep = .125cm, anchor = east] (Tail) {Tail};
                \draw [<-] (135:.5) -- (135:.7) -- +(-.125,0)
                    node [right, inner xsep = .125cm, anchor = east] (Head) {Head};
                \draw [->, thick] (0,0)+(90:.7) arc [start angle = 90, end angle = -90, radius = .7];
            \end{tikzpicture}
        \end{minipage} \\
        \vspace{-.5em}
        \begin{tikzpicture}[boolRectangle/.style = {draw = black, thick, rectangle, minimum width = width("false")+.6666em}]
            \node [draw = none]  (currentlyCheckingRetryQueue)               {currentlyCheckingRetryQueue};
            \node [boolRectangle, right = 0em of currentlyCheckingRetryQueue, fill = black!10] (currentlyCheckingRetryQueueValue) {true};
            \node [draw = none, right = 3em of currentlyCheckingRetryQueue] (currentQueueChecks) {currentQueueChecks};
            \node [rectangle, draw = black, right = 0em of currentQueueChecks, fill = black!10] (currentQueueChecksValue) {15};
            \node[rectangle, draw = black, inner sep = .15em, fit = (currentlyCheckingRetryQueue)(currentlyCheckingRetryQueueValue)(currentQueueChecks)(currentQueueChecksValue), label = {Thread 0}] {};
        \end{tikzpicture} \\
        \vspace{.25em}
        \begin{tikzpicture}[boolRectangle/.style = {draw = black, thick, rectangle, minimum width = width("false")+.6666em}]
            \node [draw = none]  (currentlyCheckingRetryQueue)               {currentlyCheckingRetryQueue};
            \node [boolRectangle, right = 0em of currentlyCheckingRetryQueue, fill = black!10] (currentlyCheckingRetryQueueValue) {false};
            \node [draw = none, right = 3em of currentlyCheckingRetryQueue] (currentQueueChecks) {currentQueueChecks};
            \node [rectangle, draw = black, right = 0em of currentQueueChecks, minimum width = width("15")+.6666em, fill = black!10] (currentQueueChecksValue) {0};
            \node[rectangle, draw = black, inner sep = .15em, fit = (currentlyCheckingRetryQueue)(currentlyCheckingRetryQueueValue)(currentQueueChecks)(currentQueueChecksValue), label = {Thread 1}] {};
        \end{tikzpicture} \\
        \vspace{.25em}
        \begin{tikzpicture}
            \node [draw = none] {\LARGE $\vdots$};
        \end{tikzpicture} \\
        \vspace{-.5em}
        \begin{tikzpicture}[font = \small,
                            boolRectangle/.style = {draw = black, thick, rectangle, inner xsep = .1111em, fill = black!10}]
            \node [boolRectangle, label = below: 0]                             (index0) {true};
            \node [boolRectangle, label = below: 1, right = -0.8pt of  index0]  (index1) {true};
            \node [boolRectangle, label = below: 2, right = -0.8pt of  index1]  (index2) {true};
            \node [boolRectangle, label = below: 3, right = -0.8pt of  index2]  (index3) {true};
            \node [boolRectangle, label = below: 4, right = -0.8pt of  index3]  (index4) {true};
            \node [boolRectangle, label = below: 5, right = -0.8pt of  index4]  (index5) {true};
            \node [boolRectangle, label = below: 6, right = -0.8pt of  index5]  (index6) {true};
            \node [boolRectangle, label = below: 7, right = -0.8pt of  index6]  (index7) {true};
            \node [boolRectangle, label = below: 8, right = -0.8pt of  index7]  (index8) {true};
            \node [boolRectangle, label = below: 9, right = -0.8pt of  index8]  (index9) {true};
            \node [boolRectangle, label = below:10, right = -0.8pt of  index9] (index10) {true};
            \node [boolRectangle, label = below:11, right = -0.8pt of index10] (index11) {true};
            \node [boolRectangle, label = below:12, right = -0.8pt of index11] (index12) {true};
            \node [boolRectangle, label = below:13, right = -0.8pt of index12] (index13) {true};
            \node [boolRectangle, label = below:14, right = -0.8pt of index13] (index14) {true};
            \node [boolRectangle, label = below:15, right = -0.8pt of index14] (index15) {true};

            \node [above = 1.25em of index0.west, anchor = west]{notExplicitlyEvictedList};
        \end{tikzpicture}
        \vspace{1em}
        \caption[Page reference statistics of Quasi-FIFO]{The page reference statistics of the Quasi-FIFO page replacement algorithm after almost a complete iteration over the buffer pool}
        \label{fig:fifo}
        \protect
    \end{figure}
\end{@empty}

    The \emph{example} shows the page reference statistics of the Quasi-FIFO page replacement algorithm operating on a buffer pool with \num{16} buffer frames---\numrange{0}{15}---, after the events described in this paragraph. Before the first pages were fetched from the database, both the \textit{FIFO queue} and the \textit{repeat queue} were empty. After \num{16} pages were fetched into the buffer pool, all buffer frame indexes were in the \textit{FIFO queue}---0 at the head and 15 at the tail---and the \textit{retry queue} was still empty since it was not yet necessary to try to evict pages from the buffer pool.

    Then thread 0 successfully reclaimed buffer frame 0 and increased its currentQueueChecks counter to \num{1}. Afterward, buffer frame 0 was reused and 0 was added to the tail of the \textit{FIFO queue}. Since the page reference statistics do not contain information about the pages in the buffer frames, the changed ID of the page stored in the buffer frame 0 is not reflected there. Subsequently thread 0 did the same with the buffer frames \numlist{1;2;3}.

    When the buffer frame index 4 was at the head of the \textit{FIFO queue}, it was not reclaimable, and thread 0 moved the buffer index from the head of the \textit{FIFO queue} to the tail of the \textit{retry queue} for later retrying. The page from the buffer frame 5 was then successfully evicted. The figure shows the \emph{state} of the page reference statistics after thread 0 checked \num{15} pages for eviction (currentQueueChecks) and the pages from buffer frames \numlist{0;1;2;3;5;6;8;11;12;13;14} were successfully evicted. The buffer frames \numlist{4;7;9;10} were found to be unreclaimable. No retries were made to reclaim a buffer frame that was found to be unreclaimable, and no page was explicitly evicted.

\begin{@empty}
    \begin{algorithm}[ht!]
        \scriptsize
        \resizebox*{!}{\dimexpr\textheight-5\baselineskip\relax}{%
            \begin{minipage}{\linewidth}%
                \begin{algorithmic}[1]
                    \Function{select}{}
                        \State $\text{selected} \gets 0$
                        \State $\textbf{static } \text{currentlyCheckingRetryQueue} \gets \text{false}$
                        \State $\textbf{static } \text{currentQueueChecks} \gets 0$
                        \While{$\text{true}$}
                            \If{$\text{currentlyCheckingRetryQueue} == \text{false}$}
                                \If{$\text{currentQueueChecks} < 0.01 * \left|\text{FIFOQueue}\right| \vee \left|\text{retryQueue}\right| == 0$}
                                    \State $\text{selected} \gets \text{FIFOQueue.pop()}$
                                    \State $\text{currentQueueChecks} \gets \text{currentQueueChecks} + 1$
                                    \If{$\text{notExplicitlyEvictedList}\left[\text{selected}\right] == \text{true}$}
                                        \Return $\text{selected}$
                                    \Else
                                        \State $\text{notExplicitlyEvictedList}\left[\text{selected}\right] \gets \text{true}$
                                        \State $\textbf{continue}$
                                    \EndIf
                                \Else
                                    \State $\text{selected} \gets \text{retryQueue.pop()}$
                                    \If{$\text{notExplicitlyEvictedList}\left[\text{selected}\right] == \text{true}$}
                                        \State $\text{currentQueueChecks} \gets 0$
                                        \State $\text{currentlyCheckingRetryQueue} \gets \text{true}$
                                        \Return $\text{selected}$
                                    \Else
                                        \State $\text{notExplicitlyEvictedList}\left[\text{selected}\right] \gets \text{true}$
                                        \State $\textbf{continue}$
                                    \EndIf            
                                \EndIf
                            \Else
                                \If{$\text{currentQueueChecks} < \left|\text{retryQueue}\right| \vee \left|\text{FIFOQueue}\right| == 0$}
                                    \State $\text{selected} \gets \text{retryQueue.pop()}$
                                    \State $\text{currentQueueChecks} \gets \text{currentQueueChecks} + 1$
                                    \If{$\text{notExplicitlyEvictedList}\left[\text{selected}\right] == \text{true}$}
                                        \Return $\text{selected}$
                                    \Else
                                        \State $\text{notExplicitlyEvictedList}\left[\text{selected}\right] \gets \text{true}$
                                        \State $\textbf{continue}$
                                    \EndIf
                                \Else
                                    \State $\text{selected} \gets \text{FIFOQueue.pop()}$
                                    \If{$\text{notExplicitlyEvictedList}\left[\text{selected}\right] == \text{true}$}
                                        \State $\text{currentQueueChecks} \gets 0$
                                        \State $\text{currentlyCheckingRetryQueue} \gets \text{false}$
                                        \Return $\text{selected}$
                                    \Else
                                        \State $\text{notExplicitlyEvictedList}\left[\text{selected}\right] \gets \text{true}$
                                        \State $\textbf{continue}$
                                    \EndIf            
                                \EndIf
                            \EndIf
                        \EndWhile
                    \EndFunction
                \end{algorithmic}%
            \end{minipage}%
        }
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{select}} of Quasi-FIFO]{Selection of eviction candidates by the Quasi-FIFO page replacement algorithm}
        \label{alg:FIFOselect}
    \end{algorithm}
\end{@empty}

    Important to achieve behavior closer to the abstract FIFO page replacement strategy is to balance the eviction of pages from both queues---\textit{FIFO queue} and \textit{retry queue}. This results in the relatively\footnote{compared to the simplicity of the abstract FIFO page replacement strategy} high complexity of the control structures in the {\footnotesize \textbf{function} \textsc{select}} from Algorithm \ref{alg:FIFOselect}.

    According to the abstract FIFO strategy, the pages in the \textit{retry queue} should have already been evicted from the buffer pool, so the further eviction should \emph{concentrate} on these pages. However, since some of the reasons why a page cannot be evicted temporarily are relatively long-lasting (dirty, foster children) and others indicate that a page is very hot (fixed, pinned), it is more likely that the pages in the \textit{retry queue} can---again---not be evicted, and therefore, too much concentration of the eviction on the \textit{retry queue} would significantly degrade the performance. Pages that cannot be evicted permanently should be excluded from the eviction as an \emph{additional optimization} because they would be permanently included in the \textit{retry queue} and therefore, the eviction of these pages would be tried repeatedly, which would reduce the overall performance.

    As Algorithm \ref{alg:FIFOselect} reveals, every working thread alternates its eviction activities between the two queues---after trying to reclaim \SI{1}{\percent} of the buffer frames in the \textit{FIFO queue}, it tries to reclaim every buffer frame in the \textit{retry queue}. This gives a clear focus on the idea behind the FIFO page replacement strategy and sets the Quasi-FIFO page replacement algorithm off against the \nameref{subsubsec:loop} page replacement algorithm.

\subsection[FILO]{First In, Last Out (FILO)} \label{subsec:filo}

    The FILO page replacement strategy always evicts the \emph{newest page first}---it arranges the buffer frames in a \emph{FILO stack}. It can therefore be considered the opposite of the \nameref{subsec:fifo} page replacement strategy. This strategy results in very poor performance, because in a buffer pool with $n$ buffer frames, the $(n-1)$ pages fetched first from the buffer pool remain there permanently, and only the last page fetched is replaced \emph{over and over again}, resulting in a very low hit rate. However, for pages fetched during a table scan, this page replacement algorithm is perfectly suitable as each page is only accessed once, and therefore it could be part of a dynamic page replacement algorithm that uses different page replacement algorithms for different \emph{reference patterns}.

    But the implementation of the \nameref{subsubsec:quasi-fifo} and FILO page replacement algorithms leads to identical problems with unreclaimable buffer frames, and thus the same solutions to these problems are used in the implementations of both replacement algorithms. In addition to the \textit{FILO stack}, a \textit{retry queue} is used\footnote{The \textit{FIFO queue} from figure \ref{fig:fifo}is just replaced with the \textit{FILO stack}.}. The algorithm used to select the buffer frames for eviction is almost identical to the one used for the \nameref{subsubsec:quasi-fifo} page replacement algorithm (Algorithm \ref{alg:FIFOselect}), but instead of the \textit{FIFO queue}, a \textit{FILO stack} is used. However, because the newest page in the buffer pool is usually still fixed, almost all pages selected for eviction are placed in the \textit{retry queue}, degrading this \emph{Quasi-FILO} to FIFO.

\subsection[LRU]{Least Recently Used (LRU)} \label{subsec:lru}

    The LRU page replacement algorithm improves on the idea of the \nameref{subsec:fifo} page replacement algorithm by considering the time of the last reference to a page, rather than the time it was last fetched from the database file into the buffer pool.  It is probably the \emph{most widespread} approach, both in operating system virtual memory management and in DBMS buffer management.

    The \emph{intuition} behind the algorithm is that of all pages in the buffer pool, the page that has not been referenced for the longest time in the past (least recently used) will not be referenced for the longest time in the future (Bélády's optimal page replacement algorithm). Although this heuristic is quite intuitive, it is not immune to \emph{suboptimal replacement decisions}. LRU is not scan resistant and prone to page thrashing. The lack of \emph{scan resistance} means that in the case of a table scan, a large number of pages that are usually referenced only once (cold pages) will probably replace all or at least many other pages in the buffer pool---including the hot ones---just because all these pages are used more recently than any previously referenced pages. \emph{Thrashing} refers to a behavior of page replacement algorithms that results in a very low hit rate when the working set of the database is just larger than the buffer pool. For example, if the inner loop of a nested loop join is just one page larger than the buffer pool, LRU will always evict the page used next, resulting in a page fault rate of \SI{100}{\percent} (much worse than with \nameref{subsec:random} page replacement), even though a hit rate of almost \SI{100}{\percent} could be achieved by sharing only one buffer frame between two pages (with page faults whenever one of these pages is referenced).

\subsubsection[Hash-Map-Doubly-Linked-List]{Hash-Map-Doubly-Linked-List Implementation} \label{subsubsec:lru_traditional}

\paragraph{Introduction}

    The most straightforward approach for implementing the LRU page replacement strategy uses a \emph{queue} into which each buffer frame index is inserted when a page is fetched into the respective buffer frame. For each page reference, the respective buffer frame index is moved to the tail of the queue. And the buffer frame at the head of the queue is always the one that is reclaimed during eviction.

\paragraph{Page Reference Statistics}

    Because of the requirement to find and remove a specific element (buffer frame index) at any position in the queue (whenever a page reference occurs), an \emph{abstract data type} implementing a simple queue with \emph{enqueue} and \emph{dequeue} operations cannot be used. The \emph{Hash-Map-Doubly-Linked-List implementation} uses a queue implemented using a doubly-linked list inside a hash map (a simple array can be used alternatively), because searching in a bare doubly-linked list would otherwise require traversing all elements from the tail of the queue to the searched buffer frame index, which would require traversing \emph{less than half} of all elements ($\mathcal{O}\left(n\right)$) due to the locality of the page references.

\begin{@empty}%
    \tikzset{%
        queueelement/.style = {draw = black,
                               rectangle},
        queuereferences/.style = {draw = black,
                                  rectangle split,
                                  rectangle split parts = 2,
                                  rectangle split horizontal,
                                  text = black!75,
                                  inner xsep = .75pt}
    }
    \newcommand{\queueelement}[4]{%
        \node [{queuereferences, #4}] ({#2})%
            {#1\nodepart{two}#3};%
        \node [queueelement, above = -.6pt of {#2}] (center#2) {\textbf{#2}};
    }
    \newcommand{\getAngle}[2]{%
        \pgfmathanglebetweenpoints{\pgfpointanchor{#1}{center}}{\pgfpointanchor{#2}{center}}
        \global\let\calculatedAngle\pgfmathresult
    }

    \begin{figure}[h]
        \centering
        \resizebox{\textwidth}{!}{%
            \begin{tikzpicture}[>=latex,
                                semithick,
                                node distance = 1em]
                % Draw the hash map root:
                \node [draw = black, rectangle, thick] (hashmap) {hashMap};

                % Draw the queue elements:
                \node [below = 5em of hashmap] (center) {};
                \queueelement{7}{0}{6}{left = .5em of center.base}
                \queueelement{0}{6}{13}{right = .5em of center.base}
                \queueelement{10}{7}{0}{left = of 0}
                \queueelement{6}{13}{1}{right = of 6}
                \queueelement{2}{10}{7}{left = of 7}
                \queueelement{13}{1}{5}{right = of 13}
                \queueelement{14}{2}{10}{left = of 10}
                \queueelement{1}{5}{3}{right = of 1}
                \queueelement{15}{14}{2}{left = of 2}
                \queueelement{5}{3}{12}{right = of 5}
                \queueelement{9}{15}{14}{left = of 14}
                \queueelement{3}{12}{11}{right = of 3}
                \queueelement{8}{9}{15}{left = of 15}
                \queueelement{12}{11}{4}{right = of 12}
                \queueelement{NULL}{8}{9}{left = of 9}
                \queueelement{11}{4}{NULL}{right = of 11}

                % Draw the arrows to the queue elements:
                \foreach \element in {0, 1, ..., 15} {%
                    \getAngle{hashmap}{center\element}
                    \draw [->] (hashmap) to [in = 90, out = \calculatedAngle, looseness = .375] (center\element.north);
                }

                % Draw the arrows between the queue elements:
                \draw [->, draw = black!50]  (8) to [in = 180, out = 0]  (center9);
                \draw [->, draw = black!50]  (9) to [in = 180, out = 0] (center15);
                \draw [->, draw = black!50] (15) to [in = 180, out = 0] (center14);
                \draw [->, draw = black!50] (14) to [in = 180, out = 0]  (center2);
                \draw [->, draw = black!50]  (2) to [in = 180, out = 0] (center10);
                \draw [->, draw = black!50] (10) to [in = 180, out = 0]  (center7);
                \draw [->, draw = black!50]  (7) to [in = 180, out = 0]  (center0);
                \draw [->, draw = black!50]  (0) to [in = 180, out = 0]  (center6);
                \draw [->, draw = black!50]  (6) to [in = 180, out = 0] (center13);
                \draw [->, draw = black!50] (13) to [in = 180, out = 0]  (center1);
                \draw [->, draw = black!50]  (1) to [in = 180, out = 0]  (center5);
                \draw [->, draw = black!50]  (5) to [in = 180, out = 0]  (center3);
                \draw [->, draw = black!50]  (3) to [in = 180, out = 0] (center12);
                \draw [->, draw = black!50] (12) to [in = 180, out = 0] (center11);
                \draw [->, draw = black!50] (11) to [in = 180, out = 0, in looseness = 2]  (center4);
                \draw [->, draw = black!50]  (4) to [in = 0, out = 180] (center11);
                \draw [->, draw = black!50] (11) to [in = 0, out = 180] (center12);
                \draw [->, draw = black!50] (12) to [in = 0, out = 180]  (center3);
                \draw [->, draw = black!50]  (3) to [in = 0, out = 180]  (center5);
                \draw [->, draw = black!50]  (5) to [in = 0, out = 180]  (center1);
                \draw [->, draw = black!50]  (1) to [in = 0, out = 180] (center13);
                \draw [->, draw = black!50] (13) to [in = 0, out = 180]  (center6);
                \draw [->, draw = black!50]  (6) to [in = 0, out = 180]  (center0);
                \draw [->, draw = black!50]  (0) to [in = 0, out = 180]  (center7);
                \draw [->, draw = black!50]  (7) to [in = 0, out = 180] (center10);
                \draw [->, draw = black!50] (10) to [in = 0, out = 180]  (center2);
                \draw [->, draw = black!50]  (2) to [in = 0, out = 180] (center14);
                \draw [->, draw = black!50] (14) to [in = 0, out = 180] (center15);
                \draw [->, draw = black!50] (15) to [in = 0, out = 180]  (center9);
                \draw [->, draw = black!50]  (9) to [in = 0, out = 180, in looseness = 2]  (center8);

                \node (head)     [draw = black, rectangle, text = black!75, above = 2em of center8] {8};
                \node (headname) [above = .125em of head]                                           {head};
                \draw [->, draw = black!50] (head) to [bend right]  (center8);
                \node (tail)     [draw = black, rectangle, text = black!75, above = 2em of center4] {4};
                \node (tailname) [above = .125em of tail]                                           {tail};
                \draw [->, draw = black!50] (tail) to [bend  left]  (center4);
            \end{tikzpicture}
        }
        \vspace{-.5em}
        \caption[LRU: Hash-Map-Doubly-Linked-List]{Implementation of the LRU queue using a doubly-linked list inside a hash map}
        \label{fig:hashmapdoublylinkedlist}
    \end{figure}
\end{@empty}

    Figure \ref{fig:hashmapdoublylinkedlist} shows such a double-linked list within a hash map used to obtain a queue with the special properties required for the LRU page replacement algorithm. The hashMap can be any suitable hash map implementation that maps a buffer frame index (e.g., \textbf{10}) to its corresponding previous and next pointers (e.g., \textcolor{black!75}{2} and \textcolor{black!75}{7}). The order of the buffer frame indices in the queue (shown in the figure) does not necessarily correspond to the way the hashMap organizes the elements (not specified in the figure). A call to $\text{hashMap}\left[10\right]$ will return $\left(2, 7\right)$.

\paragraph{Updates of the Page Reference Statistics}

\begin{@empty}
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{enqueue}{$\text{key}$}
                \If{$\left|\text{hashMap}\right| \neq 0$}
                    \If{$\text{hashMap}\left[\text{key}\right] \neq \text{NULL}$}
                        \State \Return $\text{ERROR!}$
                    \EndIf
                    \State $\text{hashMap}\left[\text{key}\right] \gets \left(\text{tail}, \text{NULL}\right)$
                    \State $\text{hashMap}\left[\text{tail}\right].\text{next} \gets \text{key}$
                    \State $\text{tail} \gets \text{key}$
                \Else
                    \State $\text{hashMap}\left[\text{key}\right] \gets \left(\text{NULL}, \text{NULL}\right)$
                    \State $\text{head} \gets \text{key}$
                    \State $\text{tail} \gets \text{key}$
                \EndIf
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{enqueue}} of Hash-Map-Doubly-Linked-List]{Enqueue an index into the Hash-Map-Doubly-Linked-List}
        \label{alg:hashmapdoublylinkedlistenqueue}
    \end{algorithm}
\end{@empty}

\begin{@empty}
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{dequeue}{}
                \If{$\left|\text{hashMap}\right| = 1$}
                    \State $\text{hashMap}\left[\text{head}\right] \gets \text{NULL}$
                    \State $\text{head} \gets \text{NULL}$
                    \State $\text{tail} \gets \text{NULL}$
                \ElsIf{$\left|\text{hashMap}\right| > 1$}
                    \State $\text{oldHead} \gets \text{head}$
                    \State $\text{hashMap}\left[\text{hashMap}\left[\text{oldHead}\right].\text{next}\right].\text{previous} \gets \text{NULL}$
                    \State $\text{hashMap}\left[\text{oldHead}\right] \gets \text{NULL}$
                \Else
                    \State \Return $\text{ERROR!}$
                \EndIf
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{dequeue}} of Hash-Map-Doubly-Linked-List]{Dequeue an index from the Hash-Map-Doubly-Linked-List}
        \label{alg:hashmapdoublylinkedlistdequeue}
    \end{algorithm}
\end{@empty}

\begin{@empty}
    \begin{algorithm}[h!]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{remove}{$\text{key}$}
                \If{$\text{hashMap}\left[\text{key}\right] \neq \text{NULL}$}
                    \If{$\text{hashMap}\left[\text{key}\right].\text{next} \neq \text{NULL}$}
                        \State $\text{hashMap}\left[\text{hashMap}\left[\text{key}\right].\text{next}\right].\text{previous} \gets \text{hashMap}\left[\text{key}\right].\text{previous}$
                    \Else
                        \State $\text{tail} \gets \text{hashMap}\left[\text{key}\right].\text{previous}$
                    \EndIf
                    \If{$\text{hashMap}\left[\text{key}\right].\text{previous} \neq \text{NULL}$}
                        \State $\text{hashMap}\left[\text{hashMap}\left[\text{key}\right].\text{previous}\right].\text{next} \gets \text{hashMap}\left[\text{key}\right].\text{next}$
                    \Else
                        \State $\text{head} \gets \text{hashMap}\left[\text{key}\right].\text{next}$
                    \EndIf
                    \State $\text{hashMap}\left[\text{key}\right] \gets \text{NULL}$
                \Else
                    \State \Return $\text{ERROR!}$
                \EndIf
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} remove} of Hash-Map-Doubly-Linked-List]{Remove an index from the Hash-Map-Doubly-Linked-List}
        \label{alg:hashmapdoublylinkedlistremove}
    \end{algorithm}
\end{@empty}

    The operations for enqueuing (Algorithm \ref{alg:hashmapdoublylinkedlistenqueue}), dequeuing (Algorithm \ref{alg:hashmapdoublylinkedlistdequeue}) and removing (Algorithm \ref{alg:hashmapdoublylinkedlistremove}) a specific buffer pool index are rather trivial, but are nevertheless given here for clarification.

    An eviction candidate is selected by dequeuing a buffer frame index from the LRU queue. If it cannot be evicted, it is enqueued again. When a page is fetched into the buffer pool, the corresponding buffer frame index is enqueued in the LRU queue, and when a page hit occurs, the corresponding buffer index is removed from the LRU queue and enqueued again.

    A very important part of the implementation has been left out so far. Since there are usually many working threads processing transactions \emph{concurrently} in a modern DBS, there are multiple threads referencing pages concurrently and thus updating the page reference statistics concurrently. For this reason, accesses to the LRU queue must be \emph{synchronized}, which is simply done here via a \emph{global latch} for the entire queue. But such a global latch, acquired during every page fix, severely limits the concurrent transaction processing of the entire DBS and thus becomes a bottleneck of the system. An implementation that scales better with the number of threads is described in the next subsection \ref{subsubsec:lru_timestamp}.

\subsubsection[Timestamp-Sorting]{Timestamp-Sorting Implementation} \label{subsubsec:lru_timestamp}

\paragraph{Introduction}

    While page hit and page miss overhead is the same for the \nameref{subsubsec:lru_traditional} implementation of the LRU page replacement strategy, the Timestamp-Sorting implementation is \emph{optimized for} (on average) fast updates of page reference statistics on \emph{page hits}. As the name suggests, this implementation records the \emph{timestamp of the last page reference} for each buffer frame, and \emph{sorts the buffer frames} by these timestamps in order to evict the least recently referenced page.

\paragraph{Page Reference Statistics}

    Figure \ref{fig:timestamp-sorting} shows the page reference statistics of this implementation of the LRU page replacement strategy for a buffer pool with \num{16} buffer frames. The \emph{liveTimestamps} array contains for each buffer frame \numrange{0}{15} the \emph{timestamp of the most recent reference} to the contained page. The LRUqueue0 and LRUqueue1 arrays are unused until the first buffer frame is reclaimed. But then, either \emph{LRUqueue0} or \emph{LRUqueue1} (indicated by either \emph{useLRUqueue0} or \emph{useLRUqueue1} being true) contains the most up-to-date list of buffer frames (first column), \emph{sorted by the timestamp of references} to the contained pages. The timestamp in the second column shows the time of the last reference to the page in the corresponding buffer frame at the time the list (LRUqueue0 or LRUqueue1) was sorted---it is not updated after the creation of the list.

    The \emph{lastChecked} variable refers to the entry in the currently used sorted LRU queue that was \emph{last considered for eviction}. If the currently used queue is \emph{too outdated}, the other queue is prepared by sorting the buffer frames into it based on the current timestamps. During this process, \emph{sortingInProgress} is set and the \emph{waitForSortedMutex} is acquired by each working thread \emph{waiting for this update}.

    useLRUqueue0, useLRUqueue1, lastChecked and the liveTimestamps array provide \emph{atomic read and write} operations and sortingInProgress provides \emph{test-and-set} and \emph{clear} operations.

\begin{@empty}%
    \tikzset{%
        timestampfield/.style = {draw = black,
                                 rectangle,
                                 fill = black!10},
        sortfield/.style = {draw = black,
                            rectangle split,
                            rectangle split horizontal,
                            rectangle split parts = 2,
                            fill = black!10}
    }

    \begin{figure}
        \centering
        \resizebox{\linewidth}{!}{%
            \begin{tikzpicture}[>=latex,
                                semithick,
                                node distance = 1em]
                \node[timestampfield, label = left:0] (liveTimestamp0) {\textls[-50]{2020-09-14 12:34:56.197548}};
                \foreach \timestampnumber/\previoustimestampnumber/\timestamp in {1/0/2020-09-14 12:34:56 821122,
                                                                                  2/1/2020-09-14 12:34:57 062836,
                                                                                  3/2/2020-09-14 12:34:56 227794,
                                                                                  4/3/2020-09-14 12:34:57 289365,
                                                                                  5/4/2020-09-14 12:34:56 849729,
                                                                                  6/5/2020-09-14 12:34:56 377511,
                                                                                  7/6/2020-09-14 12:34:57 179364,
                                                                                  8/7/2020-09-14 12:34:56 498737,
                                                                                  9/8/2020-09-14 12:34:56 776239,
                                                                                  10/9/2020-09-14 12:34:56 720335,
                                                                                  11/10/2020-09-14 12:34:56 855806,
                                                                                  12/11/2020-09-14 12:34:56 213471,
                                                                                  13/12/2020-09-14 12:34:56 881209,
                                                                                  14/13/2020-09-14 12:34:56 346659,
                                                                                  15/14/2020-09-14 12:34:56 793698}
                    \node[timestampfield, below = -.8pt of liveTimestamp\previoustimestampnumber, label = left:\timestampnumber] (liveTimestamp\timestampnumber) {\textls[-50]{\timestamp}};
                \node[draw = none, above = 0em of liveTimestamp0] (liveTimestampName) {liveTimestamps};

                \node[sortfield, right = 1.5em of liveTimestamp0] (sort00) {\phantom{0}2\nodepart{two}\textls[-50]{2020-09-14 12:34:56 071309}};
                \foreach \timestampnumber/\frameindex/\timestamp in {1/\phantom{0}0/2020-09-14 12:34:56.197548,
                                                                     2/12/2020-09-14 12:34:56 213471,
                                                                     3/\phantom{0}3/2020-09-14 12:34:56 227794,
                                                                     4/14/2020-09-14 12:34:56 346659,
                                                                     5/\phantom{0}6/2020-09-14 12:34:56 377511,
                                                                     6/\phantom{0}8/2020-09-14 12:34:56 498737,
                                                                     7/10/2020-09-14 12:34:56 720335,
                                                                     8/\phantom{0}9/2020-09-14 12:34:56 776239,
                                                                     9/15/2020-09-14 12:34:56 793698,
                                                                     10/\phantom{0}1/2020-09-14 12:34:56 821122,
                                                                     11/\phantom{0}5/2020-09-14 12:34:56 849729,
                                                                     12/11/2020-09-14 12:34:56 855806,
                                                                     13/\phantom{0}4/2020-09-14 12:34:56 865145,
                                                                     14/13/2020-09-14 12:34:56 881209,
                                                                     15/\phantom{0}7/2020-09-14 12:34:56 987742}
                    \node[sortfield, right = 1.5em of liveTimestamp\timestampnumber] (sort0\timestampnumber) {\frameindex\nodepart{two}\textls[-50]{\timestamp}};
                \node[draw = none, above = 0em of sort00] (sort0Name) {LRUqueue0};
                \node[draw = none, below = .25em of sort015] {%
                    \begin{tikzpicture}
                        \node[draw = black, rectangle, fill = black!10] (useSort0) {true};
                        \node[draw = none, left = .3333em of useSort0.base west, anchor = base east] (useSort0Name) {useLRUqueue0};
                    \end{tikzpicture}
                };
                
                \node[sortfield, right = 1.5em of sort00] (sort10) {\phantom{1}8\nodepart{two}\textls[-50]{2020-09-14 12:34:55 185406}};
                \foreach \timestampnumber/\frameindex/\timestamp in {1/\phantom{0}9/2020-09-14 12:34:55.218616,
                                                                     2/\phantom{0}1/2020-09-14 12:34:55 222490,
                                                                     3/13/2020-09-14 12:34:55 439575,
                                                                     4/11/2020-09-14 12:34:55 582807,
                                                                     5/12/2020-09-14 12:34:55 607186,
                                                                     6/\phantom{0}5/2020-09-14 12:34:55 611986,
                                                                     7/\phantom{0}4/2020-09-14 12:34:55 688895,
                                                                     8/15/2020-09-14 12:34:55 726161,
                                                                     9/\phantom{0}7/2020-09-14 12:34:55 742479,
                                                                     10/10/2020-09-14 12:34:55 809492,
                                                                     11/\phantom{0}6/2020-09-14 12:34:55 953010,
                                                                     12/\phantom{0}3/2020-09-14 12:34:55 955357,
                                                                     13/14/2020-09-14 12:34:55 978132,
                                                                     14/\phantom{0}2/2020-09-14 12:34:56 071309,
                                                                     15/\phantom{0}0/2020-09-14 12:34:56.197548}
                    \node[sortfield, right = 1.5em of sort0\timestampnumber] (sort1\timestampnumber) {\frameindex\nodepart{two}\textls[-50]{\timestamp}};
                \node[draw = none, above = 0em of sort10] (sort1Name) {LRUqueue1};
                \node[draw = none, below = .25em of sort115] {%
                    \begin{tikzpicture}
                        \node[draw = black, rectangle, fill = black!10] (useSort1) {false};
                        \node[draw = none, left = .3333em of useSort1.base west, anchor = base east] (useSort1Name) {useLRUqueue1};
                    \end{tikzpicture}
                };

                \node[draw = none, below = .5em of liveTimestamp15] (lastChecked) {%
                    \begin{tikzpicture}
                        \node[draw = black, rectangle, fill = black!10] (lastChecked) {$\circ$\vphantom{f}};
                        \node[draw = none, left = .3333em of lastChecked.base west, anchor = base east] (lastCheckedName) {lastChecked};
                    \end{tikzpicture}
                };
%                \node[draw = none, below = .5em of liveTimestamp15] (lastChecked) {lastChecked};
                \draw [->, draw = black] ([xshift = -.875em, yshift = -.0625em]lastChecked.east) to ([xshift = 1em, yshift = -.0625em]lastChecked.east) to [in = 180, out = 0, in looseness = .375, out looseness = .375]  (sort00);

                \node[draw = none, below = 2.75em of $(liveTimestamp15)!0.5!(sort015)$] {%
                    \begin{tikzpicture}
                    \node[draw = black, rectangle, fill = black!10] (sortingInProgress) {false};
                    \node[draw = none, left = .3333em of sortingInProgress.base west, anchor = base east] (sortingInProgressName) {sortingInProgress};
                    \end{tikzpicture}
                };
                \node[draw = none, below = 2.75em of $(sort015)!0.5!(sort115)$] {%
                    \begin{tikzpicture}
                        \node[draw = black, rectangle, fill = black!10] (waitForSortedMutexName) {waitForSortedMutex};
                    \end{tikzpicture}
                };
            \end{tikzpicture}
        }
        \vspace{-.75em}
        \caption[Page reference statistics of Timestamp-Sorting LRU]{The page reference statistics of the Timestamp-Sorting implementation of the LRU page replacement strategy one eviction after sorting LRUqueue0}
        \label{fig:timestamp-sorting}
    \end{figure}
\end{@empty}

\paragraph{Page Hits}

    The Timestamp-Sorting implementation of the LRU page replacement algorithm prevents the synchronization overhead for page hits by atomically writing the current \emph{wall clock} time to the element in the liveTimestamps array associated with the referenced buffer frame during a page hit. To obtain correctly ordered reference timestamps, a monotonic clock should be used if available. To further reduce the cost of page eviction, the timestamps are also updated when a page \emph{cannot be evicted temporarily}. Since this indicates that a page is a somewhat hot, it should not be considered for eviction again so quickly. As a small optimization, pages that \emph{cannot be evicted at all} are given a timestamp that is as far in the future as possible (which is always considered the most recent), but a regular page reference to these pages overwrites this timestamp again.

\paragraph{Page Eviction}

    The page in the buffer pool with the \emph{oldest reference timestamp} is selected for eviction whenever a buffer frame needs to be freed. But to avoid an exhaustive search for the oldest reference timestamp in the liveTimestamps array, which would be required each time a buffer frame is needed to be reclaimed, an array of buffer frame indexes \emph{sorted by reference timestamp} is created, in which in the best case the oldest reference timestamp can be found in $\mathcal{O}\left(1\right)$. This array does not receive live updates, but is created each time the old version became too outdated. To allow the creation of a new sorted array in the background, two arrays are used alternately, and therefore either LRUqueue0 or LRUqueue1 contains the most up-to-date list of sorted buffer frames. And to ensure that the entry for the buffer frame with the oldest reference timestamp in this list is not outdated, the reference timestamp of the one used to create this list is compared with the live version. A reference to this page made in the meantime (since the last sorting) can be recognized in that way, and due to the fact that this reference was made later than any other page reference used to create the currently used sorted list, this page can be skipped without problems.

    Sorting the reference timestamp becomes a \emph{scalability bottleneck} due to its computational complexity of $\mathcal{O}\left(n \cdot \log\left(n\right)\right)$, but asynchronous execution helps with this problem to some degree.

\begin{@empty}
    \newcommand{\plusplus}{\mathord{\mathord{+}\hspace*{-1pt}\mathord{+}}}

    \begin{algorithm}[h!]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{select}{}
                \While{$\text{true}$}
                    \If{$\text{useLRUqueue0} = \text{true}$}
                        \If{\scalebox{.95}[1.0]{$\text{lastChecked} > 0.75 \cdot \text{maxBufferFrameIndex} \wedge \neg\text{sortingInProgress}.$\Call{$\text{test\_and\_set}$}{}}}
                            \State $\text{waitForSortedMutex}.$\Call{$\text{acquire}$}{}
                            \State \Call{$\text{sortInto}$}{$\text{LRUqueue1}$}
                            \State $\text{useLRUqueue1} \gets \text{true}$
                            \State $\text{lastChecked} \gets -1$
                            \State $\text{waitForSortedMutex}.$\Call{$\text{release}$}{}
                            \State $\text{useLRUqueue0} \gets \text{false}$
                            \State $\text{sortingInProgress}.$\Call{$\text{clear}$}{}
%                            \State $\textbf{continue}$
                        \Else
                            \State $\text{checkThis} \gets \plusplus\text{lastChecked}$
                            \If{$\text{checkThis} > \text{maxBufferFrameIndex}$}
                                \State $\text{waitForSortedMutex}.$\Call{$\text{acquire}$}{}
                                \State $\text{waitForSortedMutex}.$\Call{$\text{release}$}{}
%                                \State $\textbf{continue}$
                            \Else
                                \If{\scalebox{.76}[1.0]{$\text{LRUqueue0}\left[\text{checkThis}\right].\text{timestamp} = \text{liveTimestamps}\left[\text{LRUqueue0}\left[\text{checkThis}\right].\text{bufferIndex}\right]$}}
                                    \State \Return $\text{LRUqueue0}\left[\text{checkThis}\right].\text{bufferIndex}$
                                \Else
                                    \State $\textbf{continue}$
                                \EndIf
                            \EndIf
                        \EndIf
                    \ElsIf{$\text{useLRUqueue1} = \text{true}$}
                        \State $...$ \Comment{As before but with LRUqueue1 instead of LRUqueue0}
%                        \If{\scalebox{.95}[1.0]{$\text{lastChecked} > 0.75 \cdot \text{maxBufferFrameIndex} \wedge \neg\text{sortingInProgress}.$\Call{$\text{test\_and\_set}$}{}}}
%                            \State $\text{waitForSortedMutex}.$\Call{$\text{acquire}$}{}
%                            \State \Call{$\text{sortInto}$}{$\text{LRUqueue0}$}
%                            \State $\text{useLRUqueue0} \gets \text{true}$
%                            \State $\text{lastChecked} \gets -1$
%                            \State $\text{waitForSortedMutex}.$\Call{$\text{release}$}{}
%                            \State $\text{useLRUqueue1} \gets \text{false}$
%                            \State $\text{sortingInProgress}.$\Call{$\text{clear}$}{}
%%                            \State $\textbf{continue}$
%                        \Else
%                            \State $\text{checkThis} \gets \plusplus\text{lastChecked}$
%                            \If{$\text{checkThis} > \text{maxBufferFrameIndex}$}
%                                \State $\text{waitForSortedMutex}.$\Call{$\text{acquire}$}{}
%                                \State $\text{waitForSortedMutex}.$\Call{$\text{release}$}{}
%%                                \State $\textbf{continue}$
%                            \Else
%                                \If{\scalebox{.76}[1.0]{$\text{LRUqueue1}\left[\text{checkThis}\right].\text{timestamp} = \text{liveTimestamps}\left[\text{LRUqueue1}\left[\text{checkThis}\right].\text{bufferIndex}\right]$}}
%                                    \State \Return $\text{LRUqueue1}\left[\text{checkThis}\right].\text{bufferIndex}$
%                                \Else
%                                    \State $\textbf{continue}$
%                                \EndIf
%                            \EndIf
%                        \EndIf
                    \ElsIf{$\neg\text{sortingInProgress}.$\Call{$\text{test\_and\_set}$}{}}
                        \State \Comment{Initially neither useLRUqueue0 nor useLRUqueue1 is true.}
                        \State $\text{waitForSortedMutex}.$\Call{$\text{acquire}$}{}
                        \State \Call{$\text{sortInto}$}{$\text{LRUqueue0}$}
                        \State $\text{useLRUqueue0} \gets \text{true}$
                        \State $\text{lastChecked} \gets -1$
                        \State $\text{waitForSortedMutex}.$\Call{$\text{release}$}{}
                        \State $\text{useLRUqueue1} \gets \text{false}$
                        \State $\text{sortingInProgress}.$\Call{$\text{clear}$}{}
%                        \State $\textbf{continue}$
                    \Else
                        \State $\text{waitForSortedMutex}.$\Call{$\text{acquire}$}{}
                        \State $\text{waitForSortedMutex}.$\Call{$\text{release}$}{}
%                        \State $\textbf{continue}$
                    \EndIf
                \EndWhile
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} select} of Timestamp-Sorting LRU]{Selection of eviction candidates by the Timestamp-Sorting implementation of the LRU page replacement strategy}
        \label{alg:timestampsortingselect}
    \end{algorithm}
\end{@empty}

    As an example for this algorithm, figure \ref{fig:timestamp-sorting} shows LRUqueue0 as the most up-to-date list of buffer frames sorted by reference timestamp (useLRUqueue0 is true), and therefore it is iterated through this array when pages are evicted. The last buffer frame (potentially) reclaimed here was buffer frame 2 (lastChecked points to 0 and useLRUqueue0 is true), and therefore its timestamp was updated in liveTimestamps after LRUqueue0 had been sorted---the newly fetched page was referenced or it was found temporarily unreclaimable. The next reclaimed buffer frame will be buffer frame 0. It is already known that buffer frames 4 and 7 will be skipped because the contained pages were referenced after LRUqueue0 had been sorted---their timestamps in LRUqueue0 are not up-to-date.

    If a buffer frame is to be reclaimed by a working thread and lastChecked is 12 (\SI{75}{\percent} of buffer frames have been checked out), that thread sets sortingInProgress, acquires the waitForSortedMutex, and sorts the buffer frames in LRUqueue1 based on the timestamps in liveTimestamps as shown in Algorithm \ref{alg:timestampsortingselect}. Other working threads reclaiming buffer frames still use LRUqueue0 until the working thread currently sorting sets useLRUqueue1 to true. They know that they do not need to perform the sorting because they find sortingInProgress set. If all buffer frames are checked out by the other working threads before LRUqueue1 is completely sorted, threads that need to reclaim buffer frames wait using waitForSortedMutex.

\subsection[MRU]{Most Recently Used (MRU)} \label{subsec:mru}

    MRU is for \nameref{subsec:lru}, what \nameref{subsec:filo} is for \nameref{subsec:fifo}. With the MRU page replacement strategy, the \emph{most recently referenced} is always evicted. In an OLTP system, this leads to the frequent eviction of hot pages, as these are very often the most recently referenced pages. But due to the arbitrariness of the transaction mix concurrently running on OLTP systems, this eviction strategy will result in rather random eviction decisions.

    Like the \nameref{subsec:filo} page replacement strategy, this one has the problem that pages, which are referenced early on after the system cold start, tend to stay in the buffer pool for a very long time, and that they are never evicted if they are never referenced again after the first page eviction (of any page) from the buffer pool. There is no use case in an OLTP system where this page replacement strategy is better suited than every other.

\subsubsection{Quasi-MRU} \label{subsubsec:quasi-mru}

\paragraph{Introduction}

    The Quasi-MRU implementation of this page replacement strategy is based on the \nameref{subsubsec:quasi-fifo} implementation of the \nameref{subsec:fifo} page replacement strategy but with more sophisticated updates to the page reference statistics.

\paragraph{Page Reference Statistics}

    The Quasi-MRU page replacement algorithm uses---like \nameref{subsec:filo}---a stack (MRU stack) and a queue (retry queue) for its page reference statistics. But both data structures are implemented using a doubly-linked list in a hash map (shown in figure \ref{fig:hashmapdoublylinkedlist}) like the one used for the \nameref{subsubsec:lru_traditional} implementation of the \nameref{subsec:lru} page replacement strategy. In addition to the operations for enqueuing (alias ``push to back'') (Algorithm \ref{alg:hashmapdoublylinkedlistenqueue}), dequeuing (alias ``pop from front'') (Algorithm \ref{alg:hashmapdoublylinkedlistdequeue}) and removing (Algorithm \ref{alg:hashmapdoublylinkedlistremove}) a specific buffer pool index, an operation ``push to front'' (Algorithm \ref{alg:hashmapdoublylinkedlistpushtofront}) needs to be provided by the doubly-linked list in a hash map.

\begin{@empty}
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{pushToFront}{$\text{key}$}
                \If{$\left|\text{hashMap}\right| \neq 0$}
                    \If{$\text{hashMap}\left[\text{key}\right] \neq \text{NULL}$}
                        \State \Return $\text{ERROR!}$
                    \EndIf
                    \State $\text{hashMap}\left[\text{key}\right] \gets \left(\text{NULL}, \text{head}\right)$
                    \State $\text{hashMap}\left[\text{head}\right].\text{previous} \gets \text{key}$
                    \State $\text{head} \gets \text{key}$
                \Else
                    \State $\text{hashMap}\left[\text{key}\right] \gets \left(\text{NULL}, \text{NULL}\right)$
                    \State $\text{tail} \gets \text{key}$
                    \State $\text{head} \gets \text{key}$
                \EndIf
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{pushToFront}} of Hash-Map-Doubly-Linked-List]{Push an index to the front of Hash-Map-Doubly-Linked-List}
        \label{alg:hashmapdoublylinkedlistpushtofront}
    \end{algorithm}
\end{@empty}


    Per working thread, the variables currentListChecks and currentlyCheckingRetryQueue are used to balance the page evictions between the MRU stack and the retry queue, as done in the \nameref{subsubsec:quasi-fifo} page replacement algorithm.

\paragraph{Updates of the Page Reference Statistics}

    The page reference statistics are not updated on \emph{page hit} because moving a buffer frame to the front of the MRU stack would make that buffer frame the last referenced one and therefore the contained page would probably be selected for eviction while it is still fixed. The update is done when the page gets \emph{unfixed}.

    A buffer frame that is \emph{temporarily or permanently unreclaimable} is moved to the end of the retry queue, and an \emph{explicitly reclaimed} buffer frame is removed either from the MRU stack or from the retry queue---wherever it was before. \emph{Empty buffer frames} are always neither in the MRU stack nor in the retry queue.

\paragraph{Page Eviction}

    The selection of buffer frames for page eviction works similar to that of the \nameref{subsubsec:quasi-fifo} page replacement algorithm presented in Algorithm \ref{alg:FIFOselect}. However, instead of dequeuing buffer frame indexes from the head of an LRU queue, they are popped from the top (tail) of the MRU stack. A notExplicitlyEvictedList does not need to be checked because empty buffer frames are simply not in the MRU stack or in the retry queue. But unlike the simpler lock-free ring buffer used in the \nameref{subsubsec:quasi-fifo} page replacement algorithm, the double-linked-lists in hash maps used here require a global latch to be acquired for synchronization.

\subsection{LRU-K} \label{subsec:lru-k}

    The LRU-K page replacement strategy is an optimization (and generalization) of the \nameref{subsec:lru} page replacement strategy proposed by O'Neil, O'Neil and Weikum in \cite{ONeil:1993}. By taking into account the \emph{$K$ most recent references} to each page in the buffer pool, the authors achieve a page replacement policy that can better discriminate between pages that are referenced \emph{frequently} and those that are referenced \emph{only (once or) a few times}. The fact that the $K^{\text{th}}$ most recent reference of a page referenced $\mathord{<} K$ times is considered to be \emph{infinitely far in the past} leads to scan resistance thus overcoming one of the major weaknesses of \nameref{subsec:lru}. \emph{LRU-1} is equivalent to \nameref{subsec:lru}.

    The LRU-K page replacement algorithm evicts the page from the buffer pool where the $K^{\text{th}}$ most recent reference is farthest in the past. Therefore, no page with $\mathord{\geq} K$ references will be evicted if pages with $\mathord{<} K$ references are in the buffer pool. \emph{A different eviction policy} is required for the pages with $\mathord{<} K$ references because the $K^{\text{th}}$ most recent reference of all these pages is considered to be infinitely far in the past, but a certain order must be determined to evict these pages. One option would be to use \nameref{subsec:lru} for these pages, taking into account only the most recent page reference to these pages. Another possibility---which was used for this evaluation---is to use \nameref{subsec:fifo} to differentiate between pages with $\mathord{<} K$ references. But for $K > 2$ the consideration of the reference frequency of the pages would be a possible solution as well.
    
\begin{@empty}%    
    \begin{figure}[h]
        \begin{itemize}
            \item[$\rightarrow$] For $p_i$, i.e. the page that is currently in the buffer frame $i$, the page reference string $p_4p_3p_2p_3p_2p_4p_2p_0p_4p_0p_3p_1$ (pages replaced in the meantime ignored) leads to the following page reference statistics:
        \end{itemize}
        \vspace{-.125em}
        \resizebox{\linewidth}{!}{%
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
                \multicolumn{7}{l}{\tiny least recent page references} & \multicolumn{1}{c}{} & \multicolumn{7}{r}{\tiny most recent page references}                        \\ \hline
                0 & 1 & 1 & 4 & 3 & 2 & 3 & 2 & 4 & 2 & 0 & 4 & 0 & 3 & 1                    \\ \hline
                \multicolumn{3}{r|}{\scriptsize \scalebox{.95}[1.0]{$\infty$ in the past}} & \multicolumn{12}{l}{}
            \end{tabular}
        }
        \vspace{.25em}
        \begin{itemize}
            \item[$\rightarrow$] After the replacement of $p_0$ with $p_{0'}$:
        \end{itemize}
        \vspace{-.125em}
        \resizebox{\linewidth}{!}{%
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
                \multicolumn{7}{l}{\tiny least recent page references} & \multicolumn{1}{c}{} & \multicolumn{7}{r}{\tiny most recent page references}                        \\ \hline
                1 & 1 & 0 & 0 & 4 & 3 & 2 & 3 & 2 & 4 & 2 & 4 & 3 & 1 & 0                    \\ \hline
                \multicolumn{4}{r|}{\scriptsize $\infty$ in the past} & \multicolumn{11}{l}{}
            \end{tabular}
        }
        \vspace{.25em}
        \begin{itemize}
            \item[$\rightarrow$] After a reference to $p_1$:
        \end{itemize}
        \vspace{-.125em}
        \resizebox{\linewidth}{!}{%
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
                \multicolumn{7}{l}{\tiny least recent page references} & \multicolumn{1}{c}{} & \multicolumn{7}{r}{\tiny most recent page references}                        \\ \hline
                1 & 0 & 0 & 4 & 3 & 2 & 3 & 2 & 4 & 2 & 4 & 3 & 1 & 0 & 1                    \\ \hline
                \multicolumn{3}{r|}{\scriptsize \scalebox{.95}[1.0]{$\infty$ in the past}} & \multicolumn{12}{l}{}
            \end{tabular}
        }
        \vspace{.25em}
        \caption[Page reference statistics of LRU-K]{Page reference statistics of LRU-3 for 5 buffer frames}
        \label{fig:lru-k}
    \end{figure}
\end{@empty}

    $\left(K - 1\right)$ \emph{pseudo-references}---which are considered to be infinitely far in the past---are added to the page reference statistics when a page is fetched into the buffer pool. These are considered to be later than any other pseudo-references currently contained---and are therefore inserted after them. This leads to the eviction of the \emph{oldest page with $\mathord{<} K$ page references} (\nameref{subsec:fifo}) when the most recent page reference from the page reference statistics is selected for eviction.

    Figure \ref{fig:lru-k} shows the abstract page reference statistics for a given page reference string collected by the LRU-3 page replacement policy with pseudo-references inserted as described above. The page in buffer frame 0 was referenced twice (1 pseudo-reference) and the page in buffer frame 1 was referenced just once (2 pseudo-references). The page $p_0$ was \emph{replaced} by the page $p_{0'}$, because it was \emph{fetched into the buffer pool before} page $p_1$ (\nameref{subsec:fifo}). The references to $p_0$ have been removed and $2$ ($K - 1$) pseudo-references have been inserted after the most recent pseudo-reference in the page reference statistics (that of $p_1$). The least recent reference to the $p_1$ page (including pseudo-references) is removed when a new reference to this page is recorded.

\subsubsection[Hash-Map-Doubly-Linked-List]{Hash-Map-Doubly-Linked-List Implementation} \label{subsubsec:lru-k_traditional}

\paragraph{Introduction}

    The Hash-Map-Doubly-Linked-List implementation of the \nameref{subsec:lru-k} page replacement policy is based on the same principle as the \nameref{subsubsec:lru_traditional} Implementation of \nameref{subsec:lru}. But for each buffer frame it manages the $K$ most recent references in the used LRU queue.

\paragraph{Page Reference Statistics}

    To \emph{identify the $K$ references recorded per buffer frame} in the LRU queue, a unique ID must be defined for these references. The $K$ most recent references to the page in buffer frame $i$ receive IDs in the range $i \cdot K$ to $i \cdot K + (K - 1)$.

    When a page $p_i$ (in buffer frame $i$) is re-referenced, the $K^{\text{th}}$ least recent reference to $p_i$ is removed from the LRU queue and enqueued in the LRU queue as the most recent reference. However, for these operations the ID $ID_{i_k}$ of the $K^{\text{th}}$ least recent reference to $p_i$ is required. It can be found by traversing the LRU queue from the head (least recent references) to the tail until a reference ID $ID_j$ with $ID_j / K = i$ is found. Due to the fact that this traversal is done in $\mathcal{O}\left(n\right)$ (for very frequently referenced pages, almost $K \cdot n$ elements in the LRU queue must be visited), maintaining the ID of the $K^{\text{th}}$ least recent reference to $p_i$ (in $\text{frameReference}\left[i\right]$) is a \emph{significant optimization} of the function used to update page reference statistics on page hit.

    To allow the insertion of $\left(K - 1\right)$ pseudo-references---between the most recent pseudo-reference and the least recent real reference in the LRU queue---when a page is fetched into the buffer pool, the ID of the least recent real reference is maintained in the variable $\text{leastRecentlyUsedFinite}$.

    The page reference statistics are protected against data races caused by concurrent page references by the $\text{LRUqueueLatch}$.

\paragraph{Page Hit}

    Whenever a page hit (or alternatively a page unfix) occurs, the least recent reference to that page is removed from the LRU queue ($\text{LRUqueue}$) and enqueued as the most recent reference in the LRU queue. Algorithm \ref{alg:hashmapdoublylinkedlistlrukhit} shows the corresponding function. The used functions of the Hash-Map-Doubly-Linked-List are described in Algorithms \ref{alg:hashmapdoublylinkedlistgetafter}, \ref{alg:hashmapdoublylinkedlistremove} and \ref{alg:hashmapdoublylinkedlistenqueue}.

\begin{@empty}
    \newcommand{\plusplus}{\mathord{\mathord{+}\hspace*{-1pt}\mathord{+}}}

    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{onHit}{$\text{bufferIndex}$}
                \State $\text{LRUqueueLatch}.$\Call{$\text{acquire}$}{}
                \State $\text{referenceID} \gets \left(\text{frameReference}\left[\text{bufferIndex}\right] \mod K\right) + \left(K \cdot \text{bufferIndex}\right)$
                \If{$\text{referenceID} = \text{leastRecentlyUsedFinite}$}
                    \If{$\text{LRUqueue}$.\Call{$\text{getAfter}$}{$\text{leastRecentlyUsedFinite}$} $ = \text{NULL}$}
                        \State $\text{leastRecentlyUsedFinite} \gets \text{NULL}$
                    \Else
                        \State $\text{leastRecentlyUsedFinite} \gets \text{LRUqueue}$.\Call{$\text{getAfter}$}{$\text{leastRecentlyUsedFinite}$}
                    \EndIf
                \EndIf
                \State $\text{LRUqueue}$.\Call{$\text{remove}$}{$\text{referenceID}$}
                \If{$\text{leastRecentlyUsedFinite} = \text{NULL}$}
                    \State $\text{leastRecentlyUsedFinite} \gets \text{referenceID}$
                \EndIf
                \State $\text{LRUqueue}$.\Call{$\text{enqueue}$}{$\text{referenceID}$}
                \State $\text{frameReference}\left[\text{bufferIndex}\right]\plusplus$
                \State $\text{LRUqueueLatch}.$\Call{$\text{release}$}{}
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{onHit}} of Hash-Map-Doubly-Linked-List LRU-K]{Update the page reference statistics on a page hit when the Hash-Map-Doubly-Linked-List implementation of the LRU-K page replacement policy is used}
        \label{alg:hashmapdoublylinkedlistlrukhit}
    \end{algorithm}
\end{@empty}

\begin{@empty}
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{getAfter}{$\text{key}$}
                \If{$\text{hashMap}\left[\text{key}\right] = \text{NULL}$}
                    \State \Return $\text{ERROR!}$
                \ElsIf{\text{tail} = \text{key}}
                    \State \Return $\text{NULL}$
                \Else
                    \State \Return $\text{hashMap}\left[\text{key}\right].\text{next}$
                \EndIf
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{getAfter}} of Hash-Map-Doubly-Linked-List]{Get the index after a given index in a Hash-Map-Doubly-Linked-List}
        \label{alg:hashmapdoublylinkedlistgetafter}
    \end{algorithm}
\end{@empty}


\paragraph{Page Eviction}

    An eviction candidate is selected by dequeuing the least recent reference (divided by $K$) from the head of the LRU queue. Algorithm \ref{alg:hashmapdoublylinkedlistlrukselect} shows the corresponding function. The used functions of the Hash-Map-Doubly-Linked-List are described in Algorithms \ref{alg:hashmapdoublylinkedlistgetfront}, \ref{alg:hashmapdoublylinkedlistgetafter} and \ref{alg:hashmapdoublylinkedlistremove}.

\begin{@empty}
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{select}{}
                \State $\text{LRUqueueLatch}.$\Call{$\text{acquire}$}{}
                \State $\text{front} \gets \text{LRUqueueLatch}.$\Call{$\text{getFront}$}{}
                \If{$\text{referenceID} = \text{leastRecentlyUsedFinite}$}
                    \If{$\text{LRUqueue}$.\Call{$\text{getAfter}$}{$\text{leastRecentlyUsedFinite}$} $ = \text{NULL}$}
                        \State $\text{leastRecentlyUsedFinite} \gets \text{NULL}$
                    \Else
                        \State $\text{leastRecentlyUsedFinite} \gets \text{LRUqueue}$.\Call{$\text{getAfter}$}{$\text{leastRecentlyUsedFinite}$}
                    \EndIf
                \EndIf
                \State $\text{LRUqueue}$.\Call{$\text{remove}$}{$\text{referenceID}$}
                \State \Return $\text{front} / K$
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{select}} of Hash-Map-Doubly-Linked-List LRU-K]{Selection of eviction candidates by the Hash-Map-Doubly-Linked-List implementation of the LRU-K page replacement strategy}
        \label{alg:hashmapdoublylinkedlistlrukselect}
    \end{algorithm}
\end{@empty}

\begin{@empty}
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{getFront}{}
                \If{$\left|\text{hashMap}\right| = 0$}
                    \State \Return $\text{ERROR!}$
                \Else
                    \State \Return $\text{head}$
                \EndIf
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{getFront}} of Hash-Map-Doubly-Linked-List]{Get head index of an Hash-Map-Doubly-Linked-List}
        \label{alg:hashmapdoublylinkedlistgetfront}
    \end{algorithm}
\end{@empty}

    If the selected eviction candidate cannot be evicted, the reference ID dequeued from the LRU queue is enqueued (algorithm \ref{alg:hashmapdoublylinkedlistenqueue}) again. Algorithm \ref{alg:hashmapdoublylinkedlistlruknotEvictabl} describes the corresponding function.

\begin{@empty}
    \newcommand{\plusplus}{\mathord{\mathord{+}\hspace*{-1pt}\mathord{+}}}
    
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{notEvictabl}{}
                \State $\text{referenceID} \gets \left(\text{frameReference}\left[\text{bufferIndex}\right] \mod K\right) + \left(K \cdot \text{bufferIndex}\right)$
                \If{$\text{leastRecentlyUsedFinite} = \text{NULL}$}
                    \State $\text{leastRecentlyUsedFinite} \gets \text{referenceID}$
                \EndIf
                \State $\text{LRUqueue}$.\Call{$\text{enqueue}$}{$\text{referenceID}$}
                \State $\text{frameReference}\left[\text{bufferIndex}\right]\plusplus$
                \State $\text{LRUqueueLatch}.$\Call{$\text{release}$}{}
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{notEvictabl}} of Hash-Map-Doubly-Linked-List LRU-K]{Update the page reference statistics for an eviction candidate that cannot be evicted when the Hash-Map-Doubly-Linked-List implementation of the LRU-K page replacement policy is used}
        \label{alg:hashmapdoublylinkedlistlruknotEvictabl}
    \end{algorithm}
\end{@empty}

    But if a new page can be fetched into the reclaimed buffer frame, {\footnotesize \textbf{function} \textsc{insert}} described in Algorithm {alg:hashmapdoublylinkedlistlrukinsert} is called. It begins with resetting the $\text{frameReference}$ variable, then it removes all the references associated with the buffer frame. It then inserts the $\left(K - 1\right)$ pseudo-references into the LRU queue, and finally enqueues a reference for the initial reference to the buffer frame. The same function is also used when a buffer frame is used for the first time, so the $\text{LRUqueueLatch}$ must be acquired first and released twice after the function---once for acquisition in this function and once for potential acquisition in the previously called {\footnotesize \textbf{function} \textsc{select}}. The Hash-Map-Doubly-Linked-List functions used are described in the algorithms \ref{alg:hashmapdoublylinkedlistgetafter}, \ref{alg:hashmapdoublylinkedlistremove}, \ref{alg:hashmapdoublylinkedlistinsertbefore} and \ref{alg:hashmapdoublylinkedlistenqueue}.

\begin{@empty}
    \newcommand{\plusplus}{\mathord{\mathord{+}\hspace*{-1pt}\mathord{+}}}
    
    \begin{algorithm}[h!]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{insert}{$\text{bufferIndex}$}
                \State $\text{LRUqueueLatch}.$\Call{$\text{acquire}$}{}
                \State $\text{frameReference}\left[\text{bufferIndex}\right] \gets 0$
                \For{$i \gets 0$ to $K - 1$}
                    \State $\text{referenceID} \gets \left(i \mod K\right) + \left(K \cdot \text{bufferIndex}\right)$
                    \If{$\text{referenceID} = \text{leastRecentlyUsedFinite}$}
                        \If{$\text{LRUqueue}$.\Call{$\text{getAfter}$}{$\text{leastRecentlyUsedFinite}$} $ = \text{NULL}$}
                            \State $\text{leastRecentlyUsedFinite} \gets \text{NULL}$
                        \Else
                            \State $\text{leastRecentlyUsedFinite} \gets \text{LRUqueue}$.\Call{$\text{getAfter}$}{$\text{leastRecentlyUsedFinite}$}
                        \EndIf
                    \EndIf
                    \State $\text{LRUqueue}$.\Call{$\text{remove}$}{$\text{referenceID}$}
                \EndFor
                \State $\text{referenceID} \gets \left(\text{frameReference}\left[\text{bufferIndex}\right] \mod K\right) + \left(K \cdot \text{bufferIndex}\right)$
                \If{$\text{leastRecentlyUsedFinite} = \text{NULL}$}
                    \State $\text{leastRecentlyUsedFinite} \gets \text{referenceID}$
                \EndIf
                \If{$K \geq 2$}
                    \State $\text{referenceID} \gets \left(\text{frameReference}\left[\text{bufferIndex}\right] \mod K\right) + \left(K \cdot \text{bufferIndex}\right)$
                    \State $\text{LRUqueue}$.\Call{$\text{insertBefore}$}{$\text{referenceID}, \text{leastRecentlyUsedFinite}$}
                \EndIf
                \For{$i \gets 2$ to $K - 1$}
                     \State $\text{beforeID} \gets \left(\text{frameReference}\left[\text{bufferIndex}\right] \mod K\right) + \left(K \cdot \text{bufferIndex}\right)$
                     \State $\text{frameReference}\left[\text{bufferIndex}\right]\plusplus$
                     \State $\text{referenceID} \gets \left(\text{frameReference}\left[\text{bufferIndex}\right] \mod K\right) + \left(K \cdot \text{bufferIndex}\right)$
                     \State $\text{LRUqueue}$.\Call{$\text{insertBefore}$}{$\text{referenceID}, \text{beforeID}$}
                \EndFor
                \If{$K \geq 2$}
                    \State $\text{frameReference}\left[\text{bufferIndex}\right]\plusplus$
                \EndIf
                \State $\text{LRUqueue}$.\Call{$\text{enqueue}$}{$\text{referenceID}$}
                \State $\text{frameReference}\left[\text{bufferIndex}\right]\plusplus$
                \State $\text{LRUqueueLatch}.$\Call{$\text{release}$}{}
                \State $\text{LRUqueueLatch}.$\Call{$\text{release}$}{}
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{insert}} of Hash-Map-Doubly-Linked-List LRU-K]{Update the page reference statistics for a fetched page when the Hash-Map-Doubly-Linked-List implementation of the LRU-K page replacement policy is used \vspace{-1em}}
        \label{alg:hashmapdoublylinkedlistlrukinsert}
    \end{algorithm}
\end{@empty}

\begin{@empty}
    \begin{algorithm}[h!]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{insertBefore}{$\text{key}, \text{ref}$}
                \If{$\text{hashMap}\left[\text{ref}\right] = \text{NULL}$}
                    \State \Return $\text{ERROR!}$
                \ElsIf{$\text{hashMap}\left[\text{key}\right] = \text{NULL}$}
                    \If{\text{head} = \text{ref}}
                        \State $\text{hashMap}\left[\text{key}\right] \gets \left(\text{NULL}, \text{ref}\right)$
                        \State $head \gets \text{key}$
                        \State $\text{hashMap}\left[\text{ref}\right].\text{previous} \gets \text{key}$
                    \Else
                        \State $\text{hashMap}\left[\text{key}\right] \gets \left(\text{hashMap}\left[\text{ref}\right].\text{previous}, \text{ref}\right)$
                        \State $\text{hashMap}\left[\text{hashMap}\left[\text{ref}\right].\text{previous}\right].\text{next} \gets \text{key}$
                        \State $\text{hashMap}\left[\text{ref}\right].\text{previous} \gets \text{key}$
                    \EndIf
                \EndIf
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{insertBefore}} of Hash-Map-Doubly-Linked-List]{Insert an index before another index in an Hash-Map-Doubly-Linked-List}
        \label{alg:hashmapdoublylinkedlistinsertbefore}
    \end{algorithm}
\end{@empty}

\subsubsection[Timestamp-Sorting]{Timestamp-Sorting Implementation} \label{subsubsec:lru-k_timestamp}

\paragraph{Introduction}

    The Timestamp-Sorting implementation of the \nameref{subsec:lru-k} page replacement policy is based on the same principle as the \nameref{subsubsec:lru_timestamp} Implementation of \nameref{subsec:lru}. Therefore, the synchronization overhead for page hits is eliminated, resulting in better scalability. But for each buffer frame it manages the timestamps of the $K$ most recent references.

\paragraph{Page Reference Statistics}

    The page reference statistics of the Time\-stamp-Sort\-ing implementation of \nameref{subsec:lru-k} is very similar to that of \nameref{subsec:lru}. But in this case, $\text{liveTimestamps}$ is not a \emph{two-dimensional} array with $K$ \emph{columns} (timestamps) per buffer frame. The array $\text{liveTimestampsOldestTimestamp}$ contains for each buffer frame the array index of the least recent of the $K$ timestamps in the array $\text{liveTimestamps}$. This value is used whenever the reference statistic of that particular buffer frame is updated or when the least recent timestamps of each buffer frame are sorted into $\text{LRUqueue0}$ or $\text{LRUqueue1}$. The pseudo-references use a timestamp as far in the past as possible, but to allow FIFO page eviction to be used for pages with $\mathord{<} K$ page references, the timestamps used for pseudo-references are incremented using the $\text{infinitePast}$ counter.

\paragraph{Updates of the Page Reference Statistics}

    On a \emph{page hit} (or alternatively a page unfix), the least recent timestamp of that page (according to $\text{liveTimestampsOldestTimestamp}$) is overwritten with the current time and the value in $\text{liveTimestampsOldestTimestamp}$ is atomically incremented. This also happens when a page \emph{temporarily cannot be evicted}.

    $K$ timestamps that are as far in the future as possible are used for pages that cannot be evicted at all. However, if such a page is referenced, the  ``least recent'' timestamp will be overwritten with the current time.

    As already described, the timestamps used for the pseudo-references are taken from the $\text{infinitePast}$ counter. This means, when a page is fetched into the buffer pool, $\left(K - 1\right)$ timestamps are set to $\text{infinitePast}$ which is incremented after each read and one timestamp is set to the current time.
    
\paragraph{Page Eviction}

    The selection of eviction candidates works almost exactly the way as in the \nameref{subsubsec:lru_timestamp} implementation of the \nameref{subsec:lru} page replacement policy. This was described in algorithm \ref{alg:timestampsortingselect}. But both the sorting and the checking whether a page has been referenced in the meantime take into account the $\text{liveTimestampsOldestTimestamp}$ array here.

\subsection[SLRU]{Segmented LRU (SLRU)} \label{subsec:slru}

\paragraph{Introduction}

    \emph{SLRU}, like \nameref{subsec:lru-k}, is an optimization of the \nameref{subsec:lru} page replacement policy that combines the use of reference recency with reference frequency for eviction decisions. It was proposed by Karedla, Love and Wherry in \cite{Karedla:1994}.

\begin{@empty}%
    \begin{figure}[h]
        \centering
        \resizebox{\textwidth}{!}{%
            \begin{tikzpicture}[>=latex,
                                semithick,
                                node distance = 1em]
                \node[draw = black, rectangle split, rectangle split horizontal, rectangle split parts = 8, minimum height = 3em, fill = black!10] (probationary segment) {};
                \node[draw = none, fill = black!10, inner sep = 0em, rotate = 20] at (probationary segment) {\scriptsize Probationary segment};
                \node[draw = none, above = .3333em of probationary segment.north west, anchor = west, xshift = -.3333em] {\tiny least recently referenced};
                \node[draw = none, below = .3333em of probationary segment.south east, anchor = east, xshift = .3333em] {\tiny most recently referenced};
                \node[draw = black, fill = black!10, rectangle split, rectangle split horizontal, rectangle split parts = 6, minimum height = 3em, right = 3em of probationary segment] (protected segment) {};
                \node[draw = none, fill = black!10, inner sep = 0em, rotate = 20] at (protected segment) {\scriptsize Protected segment};
                \node[draw = none, above = .3333em of protected segment.north west, anchor = west, xshift = -.3333em] {\tiny least recently referenced};
                \node[draw = none, below = .3333em of protected segment.south east, anchor = east, xshift = .3333em] {\tiny most recently referenced};

                \draw[->] ($(protected segment.west) + (0, -.25em)$) -- node[below] {\tiny \makecell[c]{\textbf{if} size of\\protected\\segment\\above limit}} ($(probationary segment.east) + (0, -.25em)$);
                \draw[->] (probationary segment.west) -- node[below] {\tiny \textbf{evict}} ($(probationary segment.west) - (3em, 0)$);
                \draw[->] ($(probationary segment.south) + (0, -.5em)$) to[out = 270, in = 180] node[above right = -.25em] {\tiny page hit} ($(probationary segment.south) + (1.5em, -2em)$) to ($(protected segment.south) + (1.5em, -2em)$) to ($(protected segment.south east) + (0, -2em)$) to[out = 0, in = 0, looseness = 2] ($(protected segment.east) + (0, -.25em)$);
                \draw[-]  ($(protected segment.south) + (0, -.5em)$) to[out = 270, in = 180] node[above right = -.25em] {\tiny page hit} ($(protected segment.south) + (1.5em, -2em)$);
                \draw[->] ($(probationary segment.north east) + (2.5em, 1em)$) to[out = 270, in = 0] node[above left = -1.25em, yshift = .5em] {\tiny \makecell[c]{\textbf{fetch} new\\page}} ($(probationary segment.east) + (0, .25em)$);
                \draw[->] ($(probationary segment.west) + (-1.5em, 0)$) to ($(probationary segment.north west) + (-1.5em, 0)$) to[out = 90, in = 180] ($(probationary segment.north west) + (0, 1.5em)$) to node[above = -.25em] {\tiny eviction temporarily or permanently \textbf{impossible}} ($(protected segment.north east) + (0, 1.5em)$) to[out = 0, in = 0, looseness = 2] ($(protected segment.east) + (0, .25em)$);
            \end{tikzpicture}
        }
        \vspace{-.5em}
        \caption[SLRU: Page reference statistics]{The probationary and protected segment of SLRU and the flow of pages between those}
        \label{fig:slru}
    \end{figure}
\end{@empty}

\paragraph{Page Reference Statistics}

    The page reference statistics consist of two LRU queues, the probationary segment and the protected segment. The \emph{protected segment} has an adjustable maximum size (usually smaller than the buffer pool), is reserved for pages that are referenced multiple times and is ordered by reference recency. The \emph{probationary segment} contains all buffered pages that were referenced only once, as well as pages that were referenced multiple times, where the most recent reference is less recent than that of any page in the protected segment.

\paragraph{Updates of the Page Reference Statistics}

    Figure \ref{fig:slru} illustrates the \emph{flow of pages} in the page reference statistics of the SLRU page replacement policy. Pages that are fetched into the buffer pool are enqueued in the probationary segment. When a page is re-referenced (but not on unfix), it is removed from the segment it is currently in and enqueued in the protected segment---if the number of pages in the protected segment is exceeded, the least recently referenced page in it is dequeued and enqueued in the probationary segment.

\paragraph{Page Eviction}

    The least recently referenced page from the \emph{probationary segment} will be selected as eviction candidate. If it \emph{cannot be evicted}---either temporarily or permanently---it is assumed that it is a hot page and will therefore be enqueued in the protected segment.

\subsection{CLOCK} \label{subsec:clock}

\paragraph{Introduction}

    The CLOCK page replacement algorithm is a scalable approximation of the \nameref{subsec:lru} page replacement policy which was first described by Corbató in \cite{Corbato:1969}\footnote{F. J. Corbató proposed a more general algorithm with some similarities to \nameref{subsec:gclock}. If the parameter $k$ of his generalized algorithm is set to $1$, the result is the CLOCK page replacement algorithm.}. The implementation of this page replacement algorithm extends the \nameref{subsubsec:loop} variant of the \nameref{subsec:fifo} page replacement policy by a so-called \emph{usage-bit}.

\paragraph{Page Reference Statistics}

    The page reference statistics of the CLOCK page replacement algorithm consists of a \emph{global cyclic counter} (representing the clock hand) and an array of \emph{usage-bits}---one for each buffer frame. The usage-bit of a buffer frame is true if the page contained in it has been referenced since the last sweep of the hand over that buffer frame.

    The cyclic counter used is the \emph{Modulo Counter}, which was evaluated in my Project Thesis \cite{Gilbert:2020}. It uses the modulo (to get a value in the buffer frame index range) of a global counter variable that is incremented using the atomic fetch-and-increment instruction.

    Figure \ref{fig:clock} shows the usage-bits of a buffer pool with $16$ buffer frames arranged in a circle with the clock hand pointing to buffer frame 4. The next buffer frame that the clock pointer moves to has index 5. Its usage-bit is false because it has not been referenced since it was last swept.

\begin{@empty}
    \tikzset{%
        node distance = 1cm,
        refBit/.style = {draw = black, shape = rectangle, fill = black!10},
        hand/.style = {very thick, draw = black}
    }
    
    \begin{figure}[h]
        \centering
        \resizebox{.55\textwidth}{!}{
            \begin{tikzpicture}
                \foreach \index/\referenced in {0/true, 1/true, 2/false, 3/true, 4/false, 5/false, 6/false, 7/false, 8/true, 9/true, 10/false, 11/false, 12/true, 13/true, 14/true, 15/false} {
                    \ifthenelse{\index < 8}{%
                        \node [refBit, rotate = 90-11.25-\index*22.5] at (90-11.25-\index*22.5:2.5) {\referenced};%
                    }{%
                        \node [refBit, rotate = 270-11.25-\index*22.5] at (90-11.25-\index*22.5:2.5) {\referenced};%
                    }
                    \node [draw = none, font = \small] at (90-11.25-\index*22.5:1.8125) {\index};
                }
                \path[->] (0,0)		edge[hand]		(-11.25:1.625);
                \draw [->, thick] (0,0)+(-22.5:1.333) arc [start angle = -22.5, end angle = -78.75, radius = 1.333];
            \end{tikzpicture}
        }
        \vspace{.75em}
        \caption[Page reference statistics of CLOCK]{The page reference statistics of the CLOCK page replacement algorithm}
        \label{fig:clock}
    \end{figure}
\end{@empty}

\paragraph{Updates of the Page Reference Statistics}

    Each time a \emph{page hit} occurs, the usage-bit of the corresponding buffer frame is \emph{set to true} atomically. This can also be done whenever a \emph{page is unfixed} or when a page selected as a candidate for eviction by the CLOCK page replacement algorithm \emph{cannot be evicted}. When a page is fetched into the buffer pool, its corresponding usage-bit can either be set to false, which results in a faster eviction of pages that are \emph{referenced only once}, or it can be set to true. If the use bit is always set to true when the corresponding page is unfixed, an initially false use bit will always be true as soon as the page can be evicted.

\paragraph{Page Eviction}

    The CLOCK page eviction algorithm \emph{moves its clock hand forward}---setting the usage-bits of the buffer frames which have been swept to true---until it points to a buffer frame where the \emph{usage-bit is false}. This buffer frame is then the selected eviction candidate.

    It approximates the \nameref{subsec:lru} page replacement policy by storing---instead of the exact time of the most recent reference of each page----the information \emph{whether a page was referenced in a particular time frame}---which corresponds to a complete sweep of the clock---in its page reference statistics. With this information, it is not possible to determine the \emph{exact order of the pages} based on the most recent references, but it is guaranteed that the most recent reference of the least recently referenced page was less than the time of a complete sweep of the clock hand before the most recent reference of the page selected as an eviction candidate.

\paragraph{Performance Evaluation}

    Figure \ref{fig:clockthroughput} shows transaction throughput and figure \ref{fig:clockhitrate} shows the miss rate achieved with different variants of the CLOCK page replacement algorithm for different buffer pool sizes. Details of the benchmark setup can be found in section \ref{sec:page_evictioners_performance_evaluation}.

\begin{@empty}
    \pgfplotsset{%
        every axis/.append style = {
            xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
            ylabel near ticks,
            y label style = {font = \small},
            yticklabel style = {font = \scriptsize},
            ymode = normal,
            scaled y ticks = false,
            ybar = .8pt,
            xmin = -0.75,
            xmax = 7.75,
            bar width = .55em,
            xtick style = {draw = none},
            xtick = {0, 1, 2, 3, 4, 5, 6, 7},
            xticklabels = {{\SI{100}{\mega\byte}}, {\SI{500}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2.5}{\giga\byte}}, {\SI{5}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{30}{\giga\byte}}},
            x tick label style = {align = center, font = \footnotesize},
            xlabel near ticks,
            x label style = {font = \small},
            ymajorgrids = true,
            legend entries = {Fix, Unfix, FixUnfix, Full},
            legend style = {font = \footnotesize,
                            legend columns = -1,
                            /tikz/every even column/.append style = {column sep = 0.5cm}},
            width = \textwidth,
            height = .4\textheight
        }
    }
    
    \tikzset{%
        fix/.style = {thick},
        unfix/.style = {thick},
        fixunfix/.style = {thick},
        full/.style = {thick}
    }
    
    \nottoggle{bwmode}{
        \tikzset{%
            fix/.append style = {draw = Cyan, fill = Cyan!50},
            unfix/.append style = {draw = Magenta, fill = Magenta!50},
            fixunfix/.append style = {draw = blue, fill = blue!50},
            full/.append style = {draw = black, fill = black!50}
        }
    }{
        \tikzset{%
            fix/.append style = {draw = black, pattern = north east lines},
            unfix/.append style = {draw = black, pattern = north west lines},
            fixunfix/.append style = {draw = black, pattern = crosshatch},
            full/.append style = {draw = black, pattern = dots}
        }
    }
    
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Transaction throughput }\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
                         legend pos = north west]
                \addplot[fix] coordinates
                    {(0, 64101.70) (1, 79671.85) (2, 92642.61) (3, 142191.06) (4, 248060.53) (5, 618312.54) (6, 765080.14) (7, 884937.94)};
                \addplot[unfix] coordinates
                    {(0, 65258.34) (1, 80603.40) (2, 91767.14) (3, 142441.22) (4, 243736.23) (5, 626089.00) (6, 755520.72) (7, 883699.37)};
                \addplot[fixunfix] coordinates
                    {(0, 65841.74) (1, 79656.75) (2, 94042.93) (3, 143951.26) (4, 244904.41) (5, 623828.48) (6, 771109.94) (7, 887411.97)};
                \addplot[full] coordinates
                    {(0, 66889.87) (1, 79510.40) (2, 96140.14) (3, 143675.28) (4, 253828.17) (5, 644553.46) (6, 765998.78) (7, 887183.25)};
            \end{axis}
        \end{tikzpicture}
        \caption[Transaction throughput of CLOCK variants]{Transaction throughput of the \nameref{subsec:clock} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:clockthroughput}
    \end{figure}

    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         legend pos = north east,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[fix] coordinates
                    {(0, 79.49) (1, 88.81) (2, 92.38) (3, 96.46) (4, 98.28) (5, 99.71) (6, 99.85) (7, 99.86)};
                \addplot[unfix] coordinates
                    {(0, 79.48) (1, 88.83) (2, 92.39) (3, 96.48) (4, 98.27) (5, 99.71) (6, 99.85) (7, 99.86)};
                \addplot[fixunfix] coordinates
                    {(0, 79.49) (1, 88.84) (2, 92.40) (3, 96.46) (4, 98.26) (5, 99.71) (6, 99.85) (7, 99.86)};
                \addplot[full] coordinates
                    {(0, 78.22) (1, 87.52) (2, 92.12) (3, 96.29) (4, 98.25) (5, 99.65) (6, 99.85) (7, 99.86)};
            \end{axis}
        \end{tikzpicture}
        \caption[Miss rate of CLOCK variants]{Miss rate of the \nameref{subsec:clock} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:clockhitrate}
    \end{figure}
\end{@empty}

    The \emph{Fix} variant sets the corresponding usage-bit to true whenever a page hit occurs. The \emph{Unfix} variant does this on page unfix, and the \emph{FixUnfix} variant combines the two. The \emph{Full} variant does it also if the buffer frame cannot be reclaimed after it being selected as eviction candidate. Only the \emph{Fix} variant allows the immediate eviction of a page referenced once.

    The different variants show only slight differences in performance. The additional overhead for setting the usage-bit to true for the \emph{FixUnfix} variant is negligible and the difference in the resulting miss rates is statistically insignificant. The only difference that can be observed at all is the slightly higher miss rate achieved with the \emph{Full} variant, indicating that a page that cannot be evicted temporarily should not be considered hot. But even if the \emph{Full} variant has the highest overhead, it does not perform worse than the other variants when it comes to the achieved transaction throughput.

    The \emph{Full} variant is used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}.

\subsection[ZCLOCK]{Zero-Handed CLOCK (ZCLOCK)} \label{subsec:zclock}

\paragraph{Introduction}

    The ZCLOCK page replacement algorithm is a variation of the \nameref{subsec:clock} page replacement algorithm, in which the \emph{clock hand points to a random buffer frame at every move}. The result is a \nameref{subsec:random} page replacement algorithm in which each buffer frame is given a \emph{second chance} to be referenced again. The random selection is done using \emph{SplitMix32}.

\begin{@empty}
    \pgfplotsset{%
        every axis/.append style = {
            xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
            ylabel near ticks,
            y label style = {font = \small},
            yticklabel style = {font = \scriptsize},
            ymode = normal,
            scaled y ticks = false,
            ybar = .8pt,
            xmin = -0.75,
            xmax = 7.75,
            bar width = .55em,
            xtick style = {draw = none},
            xtick = {0, 1, 2, 3, 4, 5, 6, 7},
            xticklabels = {{\SI{100}{\mega\byte}}, {\SI{500}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2.5}{\giga\byte}}, {\SI{5}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{30}{\giga\byte}}},
            x tick label style = {align = center, font = \footnotesize},
            xlabel near ticks,
            x label style = {font = \small},
            ymajorgrids = true,
            legend entries = {Fix, Unfix, FixUnfix, Full},
            legend style = {font = \footnotesize,
                            legend columns = -1,
                            /tikz/every even column/.append style = {column sep = 0.5cm}},
            width = \textwidth,
            height = .4\textheight
        }
    }
    
    \tikzset{%
        fix/.style = {thick},
        unfix/.style = {thick},
        fixunfix/.style = {thick},
        full/.style = {thick}
    }
    
    \nottoggle{bwmode}{
        \tikzset{%
            fix/.append style = {draw = Cyan, fill = Cyan!50},
            unfix/.append style = {draw = Magenta, fill = Magenta!50},
            fixunfix/.append style = {draw = blue, fill = blue!50},
            full/.append style = {draw = black, fill = black!50}
        }
    }{
        \tikzset{%
            fix/.append style = {draw = black, pattern = north east lines},
            unfix/.append style = {draw = black, pattern = north west lines},
            fixunfix/.append style = {draw = black, pattern = crosshatch},
            full/.append style = {draw = black, pattern = dots}
        }
    }
    
    \begin{figure}
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Transaction throughput }\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
                         legend pos = north west]
                \addplot[fix] coordinates
                    {(0, 68497.96) (1, 81310.75) (2, 95666.51) (3, 141048.76) (4, 257937.87) (5, 748964.14) (6, 831333.07) (7, 887381.33)};
                \addplot[unfix] coordinates
                    {(0, 68735.66) (1, 81235.53) (2, 95112.94) (3, 141372.05) (4, 252519.35) (5, 740675.06) (6, 826589.22) (7, 887066.52)};
                \addplot[fixunfix] coordinates
                    {(0, 66262.42) (1, 79199.88) (2, 94841.88) (3, 140062.95) (4, 250143.61) (5, 732804.97) (6, 820238.34) (7, 884463.27)};
                \addplot[full] coordinates
                    {(0, 67929.24) (1, 79571.06) (2, 96412.80) (3, 141834.10) (4, 254240.30) (5, 639458.83) (6, 752035.27) (7, 887811.83)};
            \end{axis}
        \end{tikzpicture}
        \caption[Transaction throughput of ZCLOCK variants]{Transaction throughput of the \nameref{subsec:zclock} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:zclockthroughput}
    \end{figure}
    
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         legend pos = north east,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[fix] coordinates
                    {(0, 78.52) (1, 87.23) (2, 91.73) (3, 96.26) (4, 98.29) (5, 99.65) (6, 99.85) (7, 99.86)};
                \addplot[unfix] coordinates
                    {(0, 79.13) (1, 87.38) (2, 91.73) (3, 96.27) (4, 98.28) (5, 99.66) (6, 99.85) (7, 99.86)};
                \addplot[fixunfix] coordinates
                    {(0, 79.13) (1, 87.42) (2, 91.74) (3, 96.28) (4, 98.26) (5, 99.66) (6, 99.85) (7, 99.86)};
                \addplot[full] coordinates
                    {(0, 78.23) (1, 87.51) (2, 92.12) (3, 96.31) (4, 98.25) (5, 99.65) (6, 99.85) (7, 99.86)};
            \end{axis}
        \end{tikzpicture}
        \caption[Miss rate of ZCLOCK variants]{Miss rate of the \nameref{subsec:zclock} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:zclockhitrate}
    \end{figure}
\end{@empty}

\paragraph{Page Reference Statistics}

    The page reference statistics of the ZCLOCK page replacement algorithm for a buffer pool with $16$ buffer frame is shown in figure \ref{fig:zclock}. There is just one \emph{usage-bit} (but actually no clock hand) for each buffer frame---if true, the corresponding page has been referenced since the clock hand last pointed to it. ZCLOCK uses the usage-bits in the same way as the \nameref{subsec:clock} page replacement algorithm. But the random movement of the clock hand makes the \emph{duration between two times the clock hand points to a particular buffer frame completely unpredictable}, resulting in behavior less similar to the \nameref{subsec:lru} page replacement policy.

\begin{@empty}
    \tikzset{%
        node distance = 1em,
        refBit/.style = {draw = black, shape = rectangle, fill = black!10},
        hand/.style = {very thick, draw = black}
    }
    
    \begin{figure}[h]
        \centering
        \resizebox{\linewidth}{!}{
            \begin{tikzpicture}
%                \node[anchor = center] at (-1.375,0) {\small Usage-bits};
%                \node[anchor = center] at (-1.375,0.75) {\small Buffer indexes};
            \foreach \index/\referenced in {0/true, 1/true, 2/false, 3/true, 4/false, 5/false, 6/false, 7/false, 8/true, 9/true, 10/false, 11/false, 12/true, 13/true, 14/true, 15/false} {
                \node [refBit, rotate = 90] at (.75*\index,0) {\referenced};%
                \node [draw = none, font = \small] at (.75*\index,0.75) {\index};
            }
            \end{tikzpicture}
        }
        \vspace{-.5em}
        \caption[Page reference statistics of ZCLOCK]{The page reference statistics of the ZCLOCK page replacement algorithm}
        \label{fig:zclock}
    \end{figure}
\end{@empty}

\paragraph{Performance Evaluation}

    Figure \ref{fig:zclockthroughput} shows transaction throughput and figure \ref{fig:zclockhitrate} shows the miss rates achieved with different variants of the ZCLOCK page replacement algorithm for different buffer pool sizes. Details of the benchmark setup can be found in section \ref{sec:page_evictioners_performance_evaluation}.

    The evaluated variants of ZCLOCK are the same as for \nameref{subsec:clock}.

    The lower overhead variants of the ZCLOCK page replacement algorithm, \emph{Fix} and \emph{Unfix}, perform best, regardless of buffer pool size. The variant with the highest overhead---\emph{Full}---achieves a lower \emph{transaction throughput}---especially when the database almost fits into the buffer pool.

    With \emph{larger buffer pools} (\SI{\geq 2.5}{\giga\byte}), the \emph{miss rates} achieved are almost identical for all variants. The small deviations for \emph{smaller buffer pools} are statistically insignificant.

    In contrast to the results for the \nameref{subsec:clock} page replacement algorithm, the ZCLOCK page replacement algorithm cannot benefit from more information collected in the page reference statistics of the \emph{Full} variant. The less predictable behavior of ZCLOCK---with more or less \emph{random eviction decisions}---cannot properly utilize this information.

    The \emph{Fix} variant is used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}.

\subsection[GCLOCK]{Generalized CLOCK (GCLOCK)} \label{subsec:gclock}

\paragraph{Introduction}

    The GCLOCK page replacement algorithm is a scalable approximation to the \nameref{subsec:lru} page replacement policy which was proposed by Effelsberg and Härder in \cite{Effelsberg:1984}. A simpler approach was proposed by Corbató in \cite{Corbato:1969} and extended by Smith in \cite{Smith:1978} by additional rules for prefetching. It \emph{generalizes the \nameref{subsec:clock} page replacement algorithm} by replacing the usage-bit with an \emph{usage-count}, thus including information about reference frequency of a page in the page reference statistics.

\paragraph{Page Reference Statistics}

    The page reference statistics maintained by the GCLOCK page replacement algorithm for an exemplary buffer pool with 16 buffer frames is shown in figure \ref{fig:gclock}. Instead of one usage-bit per buffer frame, as used by the \nameref{subsec:clock} page replacement algorithm, \emph{usage-counts} (of integer type) are used. The \emph{clock hand} is implemented in the same way as in the \nameref{subsec:clock} page replacement algorithm, using the \emph{Modulo Counter} from \cite{Gilbert:2020}.

\begin{@empty}
    \tikzset{%
        node distance = 1cm,
        refInt/.style = {draw = black, shape = rectangle, fill = black!10},
        hand/.style = {very thick, draw = black}
    }
    
    \begin{figure}[h]
        \centering
        \resizebox{.55\textwidth}{!}{
            \begin{tikzpicture}
                \foreach \index/\referenced in {0/45, 1/1, 2/4, 3/5, 4/0, 5/1, 6/6, 7/1, 8/2, 9/2, 10/0, 11/2, 12/2, 13/1, 14/0, 15/4} {
                    \ifthenelse{\index < 8}{%
                        \node [refInt, rotate = 90-11.25-\index*22.5] at (90-11.25-\index*22.5:2.5) {\referenced};%
                    }{%
                        \node [refInt, rotate = 270-11.25-\index*22.5] at (90-11.25-\index*22.5:2.5) {\referenced};%
                    }
                    \node [draw = none, font = \small] at (90-11.25-\index*22.5:2) {\index};
                }
                \path[->] (0,0)		edge[hand]		(-11.25:1.8125);
                \draw [->, thick] (0,0)+(-22.5:1.5205) arc [start angle = -22.5, end angle = -78.75, radius = 1.5205];
            \end{tikzpicture}
        }
        \vspace{.75em}
        \caption[Page reference statistics of (D)GCLOCK]{The page reference statistics of the GCLOCK and DGCLOCK page replacement algorithms}
        \label{fig:gclock}
    \end{figure}
\end{@empty}

\paragraph{Updates of Page Reference Statistics}

    Effelsberg and Härder worked out \emph{two different versions} of the GCLOCK page replacement algorithm, \nameref{subsubsec:gclock-v1} and \nameref{subsubsec:gclock-v2} with different rules for updating the usage-counts in case of a \emph{page hit} (or alternatively in case of a \emph{page unfix}). The usage-counts can also be updated based on these rules if an \emph{eviction candidate cannot be evicted} temporarily or permanently. The different rules are specified in subsections \ref{subsubsec:gclock-v1} and \ref{subsubsec:gclock-v2}. Both versions of the GCLOCK page replacement algorithm define a parameter $F$ to which a corresponding usage-count is set ($UC\left(p\right) = F$) \emph{when a page} $p$ \emph{is fetched} into a buffer frame.

    For optimal hit rates, the values of all the parameters defined by the GCLOCK page replacement algorithms needs to be chosen specifically for every application. The optimization effort is likely to prevent the usage of these page replacement algorithms in any production DBMS.

\paragraph{Page Eviciton}

    Both versions of the evict pages the same way. They \emph{move the clock hand forward}---decrementing the usage-counts of the buffer frames which have been touched by the value of a new parameter $S$ (which is not part of the definition in \cite{Effelsberg:1984})---until it points to a buffer frame where the \emph{usage-count is $0$}. This buffer frame is then the selected eviction candidate.

\subsubsection{GCLOCK-V1} \label{subsubsec:gclock-v1}

\paragraph{Introduction}

    The GCLOCK-V1 page replacement algorithm is the version of the \nameref{subsec:gclock} page replacement algorithm where \emph{reference recency} and \emph{reference frequency} are taken into account for eviction decisions. One or the other factor can be taken into account to a greater extent by choosing the appropriate parameter values.

\paragraph{Updates of Page Reference Statistics}

    The GCLOCK-V1 page replacement algorithm \emph{increases} the corresponding usage-count ($UC\left(p\right) = UC\left(p\right) + R$) of a page $p$ by the value of the parameter $R$ on page hit (or alternatively on page unfix). In this way, the usage-count of a page represents the number of references to this page. The decrease of the usage-counts during eviction can be seen as an \emph{aging process}. With a greater value for $R$, eviction decisions are based more on \emph{reference frequency} while a greater $S$ result in an increased focus on \emph{reference recency}.

\paragraph{Performance Evaluation}

    Figure \ref{fig:gclockv1throughput} shows transaction throughput and figure \ref{fig:gclockv1hitrate} shows the miss rate achieved with different variants of the GCLOCK-V1 page replacement algorithm for different buffer pool sizes. Details of the benchmark setup can be found in section \ref{sec:page_evictioners_performance_evaluation}.

\begin{@empty}
    \pgfplotsset{%
        every axis/.append style = {
            xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
            ylabel near ticks,
            y label style = {font = \small},
            yticklabel style = {font = \scriptsize},
            ymode = normal,
            scaled y ticks = false,
            ybar = .8pt,
            xmin = -0.75,
            xmax = 7.75,
            bar width = .25em,
            xtick style = {draw = none},
            xtick = {0, 1, 2, 3, 4, 5, 6, 7},
            xticklabels = {{\SI{100}{\mega\byte}}, {\SI{500}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2.5}{\giga\byte}}, {\SI{5}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{30}{\giga\byte}}},
            x tick label style = {align = center, font = \footnotesize},
            xlabel near ticks,
            x label style = {font = \small},
            ymajorgrids = true,
            legend entries = {Fix, FixFull, Unfix, UnfixFull, Fixx2, FixFullx2, Unfixx2, UnfixFullx2},
            legend style = {font = \footnotesize,
                            legend columns = 4,
                            /tikz/every even column/.append style = {column sep = 0.5cm}},
            width = \textwidth,
            height = .4\textheight
        }
    }
    
    \tikzset{%
        fix/.style = {thick},
        fixfull/.style = {thick},
        unfix/.style = {thick},
        unfixfull/.style = {thick}
    }
    
    \nottoggle{bwmode}{
        \tikzset{%
            x2/.style = {dashed},
            fix/.append style = {draw = Cyan!50, fill = Cyan!25},
            fixfull/.append style = {draw = Cyan, fill = Cyan!50},
            unfix/.append style = {draw = Magenta!50, fill = Magenta!25},
            unfixfull/.append style = {draw = Magenta, fill = Magenta!50}
        }
    }{
        \tikzset{%
            x2/.style = {densely dashed},
            fix/.append style = {draw = black!50, pattern = north east lines},
            fixfull/.append style = {draw = black, pattern = north east lines},
            unfix/.append style = {draw = black!50, pattern = north west lines},
            unfixfull/.append style = {draw = black, pattern = north west lines}
        }
    }
    
    \begin{figure}[t]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Transaction throughput }\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
                         legend pos = north west]
                \addplot[fix] coordinates
                    {(0, 65049.45) (1, 78530.77) (2, 88025.23) (3, 125866.02) (4, 187490.74) (5, 404662.39) (6, 675934.32) (7, 881666.37)};
                \addplot[fixfull] coordinates
                    {(0, 65360.99) (1, 83246.02) (2, 91920.02) (3, 129170.52) (4, 202754.77) (5, 476000.85) (6, 689875.86) (7, 882042.46)};
                \addplot[unfix] coordinates
                    {(0, 66291.95) (1, 78447.75) (2, 89785.49) (3, 127051.88) (4, 186308.27) (5, 405952.72) (6, 674918.45) (7, 869788.30)};
                \addplot[unfixfull] coordinates
                    {(0, 64561.13) (1, 81396.24) (2, 90398.24) (3, 132267.48) (4, 202467.74) (5, 475327.68) (6, 684862.90) (7, 882622.07)};
                \addplot[fix, x2] coordinates
                    {(0, 65053.38) (1, 75641.80) (2, 87839.72) (3, 125580.15) (4, 177340.18) (5, 350625.16) (6, 655014.83) (7, 890546.99)};
                \addplot[fixfull, x2] coordinates
                    {(0, 65077.68) (1, 77498.27) (2, 91237.39) (3, 129569.02) (4, 201051.50) (5, 444821.84) (6, 672896.71) (7, 883866.71)};
                \addplot[unfix, x2] coordinates
                    {(0, 63763.35) (1, 76889.43) (2, 87512.01) (3, 124617.60) (4, 176894.46) (5, 354239.62) (6, 653033.24) (7, 879953.96)};
                \addplot[unfixfull, x2] coordinates
                    {(0, 65271.86) (1, 80203.53) (2, 90558.15) (3, 129200.63) (4, 198557.05) (5, 445591.47) (6, 674298.46) (7, 888827.20)};
            \end{axis}
        \end{tikzpicture}
        \caption[Transaction throughput of GCLOCK-V1 variants]{Transaction throughput of the \nameref{subsubsec:gclock-v1} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:gclockv1throughput}
    \end{figure}
    
    \begin{figure}[t]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         legend pos = north east,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[fix] coordinates
                    {(0, 81.50) (1, 89.54) (2, 92.00) (3, 95.99) (4, 97.83) (5, 99.45) (6, 99.84) (7, 99.86)};
                \addplot[fixfull] coordinates
                    {(0, 80.38) (1, 89.42) (2, 92.16) (3, 96.09) (4, 97.86) (5, 99.47) (6, 99.84) (7, 99.86)};
                \addplot[unfix] coordinates
                    {(0, 81.64) (1, 89.54) (2, 92.02) (3, 96.02) (4, 97.82) (5, 99.45) (6, 99.84) (7, 99.86)};
                \addplot[unfixfull] coordinates
                    {(0, 80.60) (1, 89.37) (2, 92.16) (3, 96.10) (4, 97.87) (5, 99.47) (6, 99.84) (7, 99.86)};
                \addplot[fix, x2] coordinates
                    {(0, 82.47) (1, 89.48) (2, 91.88) (3, 95.93) (4, 97.82) (5, 99.46) (6, 99.84) (7, 99.86)};
                \addplot[fixfull, x2] coordinates
                    {(0, 80.91) (1, 89.47) (2, 92.07) (3, 96.02) (4, 97.86) (5, 99.46) (6, 99.84) (7, 99.86)};
                \addplot[unfix, x2] coordinates
                    {(0, 82.52) (1, 89.49) (2, 91.89) (3, 95.93) (4, 97.82) (5, 99.46) (6, 99.84) (7, 99.86)};
                \addplot[unfixfull, x2] coordinates
                    {(0, 81.08) (1, 89.46) (2, 92.08) (3, 96.02) (4, 97.85) (5, 99.46) (6, 99.84) (7, 99.86)};
            \end{axis}
        \end{tikzpicture}
        \caption[Miss rate of GCLOCK-V1 variants]{Miss rate of the \nameref{subsubsec:gclock-v1} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:gclockv1hitrate}
    \end{figure}
\end{@empty}

    The \emph{Fix} variant uses $F = 25$ when a page is fetched into the buffer pool and $R = 5$ when a page is fixed, while the \emph{FixFull} variant also updates usage numbers based on $R$ when an eviction candidate cannot be evicted. The \emph{Unfix} and \emph{UnfixFull} variants are the equivalents for updates on page unfix. The variants ending on \emph{x2} use $F = 50$ and $R = 10$---which both increases overhead and improves the information available for eviction decisions. The $S$ parameter is always $1$, which gives the GCLOCK-V1 variants a focus on the reference frequency.

    For the \emph{most buffer pool sizes} the \emph{FixFull} variants outperform the \emph{Fix} variants and the \emph{UnfixFull} variants outperform the \emph{Unfix} variants in terms of transaction throughput. If the buffer pool is \emph{slightly smaller than the initial DB} (\SI{10}{\giga\byte}), the performance difference is about \SI{15}{\percent}. The difference is smaller for \emph{smaller buffer pools}, and for a \SI{100}{\mega\byte} buffer pool, the \emph{Fix} and \emph{Unfix} variants are even slightly faster. Once the buffer pool is \emph{larger than the database}, the performance differences become statistically insignificant ($\pm\SI{0.5}{\percent}$). The performance differences between the \emph{Fix} (\emph{FixFull}) and the \emph{Unfix} (\emph{UnfixFull}) variants are negligible ($\pm\SI{2}{\percent}$).

    The \emph{miss rates} of the \emph{FixFull} and \emph{UnfixFull} variants are \SI{0.53}{\percent} if the buffer pool size is \SI{10}{\giga\byte}, while they are \SI{0.55}{\percent} for the \emph{Fix} and \emph{Unfix} variants. For the \emph{x2} variants, the miss rates are \SI{0.54}{\percent}. The \emph{miss rate} of the \emph{FixFull} and \emph{UnfixFull} variants is also lower for a buffer pool of \SIrange{1}{5}{\giga\byte}. The higher miss rates of the \emph{FixFull} and \emph{UnfixFull} variants for the buffer pool size \SI{500}{\mega\byte} are counterintuitive considering the transaction throughput achieved. Once the \emph{complete database fits into the buffer pool}, the miss rates of all variants are identical.

    The almost non-existent performance and miss rate difference when the \emph{database is completely in memory} is to be expected, since in this case no pages need to be evicted. Therefore, the only overhead due to the page replacement algorithm is the incrementing of the usage-count on either page fix or page unfix. The negligible difference in performance between the \emph{Fix} (\emph{FixFull}) and the \emph{Unfix} (\emph{unfixFull}) variants is the result of the fact, that the clock hand passes a page $\mathord{\geq} 25\times$ between fetching the page into the buffer pool and evicting it from it for \emph{Fix} (\emph{FixFull}), but only once more for \emph{Unfix} (\emph{UnfixFull}). The lower miss rate and better performance of the \emph{FixFull} and \emph{UnfixFull} variants for \emph{medium-sized buffer pools} suggest that the pages that cannot be evicted temporarily will be re-referenced in the near future. The decreasing differences in performance for \emph{smaller buffer pools} are the result of shorter clock hand cycle times, which leads to a smaller effect of this additional increase of the usage-count.

    The \emph{FixFull} variant is used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}.

\subsubsection{GCLOCK-V2} \label{subsubsec:gclock-v2}

\paragraph{Introduction}

    The GCLOCK-V2 page replacement algorithm is the version of the \nameref{subsec:gclock} page replacement algorithm where only \emph{reference recency} is taken into account for eviction decisions. GCLOCK-V2 with $R = 1$ is equivalent to \nameref{subsec:clock}.

\paragraph{Updates of Page Reference Statistics}

    The GCLOCK-V2 page replacement algorithm \emph{sets} the corresponding usage-count ($UC\left(p\right) = R$) of a page $p$ to the value of the parameter $R$ on page hit (or alternatively on page unfix). Higher $R$ result in more precise information about how many page misses have occurred in the DBMS (which corresponds to the time elapsed) since the most recent reference of a page. This allows a \emph{better approximation} to the \nameref{subsec:lru} page replacement algorithm.

\paragraph{Performance Evaluation}

    Figure \ref{fig:gclockv2throughput} shows transaction throughput and figure \ref{fig:gclockv2hitrate} shows the miss rate achieved with different variants of the GCLOCK-V2 page replacement algorithm for different buffer pool sizes. Details of the benchmark setup can be found in section \ref{sec:page_evictioners_performance_evaluation}.

\begin{@empty}
    \pgfplotsset{%
        every axis/.append style = {
            xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
            ylabel near ticks,
            y label style = {font = \small},
            yticklabel style = {font = \scriptsize},
            ymode = normal,
            scaled y ticks = false,
            ybar = .8pt,
            xmin = -0.75,
            xmax = 7.75,
            bar width = .25em,
            xtick style = {draw = none},
            xtick = {0, 1, 2, 3, 4, 5, 6, 7},
            xticklabels = {{\SI{100}{\mega\byte}}, {\SI{500}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2.5}{\giga\byte}}, {\SI{5}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{30}{\giga\byte}}},
            x tick label style = {align = center, font = \footnotesize},
            xlabel near ticks,
            x label style = {font = \small},
            ymajorgrids = true,
            legend entries = {Fix, FixFull, Unfix, UnfixFull, Fixx2, FixFullx2, Unfixx2, UnfixFullx2},
            legend style = {font = \footnotesize,
                            legend columns = 4,
                            /tikz/every even column/.append style = {column sep = 0.5cm}},
            width = \textwidth,
            height = .4\textheight
        }
    }
    
    \tikzset{%
        fix/.style = {thick},
        fixfull/.style = {thick},
        unfix/.style = {thick},
        unfixfull/.style = {thick}
    }
    
    \nottoggle{bwmode}{
        \tikzset{%
            x2/.style = {dashed},
            fix/.append style = {draw = Cyan!50, fill = Cyan!25},
            fixfull/.append style = {draw = Cyan, fill = Cyan!50},
            unfix/.append style = {draw = Magenta!50, fill = Magenta!25},
            unfixfull/.append style = {draw = Magenta, fill = Magenta!50}
        }
    }{
        \tikzset{%
            x2/.style = {densely dashed},
            fix/.append style = {draw = black!50, pattern = north east lines},
            fixfull/.append style = {draw = black, pattern = north east lines},
            unfix/.append style = {draw = black!50, pattern = north west lines},
            unfixfull/.append style = {draw = black, pattern = north west lines}
        }
    }
    
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Transaction throughput }\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
                         ymax = 1015000,
                         legend pos = north west]
                \addplot[fix] coordinates
                    {(0, 66126.22) (1, 78730.54) (2, 90953.54) (3, 135387.68) (4, 227063.82) (5, 609152.63) (6, 751719.47) (7, 884719.45)};
                \addplot[fixfull] coordinates
                    {(0, 65393.24) (1, 81024.72) (2, 92649.90) (3, 137824.18) (4, 244067.96) (5, 628208.19) (6, 758292.72) (7, 885172.15)};
                \addplot[unfix] coordinates
                    {(0, 67529.88) (1, 80321.59) (2, 94150.54) (3, 144352.48) (4, 246033.75) (5, 621083.97) (6, 761953.84) (7, 885285.05)};
                \addplot[unfixfull] coordinates
                    {(0, 66861.31) (1, 86048.74) (2, 95854.25) (3, 139702.65) (4, 251889.60) (5, 648089.89) (6, 760777.46) (7, 882899.51)};
                \addplot[fix, x2] coordinates
                    {(0, 64701.21) (1, 79005.75) (2, 89500.81) (3, 132592.94) (4, 216295.66) (5, 600499.71) (6, 759997.84) (7, 882521.02)};
                \addplot[fixfull, x2] coordinates
                    {(0, 65431.32) (1, 79982.58) (2, 92944.35) (3, 138711.32) (4, 244790.12) (5, 637692.04) (6, 761768.15) (7, 887521.89)};
                \addplot[unfix, x2] coordinates
                    {(0, 65541.10) (1, 78690.31) (2, 92954.34) (3, 141412.99) (4, 245345.80) (5, 618599.29) (6, 758756.01) (7, 881595.05)};
                \addplot[unfixfull, x2] coordinates
                    {(0, 65776.77) (1, 83164.87) (2, 95581.74) (3, 143411.60) (4, 262159.61) (5, 651048.14) (6, 773517.04) (7, 890192.98)};
            \end{axis}
        \end{tikzpicture}
        \caption[Transaction throughput of GCLOCK-V2 variants]{Transaction throughput of the \nameref{subsubsec:gclock-v2} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:gclockv2throughput}
    \end{figure}
    
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         legend pos = north east,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[fix] coordinates
                    {(0, 80.11) (1, 88.11) (2, 92.06) (3, 96.37) (4, 98.18) (5, 99.71) (6, 99.85) (7, 99.86)};
                \addplot[fixfull] coordinates
                    {(0, 78.99) (1, 87.10) (2, 91.84) (3, 96.29) (4, 98.18) (5, 99.68) (6, 99.85) (7, 99.86)};
                \addplot[unfix] coordinates
                    {(0, 79.47) (1, 88.81) (2, 92.39) (3, 96.47) (4, 98.26) (5, 99.71) (6, 99.85) (7, 99.86)};
                \addplot[unfixfull] coordinates
                    {(0, 78.12) (1, 87.35) (2, 92.12) (3, 96.33) (4, 98.24) (5, 99.68) (6, 99.85) (7, 99.86)};
                \addplot[fix, x2] coordinates
                    {(0, 80.80) (1, 88.50) (2, 92.05) (3, 96.32) (4, 98.16) (5, 99.70) (6, 99.85) (7, 99.86)};
                \addplot[fixfull, x2] coordinates
                    {(0, 79.28) (1, 87.19) (2, 91.87) (3, 96.24) (4, 98.16) (5, 99.66) (6, 99.85) (7, 99.86)};
                \addplot[unfix, x2] coordinates
                    {(0, 80.47) (1, 89.29) (2, 92.45) (3, 96.51) (4, 98.29) (5, 99.70) (6, 99.85) (7, 99.86)};
                \addplot[unfixfull, x2] coordinates
                    {(0, 78.38) (1, 87.74) (2, 92.20) (3, 96.32) (4, 98.26) (5, 99.66) (6, 99.85) (7, 99.86)};
            \end{axis}
        \end{tikzpicture}
        \caption[Miss rate of GCLOCK-V2 variants]{Miss rate of the \nameref{subsubsec:gclock-v2} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:gclockv2hitrate}
    \end{figure}
\end{@empty}

    The evaluated variants of GCLOCK-V2 and the corresponding parameter values are the same as for \nameref{subsubsec:gclock-v1}.

    The differences in transaction throughput between the different variants of the GCLOCK-V2 page replacement algorithm are smaller than the differences between the variants of the \nameref{subsubsec:gclock-v1} page replacement algorithm. As with \nameref{subsubsec:gclock-v1}, the performance differences are negligible or even statistically insignificant for very small and sufficiently large buffer pools. However, it is an interesting detail that the \emph{Unfix} (\emph{UnfixFull}) variants perform slightly better than the \emph{Fix} (\emph{FixFull}) variants.

    It is absolutely counterintuitive that the miss rates of the \emph{Full} variants are greater than that of the corresponding other variants. But the \emph{Unfix} (\emph{UnfixFull}) variants have slightly lower miss rates than the \emph{Fix} (\emph{FixFull}) variants, which explains the higher transaction throughput.

    The higher performance of the \emph{Unfix} and \emph{UnfixFull} variants suggests that the chosen value for the $F$ parameter is too high. If a page that is referenced only once is unfixed, the \emph{Unfix} and \emph{UnfixFull} variants set the usage-count to $R$, which is one-fifth of $F$. The \emph{Fix} and \emph{FixFull} variants do not do this for these pages, so they stay in the buffer pool much longer without being referenced again. The less superior results for the \emph{Full} variants---compared to these variants with \nameref{subsubsec:gclock-v1}---suggest that pages that could not be evicted temporarily are subsequently referenced more frequently than others, which is taken into account by \nameref{subsubsec:gclock-v1} but not by the GCLOCK-V2 page replacement algorithm.

    The \emph{UnfixFull} variant is thus used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}.

\subsection[DGCLOCK]{Dynamic Generalized CLOCK (DGCLOCK)} \label{subsec:dgclock}

\paragraph{Introduction}

    The DGCLOCK page replacement algorithm is a variant of the \nameref{subsec:gclock} page replacement algorithm, which was also proposed by Effelsberg and Härder in \cite{Effelsberg:1984}, where changes to the usage-count of a buffer frame depend on the \emph{type of page} it contains.

\paragraph{Page Reference Statistics}

    The page reference statistics of the DGCLOCK page replacement algorithm are \emph{identical} to those of the \nameref{subsec:gclock} page replacement algorithm. Examplary page reference statistics are given in figure \ref{fig:gclock}. 

\paragraph{Updates of Page Reference Statistics}

    \emph{Both versions} of the \nameref{subsec:gclock} page replacement algorithm---\nameref{subsubsec:gclock-v1} and \nameref{subsubsec:gclock-v2}---have \emph{``dynamic'' equivalents} under DGCLOCK. \nameref{subsubsec:dgclock-v1} and \nameref{subsubsec:dgclock-v2} define different rules for the updating of usage-counts of buffer frames on corresponding \emph{page hits} (or alternatively on \emph{page unfixes}), and optionally these rules are also applied if a \emph{page cannot be evicted} temporarily or permanently. The rules used by the two versions of DGCLOCK are specified in the sections \ref{subsubsec:dgclock-v1} and \ref{subsubsec:dgclock-v2}. The usage-count associated with a \emph{newly fetched page} is set to the value of parameter $F_i$ for a page of type $i$.

    Since DGCLOCK has even more parameter values to select than \nameref{subsec:gclock}, optimization for specific applications is even more challenging. In a relational DBMS, values for the parameters $F_i$ and $R_i$ must be selected for a variety of page types $i$:

\begin{itemize}
    \item regular data pages
    \item LOB data pages
    \item B-tree index pages of different levels and of primary and secondary indexes
    \item hash index pages of primary and secondary indexes
    \item pages of other index implementations (bitmap, R-tree etc.)
    \item dirty pages
    \item other metadata pages
\end{itemize}

\paragraph{Page Eviction}

    The DGCLOCK page replacement algorithms select the eviction candidates in \emph{exactly the same way} as the \nameref{subsec:gclock} page replacement algorithms---the implementation is absolutely identical.

\subsubsection{DGCLOCK-V1} \label{subsubsec:dgclock-v1}

\paragraph{Introduction}

    The only difference between the DGCLOCK-V1 page replacement algorithm and its ``static'' counterpart \nameref{subsubsec:gclock-v1} is that instead of one parameter $R$ for all pages, there are many \emph{parameters} $R_i$ \emph{for different page types} $i$. A larger value $R_i$ for a specific page type allows prioritizing this page type $i$ in the buffer pool.

\paragraph{Updates of Page Reference Statistics}

    The DGCLOCK-V1 page replacement algorithm \emph{increases} the corresponding usage-count ($UC\left(p\right) = UC\left(p\right) + R_p$) of a page $p$ by the value of the parameter $R_p$, which is specific to the page type of $p$, on page hit (or alternatively on page unfix). Page types $i$ with greater values of $R_i$ are prioritized and therefore corresponding pages are evicted later.

\paragraph{Performance Evaluation}

     Figure \ref{fig:dgclockv1throughput} shows transaction throughput and figure \ref{fig:dgclockv1hitrate} shows the miss rate achieved with different variants of the DGCLOCK-V1 page replacement algorithm for different buffer pool sizes. Details of the benchmark setup can be found in section \ref{sec:page_evictioners_performance_evaluation}.
    
    \begin{@empty}
        \pgfplotsset{%
            every axis/.append style = {
                xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
                ylabel near ticks,
                y label style = {font = \small},
                yticklabel style = {font = \scriptsize},
                ymode = normal,
                scaled y ticks = false,
                ybar = .8pt,
                xmin = -0.75,
                xmax = 7.75,
                bar width = .5em,
                xtick style = {draw = none},
                xtick = {0, 1, 2, 3, 4, 5, 6, 7},
                xticklabels = {{\SI{100}{\mega\byte}}, {\SI{500}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2.5}{\giga\byte}}, {\SI{5}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{30}{\giga\byte}}},
                x tick label style = {align = center, font = \footnotesize},
                xlabel near ticks,
                x label style = {font = \small},
                ymajorgrids = true,
                legend entries = {Fix, FixFull, Fixx2, FixFullx2},
                legend style = {font = \footnotesize,
                                legend columns = 2,
                                /tikz/every even column/.append style = {column sep = 0.5cm}},
                width = \textwidth,
                height = .4\textheight
            }
        }
        
        \tikzset{%
            fix/.style = {thick},
            fixfull/.style = {thick}
        }
        
        \nottoggle{bwmode}{
            \tikzset{%
                x2/.style = {dashed},
                fix/.append style = {draw = Cyan!50, fill = Cyan!25},
                fixfull/.append style = {draw = Cyan, fill = Cyan!50}
            }
        }{
            \tikzset{%
                x2/.style = {densely dashed},
                fix/.append style = {draw = black!50, pattern = north east lines},
                fixfull/.append style = {draw = black, pattern = north east lines}
            }
        }
        
        \begin{figure}[t]
            \centering
            \begin{tikzpicture}
                \begin{axis}[ylabel = {$\text{Transaction throughput }\left[\si{1\per\minute}\right]$},
                             ymode = normal,
                             ymin = 0,
                             legend pos = north west]
                    \addplot[fix] coordinates
                        {(0, 66924.04) (1, 79170.81) (2, 90470.43) (3, 124828.87) (4, 183965.95) (5, 387162.61) (6, 690962.18) (7, 883621.85)};
                    \addplot[fixfull] coordinates
                        {(0, 65642.55) (1, 80478.20) (2, 92000.84) (3, 130455.70) (4, 197013.68) (5, 457477.86) (6, 698882.02) (7, 882489.05)};
                    \addplot[fix, x2] coordinates
                        {(0, 63997.58) (1, 76973.25) (2, 86599.71) (3, 119294.37) (4, 173211.26) (5, 339305.62) (6, 672246.35) (7, 888587.37)};
                    \addplot[fixfull, x2] coordinates
                        {(0, 65406.34) (1, 78498.63) (2, 88725.73) (3, 126351.30) (4, 197455.81) (5, 426242.43) (6, 692582.13) (7, 878486.25)};
                \end{axis}
            \end{tikzpicture}
            \caption[Transaction throughput of DGCLOCK-V1 variants]{Transaction throughput of the \nameref{subsubsec:dgclock-v1} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
            \label{fig:dgclockv1throughput}
        \end{figure}
        
        \begin{figure}[t]
            \centering
            \begin{tikzpicture}
                \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                             ymode = normal,
                             ymin = 100,
                             legend pos = north east,
                             y coord trafo/.code = {
                                 \pgfmathparse{100 - #1}
                                 \pgfmathresult
                             }]
                    \addplot[fix] coordinates
                        {(0, 82.53) (1, 89.69) (2, 91.99) (3, 95.93) (4, 97.77) (5, 99.43) (6, 99.84) (7, 99.86)};
                    \addplot[fixfull] coordinates
                        {(0, 81.31) (1, 89.66) (2, 92.16) (3, 96.04) (4, 97.83) (5, 99.45) (6, 99.84) (7, 99.86)};
                    \addplot[fix, x2] coordinates
                        {(0, 83.70) (1, 89.65) (2, 91.88) (3, 95.87) (4, 97.78) (5, 99.44) (6, 99.84) (7, 99.86)};
                    \addplot[fixfull, x2] coordinates
                        {(0, 82.11) (1, 89.73) (2, 92.10) (3, 95.98) (4, 97.87) (5, 99.44) (6, 99.84) (7, 99.86)};
                \end{axis}
            \end{tikzpicture}
            \caption[Miss rate of DGCLOCK-V1 variants]{Miss rate of the \nameref{subsubsec:dgclock-v1} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
            \label{fig:dgclockv1hitrate}
        \end{figure}
    \end{@empty}
    
    The \emph{Fix} variant uses $F_{\text{non-B-tree}} = 25$, $F_{\text{root}} = 25$, $F_{\text{root} - 1} = 10$ and $F_{\text{root} - \geq 2} = 5$ when a page is fetched into the buffer pool and $R_{\text{non-B-tree}} = 5$, $R_{\text{root}} = 5$, $R_{\text{root} - 1} = 2$ and $R_{\text{root} - \geq 2} = 1$ when a page is fixed, while the \emph{FixFull} variant also updates usage numbers based on $R$ when an eviction candidate cannot be evicted. The variants ending on \emph{x2} use $F_{\text{non-B-tree}} = 50$, $F_{\text{root}} = 50$, $F_{\text{root} - 1} = 25$, $F_{\text{root} - \geq 2} = 10$, $R_{\text{non-B-tree}} = 10$, $R_{\text{root}} = 10$, $R_{\text{root} - 1} = 5$ and $R_{\text{root} - \geq 2} = 2$---which both increases overhead and improves the information available for eviction decisions. The $S$ parameter is always $1$, which gives the DGCLOCK-V1 variants a focus on the reference frequency.

    For buffer pool sizes $\mathord{\geq}\SI{500}{\mega\byte}$, the DGCLOCK-V1 variants with the higher value of $F_i$ and $R_i$ (which end on \emph{x2}) show a slightly worse hit rate and transaction throughput than the other variants. The \emph{FixFull} variant performs best for all these buffer pool sizes. For the \SI{100}{\mega\byte} buffer pool size, the \emph{Fixxx2} variant achieves the lowest miss rate, but the \emph{Fix} variant still achieves the higher transaction throughput.

    The \emph{x2} variants better approximate the behavior of the \nameref{subsec:lru} page replacement policy, but the minimally higher miss rates of these variants for buffer pool sizes $\mathord{\geq}\SI{500}{\mega\byte}$ show that this could not improve the performance for the tested workload. The higher overhead of these DGCLOCK-V1 variants results in a lower transaction throughput even for the \SI{100}{\mega\byte} buffer pool. The slightly lower miss rate and slightly higher transaction throughput of the \emph{FixFull} variants indicate that pages selected for eviction by the DGCLOCK-V1 page replacement algorithm, which cannot be evicted temporarily, are hot and should be kept longer in the buffer pool.

    The \emph{FixFull} variant is used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}.

\subsubsection{DGCLOCK-V2} \label{subsubsec:dgclock-v2}

\paragraph{Introduction}

    The only difference between the DGCLOCK-V2 page replacement algorithm and its ``static'' counterpart \nameref{subsubsec:gclock-v2} is that instead of one parameter $R$ for all pages, there are many \emph{parameters} $R_i$ \emph{for different page types} $i$. A larger value $R_i$ for a specific page type allows prioritizing this page type $i$ in the buffer pool.

\paragraph{Updates of Page Reference Statistics}

    The DGCLOCK-V2 page replacement algorithm \emph{sets} the corresponding usage-count ($UC\left(p\right) = R_p$) of a page $p$ to the value of the parameter $R_p$, which is specific to the page type of $p$, on page hit (or alternatively on page unfix). Page types $i$ with greater values of $R_i$ are prioritized and therefore pages of that type are evicted later.

\paragraph{Performance Evaluation}

    Figure \ref{fig:dgclockv2throughput} shows transaction throughput and figure \ref{fig:dgclockv2hitrate} shows the miss rate achieved with different variants of the DGCLOCK-V2 page replacement algorithm for different buffer pool sizes. Details of the benchmark setup can be found in section \ref{sec:page_evictioners_performance_evaluation}.

\begin{@empty}
    \pgfplotsset{%
        every axis/.append style = {
            xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
            ylabel near ticks,
            y label style = {font = \small},
            yticklabel style = {font = \scriptsize},
            ymode = normal,
            scaled y ticks = false,
            ybar = .8pt,
            xmin = -0.75,
            xmax = 7.75,
            bar width = .5em,
            xtick style = {draw = none},
            xtick = {0, 1, 2, 3, 4, 5, 6, 7},
            xticklabels = {{\SI{100}{\mega\byte}}, {\SI{500}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2.5}{\giga\byte}}, {\SI{5}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{30}{\giga\byte}}},
            x tick label style = {align = center, font = \footnotesize},
            xlabel near ticks,
            x label style = {font = \small},
            ymajorgrids = true,
            legend entries = {Fix, FixFull, Fixx2, FixFullx2},
            legend style = {font = \footnotesize,
                            legend columns = 2,
                            /tikz/every even column/.append style = {column sep = 0.5cm}},
            width = \textwidth,
            height = .4\textheight
        }
    }
    
    \tikzset{%
        fix/.style = {thick},
        fixfull/.style = {thick}
    }
    
    \nottoggle{bwmode}{
        \tikzset{%
            x2/.style = {dashed},
            fix/.append style = {draw = Cyan!50, fill = Cyan!25},
            fixfull/.append style = {draw = Cyan, fill = Cyan!50}
        }
    }{
        \tikzset{%
            x2/.style = {densely dashed},
            fix/.append style = {draw = black!50, pattern = north east lines},
            fixfull/.append style = {draw = black, pattern = north east lines}
        }
    }
    
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Transaction throughput }\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
                         legend pos = north west]
                \addplot[fix] coordinates
                    {(0, 65328.91) (1, 85150.60) (2, 89698.46) (3, 136511.50) (4, 223061.99) (5, 620475.67) (6, 761789.06) (7, 889050.53)};
                \addplot[fixfull] coordinates
                    {(0, 66091.61) (1, 80892.64) (2, 92705.83) (3, 138269.21) (4, 242778.79) (5, 627736.54) (6, 758085.38) (7, 884485.20)};
                \addplot[fix, x2] coordinates
                    {(0, 63105.93) (1, 76825.59) (2, 86478.06) (3, 132019.39) (4, 216118.93) (5, 586734.37) (6, 750078.00) (7, 891430.09)};
                \addplot[fixfull, x2] coordinates
                    {(0, 67430.20) (1, 82767.14) (2, 93595.51) (3, 134557.05) (4, 241585.52) (5, 623190.59) (6, 760453.26) (7, 882858.20)};
            \end{axis}
        \end{tikzpicture}
        \caption[Transaction throughput of DGCLOCK-V2 variants]{Transaction throughput of the \nameref{subsubsec:dgclock-v2} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:dgclockv2throughput}
    \end{figure}
    
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         legend pos = north east,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[fix] coordinates
                    {(0, 80.69) (1, 88.79) (2, 92.25) (3, 96.38) (4, 98.18) (5, 99.71) (6, 99.85) (7, 99.86)};
                \addplot[fixfull] coordinates
                    {(0, 79.73) (1, 87.87) (2, 92.21) (3, 96.31) (4, 98.18) (5, 99.68) (6, 99.85) (7, 99.86)};
                \addplot[fix, x2] coordinates
                    {(0, 81.53) (1, 89.24) (2, 92.22) (3, 96.37) (4, 98.19) (5, 99.73) (6, 99.85) (7, 99.86)};
                \addplot[fixfull, x2] coordinates
                    {(0, 80.17) (1, 88.28) (2, 92.31) (3, 96.30) (4, 98.17) (5, 99.69) (6, 99.85) (7, 99.86)};
            \end{axis}
        \end{tikzpicture}
        \caption[Miss rate of DGCLOCK-V2 variants]{Miss rate of the \nameref{subsubsec:dgclock-v2} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:dgclockv2hitrate}
    \end{figure}
\end{@empty}

    The evaluated variants of DGCLOCK-V2 and the corresponding parameter values are the same as for \nameref{subsubsec:dgclock-v1}.

    The miss rates achieved by the different DGCLOCK-V2 variants only vary for very small buffer pools. There, the variants that do not update the usage-count when a page cannot be evicted temporarily achieve lower miss rates. However, the lower miss rates of these variants do not lead to a higher transaction throughput. The differences in transaction throughput are small for larger buffer pools. For larger buffer pools, the variants of the DGCLOCK-V2 page replacement algorithm that end in \emph{x2} show slightly worse transaction throughput than the other variants. The \emph{FixFull} variant performs best for all these buffer pool sizes.

    The higher overhead of the \emph{x2} variants results in lower transaction throughput for any buffer pool size. The slightly higher transaction throughput of the \emph{FixFull} variants indicates that pages selected for eviction by the DGCLOCK-V2 page replacement algorithm that cannot be evicted temporarily are hot, but the higher miss rate of these variants for small buffer pools indicates that most other pages in such a small buffer pool are hotter for the tested workload.

    The \emph{FixFull} variant is used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}.

\subsection[LRD]{Least Reference Density (LRD)} \label{subsec:lrd}

\paragraph{Introduction}

    The LRD page replacement policy evicts pages based on the so-called \emph{reference density}---i.e. the \emph{number of references to a page per total number of references} to all pages in the buffer pool since that page was fetched. This policy, like \nameref{subsec:gclock} and \nameref{subsec:dgclock}, has been---proposed by Effelsberg and Härder in \cite{Effelsberg:1984}.

\paragraph{Page Reference Statistics}

    The page reference statistics used by the LRD page replacement policy consist of a \emph{global reference counter} and, for each buffered page, a \emph{reference counter}, the value of the global reference counter at the \emph{time of the first reference}, and---to allow concurrent eviction of pages by multiple working threads---a flag indicating whether another thread has \emph{already selected} the buffer frame for eviction.

    Exemplary page reference statistics for a buffer pool with sixteen buffer frames are shown in figure \ref{fig:lrd}. It shows for each buffer frame the reference counter (e.g., 120 for buffer frame 0), the value of the global reference counter when the contained page was fetched (e.g., 2450 for buffer frame 5), and the flag indicating whether a working thread has already selected that frame as a candidate for eviction (true only for buffer frame 13). The current reference density of each buffer frame is calculated in the rightmost column. A working thread that is currently evicting pages has obviously already found the page with the \emph{lowest reference density}---it is contained in buffer frame 13.

\begin{@empty}
    \begin{figure}[h]
        \centering
        \begin{tabular}{r|r|r|c|c}
            \multicolumn{1}{r}{} & \multicolumn{1}{c}{\small \makecell[c]{\textbf{Reference}\\ \textbf{count}}}
                                 & \multicolumn{1}{c}{\small \makecell[c]{\textbf{First}\\ \textbf{reference}}}
                                 & \multicolumn{1}{c}{\small \makecell[c]{\textbf{Already}\\ \textbf{selected}}}
                                 & \multicolumn{1}{c}{\makecell[c]{\textbf{\small Global ref. count}\\ \fbox{2500}}}
                                                                                            \\ \cline{2-4}
             0 & 120  &    0 & false & $\frac{125}{2500 - 0} = 0.05$                        \\ \cline{2-4}
             1 &   4  & 1500 & false & $\frac{4}{2500 - 1500} = 0.004$                      \\ \cline{2-4}
             2 &   7  &  600 & false & $\frac{7}{2500 - 600} \approx 0.0037$                \\ \cline{2-4}
             3 &   2  & 2100 & false & $\frac{2}{2500 - 2100} = 0.005$                      \\ \cline{2-4}
             4 &   8  &  400 & false & $\frac{8}{2500 - 400} \approx 0.0038$                \\ \cline{2-4}
             5 &   1  & 2450 & false & $\frac{1}{2500 - 2450} = 0.02$                       \\ \cline{2-4}
             6 &   3  & 1800 & false & $\frac{3}{2500 - 1800} \approx 0.0043$               \\ \cline{2-4}
             7 &   5  & 1150 & false & $\frac{5}{2500 - 1150} \approx 0.0037$               \\ \cline{2-4}
             8 &   1  & 2425 & false & $\frac{1}{2500 - 2425} \approx 0.0133$               \\ \cline{2-4}
             9 &   1  & 2400 & false & $\frac{1}{2500 - 2400} = 0.01$                       \\ \cline{2-4}
            10 &   2  & 2200 & false & $\frac{2}{2500 - 2200} \approx 0.0067$               \\ \cline{2-4}
            11 &   5  & 1100 & false & $\frac{5}{2500 - 1100} \approx 0.0036$               \\ \cline{2-4}
            12 &   6  & 1000 & false & $\frac{6}{2500 - 1000} = 0.004$                      \\ \cline{2-4}
            13 &   4  & 1200 &  true & $\frac{4}{2500 - 1200} \approx 0.0031$               \\ \cline{2-4}
            14 &   8  &  400 & false & $\frac{8}{2500 - 400} \approx 0.0038$                \\ \cline{2-4}
            15 &   9  &  200 & false & $\frac{9}{2500 - 200} \approx 0.0039$                \\ \cline{2-4}
        \end{tabular}
        \vspace{.75em}
        \caption[Page reference statistics of LRD]{The page reference statistics of the LRD-V1 and LRD-V2 page replacement algorithms}
        \label{fig:lrd}
    \end{figure}
\end{@empty}

\paragraph{Page Eviction}

    The algorithm used by the LRD page replacement policies to select an eviction candidate is shown in Algorithm \ref{alg:lrdselect}. The computational complexity of this algorithm \emph{growns linearly with the number of buffer frames}, making it a performance bottleneck in almost every modern OLTP application.

    The algorithm \emph{searches linearly} in the buffer pool for the page with the least reference density. {\scriptsize minIndex} is the index of the buffer frame with the least reference density among those already compared. The reference density of the page in the buffer frame {\scriptsize minIndex} is stored in {\scriptsize minReferenceDensity} (must be $\infty$ at the beginning) and to be able to verify at the end that the page in the buffer frame {\scriptsize minIndex} was not \emph{referenced again during the search}, the value of the reference counter used for calculating the {\scriptsize minReferenceDensity} is stored in {\scriptsize minReferences}.

\begin{@empty}
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{select}{}
                \State $\text{minIndex} \gets -1$
                \State $\text{minReferences} \gets 0$
                \State $\text{minReferenceDensity} \gets \infty$
                \While{$\text{true}$}
                    \For{$i \gets 0$ to $\text{maxBufferIndex}$}
                        \If{$\left(\frac{\text{referenceCount}\left[i\right]}{\text{globalReferenceCount} - \text{firstReference}\left[i\right]}\right) < \text{minReferenceDensity}$}
                            \If{NOT $\text{alreadySelected}\left[i\right].$\Call{$\text{test\_and\_set}$}{}}
                                \State $\text{alreadySelected}\left[\text{minIndex}\right].$\Call{$\text{clear}$}{}
                                \State $\text{minIndex} \gets i$
                                \State $\text{minReferences} \gets \text{referenceCount}\left[i\right]$
                                \State $\text{minReferenceDensity} \gets \frac{\text{referenceCount}\left[i\right]}{\text{globalReferenceCount} - \text{firstReference}\left[i\right]}$
                            \EndIf
                        \EndIf
                    \EndFor
                    \If{$\text{minReferences} \neq \text{referenceCount}\left[\text{minIndex}\right]$}
                        \State $\text{alreadySelected}\left[\text{minIndex}\right].$\Call{$\text{clear}$}{}
                        \State $\text{minReferenceDensity} \gets \infty$
                        \State $\textbf{continue}$
                    \Else
                        \State \Return $\text{minIndex}$
                    \EndIf
                \EndWhile
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{select}} of LRD]{Selection of eviction candidates by the LRD-V1 and LRD-V2 page replacement strategies}
        \label{alg:lrdselect}
    \end{algorithm}
\end{@empty}

    A working thread searching for a page with the least reference density will always \emph{flag} the buffer frame {\scriptsize minIndex} as already selected to ensure that multiple working threads concurrently searching for an eviction candidate will find \emph{unique pages}. The flag is also used to exclude \emph{unused buffer frames}---e.g. explicitly evicted ones---from this process. If the found page \emph{temporarily cannot be evicted}, the flag is removed again, and to prevent \emph{an infinite loop} in which this page would be selected over and over again, its reference counter is incremented (but not the global reference counter). The reference counter corresponding to a page that \emph{cannot be evicted permanently} is set to the current value of the global reference counter to delay the next selection for eviction. If the maximum value of the used integer data type was used, the next reference to this page would cause an overflow of the reference counter.

\subsubsection{LRD-V1} \label{subsubsec:lrd-v1}

\paragraph{Introduction}

    The LRD-V1 page replacement strategy is more basic than the \nameref{subsubsec:lrd-v2} page replacement strategy, which works with aging of the reference statistics. In this version of the \nameref{subsec:lrd} page replacement strategy, each reference to a page since the last time the page was fetched into the buffer pool is valued equally.

\paragraph{Updates of Page Reference Statistics}

    When a page is \emph{fetched} into the buffer pool, its corresponding \textit{first reference} value is set to the current value of the \textit{global reference count}, the value of the \textit{global reference count} is incremented, and the \textit{reference count} of the page is set to $1$. The corresponding buffer frame is marked as not already selected.

    In the event of a \emph{page hit}, both the corresponding \textit{reference count} and the \textit{global reference count} will be incremented. The page is marked as not already selected for eviction.

    If a page selected for eviction is \emph{temporarily impossible to evict}, its \textit{reference count} is incremented so that it is not selected over and over again. It is marked as not already selected for eviction.

    If a page selected for eviction \emph{cannot be evicted permanently}, its \textit{reference count} is set to the current value of the \textit{global reference count} to prevent further selection for eviction.

\subsubsection{LRD-V2} \label{subsubsec:lrd-v2}

\paragraph{Introduction}

    The LRD-V2 page replacement strategy adds \emph{aging of the reference statistics} to the \nameref{subsubsec:lrd-v1} page replacement strategy. In this way, pages that are referenced very frequently for a limited period of time are evicted more quickly once they are not referenced again. In this way, the \emph{reference frequency} becomes less important than the \emph{reference recency}.

\paragraph{Updates of Page Reference Statistics}

    LRD-V2 applies the \emph{same page reference statistics} updates as LRD-V1, but after every $f^{\text{th}}$ global reference an \emph{aging function} is applied to the \textit{reference count}s of all buffer frames. Simple aging function are e.g. subtraction of a fixed value $x$ ($\text{referenceCount} = \max\left(0, \text{referenceCount} - x\right)$) or multiplication by a fixed factor $x < 1$ \linebreak ($\text{referenceCount} = \text{referenceCount} \cdot x$).

\paragraph{Performance Evaluation}

    Figure \ref{fig:lrdv2throughput} shows transaction throughput and figure \ref{fig:lrdv2hitrate} shows the miss rate achieved with different variants of the LRD-V2 page replacement algorithm for different buffer pool sizes. Details of the benchmark setup can be found in section \ref{sec:page_evictioners_performance_evaluation}.

\begin{@empty}
    \pgfplotsset{%
        every axis/.append style = {
            ylabel near ticks,
            y label style = {font = \small},
            yticklabel style = {font = \scriptsize},
            ymode = normal,
            scaled y ticks = false,
            ybar = .4pt,
            bar width = .2em,
            xtick style = {draw = none},
            xtick = {0, 1, 2, 3, 4, 5, 6, 7},
            xticklabels = {{\SI{100}{\mega\byte}}, {\SI{500}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2.5}{\giga\byte}}, {\SI{5}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{30}{\giga\byte}}},
            x tick label style = {align = center, font = \footnotesize},
            xlabel near ticks,
            x label style = {font = \small},
            ymajorgrids = true,
            width = \textwidth,
            height = .3\textheight
        }
    }
    
    \tikzset{%
        aging1/.style = {thin},
        aging2/.style = {thin},
        aging5/.style = {thin},
        aging10/.style = {thin},
        factor10/.style = {thin},
        factor25/.style = {thin},
        factor50/.style = {thin},
        factor75/.style = {thin},
        subtractor1/.style = {thin},
        subtractor2/.style = {thin},
        subtractor5/.style = {thin},
        subtractor10/.style = {thin}
    }
    
    \nottoggle{bwmode}{
        \tikzset{%
            aging1/.append style = {solid},
            aging2/.append style = {densely dotted},
            aging5/.append style = {dotted},
            aging10/.append style = {loosely dotted},
            factor10/.append style = {draw = Cyan, fill = Cyan!10},
            factor25/.append style = {draw = Cyan, fill = Cyan!25},
            factor50/.append style = {draw = Cyan, fill = Cyan!50},
            factor75/.append style = {draw = Cyan, fill = Cyan!75},
            subtractor1/.append style = {draw = Magenta, fill = Magenta!10},
            subtractor2/.append style = {draw = Magenta, fill = Magenta!25},
            subtractor5/.append style = {draw = Magenta, fill = Magenta!50},
            subtractor10/.append style = {draw = Magenta, fill = Magenta!75}
        }
    }{
        \tikzset{%
            aging1/.append style = {solid},
            aging2/.append style = {densely dotted},
            aging5/.append style = {dotted},
            aging10/.append style = {loosely dotted},
            factor10/.append style = {draw = black, pattern = {Lines[angle = 0, distance = {1pt}]}},
            factor25/.append style = {draw = black, pattern = {Lines[angle = 0, distance = {2pt}]}},
            factor50/.append style = {draw = black, pattern = {Lines[angle = 0, distance = {3pt}]}},
            factor75/.append style = {draw = black, pattern = {Lines[angle = 0, distance = {4pt}]}},
            subtractor1/.append style = {draw = black, pattern = {Lines[angle = 45, distance = {1pt}]}},
            subtractor2/.append style = {draw = black, pattern = {Lines[angle = 45, distance = {2pt}]}},
            subtractor5/.append style = {draw = black, pattern = {Lines[angle = 45, distance = {3pt}]}},
            subtractor10/.append style = {draw = black, pattern = {Lines[angle = 45, distance = {4pt}]}}
        }
    }
    
    \begin{figure}[h!]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
                         xmin = -0.5,
                         xmax = 3.5]
                \addplot[aging1, factor10] coordinates
                        {(0, 21406.28) (1, 12650.43) (2, 11952.45) (3, 13316.72) (4, 21335.30) (5, 107604.30) (6, 560356.44) (7, 881206.84)};
                \addplot[aging1, factor25] coordinates
                        {(0, 21229.56) (1, 13326.91) (2, 12221.95) (3, 13649.17) (4, 21819.81) (5, 108729.86) (6, 561166.91) (7, 885438.97)};
                \addplot[aging1, factor50] coordinates
                        {(0, 21185.92) (1, 13601.06) (2, 12296.55) (3, 13787.22) (4, 22244.46) (5, 109129.91) (6, 561073.82) (7, 885928.79)};
                \addplot[aging1, factor75] coordinates
                        {(0, 21406.10) (1, 13600.25) (2, 12264.08) (3, 13687.78) (4, 22212.46) (5, 102558.02) (6, 556181.11) (7, 870721.84)};
                \addplot[aging2, factor10] coordinates
                        {(0, 24572.00) (1, 12830.88) (2, 11955.41) (3, 14865.22) (4, 23863.07) (5, 110799.80) (6, 553862.83) (7, 881440.46)};
                \addplot[aging2, factor25] coordinates
                        {(0, 24879.11) (1, 12632.71) (2, 12230.80) (3, 14606.87) (4, 23560.41) (5, 108607.90) (6, 563009.63) (7, 877781.04)};
                \addplot[aging2, factor50] coordinates
                        {(0, 27463.08) (1, 13488.06) (2, 11876.03) (3, 14737.48) (4, 23234.38) (5, 104864.03) (6, 564491.24) (7, 884524.59)};
                \addplot[aging2, factor75] coordinates
                        {(0, 26750.60) (1, 14230.10) (2, 11339.76) (3, 14391.62) (4, 22197.42) (5, 98365.75) (6, 565206.94) (7, 871683.63)};
                \addplot[aging5, factor10] coordinates
                        {(0, 24696.72) (1, 20672.13) (2, 13931.04) (3, 16492.65) (4, 24195.56) (5, 104128.34) (6, 565566.58) (7, 875879.67)};
                \addplot[aging5, factor25] coordinates
                        {(0, 24382.79) (1, 21142.77) (2, 13901.25) (3, 16197.79) (4, 23286.67) (5, 101415.07) (6, 566554.44) (7, 854237.82)};
                \addplot[aging5, factor50] coordinates
                        {(0, 22172.58) (1, 22288.41) (2, 16183.10) (3, 15071.92) (4, 22709.92) (5, 101311.56) (6, 568668.60) (7, 885584.98)};
                \addplot[aging5, factor75] coordinates
                        {(0, 19933.19) (1, 21803.43) (2, 16054.33) (3, 14855.02) (4, 21838.90) (5, 101383.15) (6, 567983.31) (7, 879927.67)};
                \addplot[aging10, factor10] coordinates
                        {(0, 21173.57) (1, 16567.32) (2, 16107.05) (3, 16328.90) (4, 23275.65) (5, 101983.20) (6, 568949.10) (7, 873542.37)};
                \addplot[aging10, factor25] coordinates
                        {(0, 21156.93) (1, 17045.94) (2, 14692.11) (3, 15843.30) (4, 23641.94) (5, 104729.69) (6, 570153.19) (7, 886153.35)};
                \addplot[aging10, factor50] coordinates
                        {(0, 20030.21) (1, 15300.29) (2, 14298.09) (3, 17998.28) (4, 22874.09) (5, 104934.56) (6, 568896.82) (7, 883188.29)};
                \addplot[aging10, factor75] coordinates
                        {(0, 18804.73) (1, 14373.60) (2, 11860.91) (3, 16238.28) (4, 23661.79) (5, 104948.84) (6, 565246.06) (7, 875551.76)};
                \addplot[aging1, subtractor1] coordinates
                        {(0, 22205.54) (1, 13689.20) (2, 11647.54) (3, 13185.03) (4, 21379.10) (5, 97095.02) (6, 561065.43) (7, 880034.75)};
                \addplot[aging2, subtractor1] coordinates
                        {(0, 25875.37) (1, 15068.35) (2, 11055.92) (3, 13782.20) (4, 21574.34) (5, 94173.80) (6, 564336.97) (7, 884591.21)};
                \addplot[aging2, subtractor2] coordinates
                        {(0, 25580.63) (1, 13411.26) (2, 11569.42) (3, 14101.23) (4, 22484.10) (5, 95574.59) (6, 563649.76) (7, 881626.44)};
                \addplot[aging5, subtractor1] coordinates
                        {(0, 19443.53) (1, 19042.59) (2, 16121.09) (3, 15401.18) (4, 21869.28) (5, 100206.75) (6, 564463.74) (7, 883677.31)};
                \addplot[aging5, subtractor2] coordinates
                        {(0, 21102.07) (1, 19626.83) (2, 15214.51) (3, 15101.12) (4, 21829.08) (5, 97110.92) (6, 566692.17) (7, 883334.89)};
                \addplot[aging5, subtractor5] coordinates
                        {(0, 24105.29) (1, 21103.78) (2, 14121.79) (3, 15354.45) (4, 22721.14) (5, 96840.11) (6, 564948.52) (7, 872378.13)};
                \addplot[aging10, subtractor1] coordinates
                        {(0, 18399.98) (1, 14784.47) (2, 11864.11) (3, 18062.91) (4, 24726.77) (5, 102036.64) (6, 560973.13) (7, 872965.49)};
                \addplot[aging10, subtractor2] coordinates
                        {(0, 19053.14) (1, 15259.32) (2, 12963.87) (3, 14831.29) (4, 21873.20) (5, 101063.13) (6, 566213.23) (7, 886027.09)};
                \addplot[aging10, subtractor5] coordinates
                        {(0, 20043.86) (1, 16215.95) (2, 14761.69) (3, 15769.38) (4, 22440.64) (5, 97994.19) (6, 569786.60) (7, 876719.18)};
                \addplot[aging10, subtractor10] coordinates
                        {(0, 20975.98) (1, 16271.13) (2, 15646.43) (3, 16410.83) (4, 22705.13) (5, 98975.93) (6, 567759.95) (7, 890394.41)};
            \end{axis}
        \end{tikzpicture} \\
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
                         xmin = 3.5,
                         xmax = 7.5,
                         xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
                         legend entries = {$1 \cdot 0.1$, $1 \cdot 0.25$, $1 \cdot 0.5$, $1 \cdot 0.75$, $2 \cdot 0.1$, $2 \cdot 0.25$, $2 \cdot 0.5$, $2 \cdot 0.75$, $5 \cdot 0.1$, $5 \cdot 0.25$, $5 \cdot 0.5$, $5 \cdot 0.75$, $10 \cdot 0.1$, $10 \cdot 0.25$, $10 \cdot 0.5$, $10 \cdot 0.75$, $1 - 1$, $2 - 1$, $2 - 2$, $5 - 1$, $5 - 2$, $5 - 5$, $10 - 1$, $10 - 2$, $10 - 5$, $10 - 10$},
                         legend style = {font = \scriptsize,
                                         legend columns = 7,
                                         /tikz/every even column/.append style = {column sep = 0.0625cm},
                                         at = {(0.5, -0.35)},
                                         anchor = north}]
                \addplot[aging1, factor10] coordinates
                    {(0, 21406.28) (1, 12650.43) (2, 11952.45) (3, 13316.72) (4, 21335.30) (5, 107604.30) (6, 560356.44) (7, 881206.84)};
                \addplot[aging1, factor25] coordinates
                    {(0, 21229.56) (1, 13326.91) (2, 12221.95) (3, 13649.17) (4, 21819.81) (5, 108729.86) (6, 561166.91) (7, 885438.97)};
                \addplot[aging1, factor50] coordinates
                    {(0, 21185.92) (1, 13601.06) (2, 12296.55) (3, 13787.22) (4, 22244.46) (5, 109129.91) (6, 561073.82) (7, 885928.79)};
                \addplot[aging1, factor75] coordinates
                    {(0, 21406.10) (1, 13600.25) (2, 12264.08) (3, 13687.78) (4, 22212.46) (5, 102558.02) (6, 556181.11) (7, 870721.84)};
                \addplot[aging2, factor10] coordinates
                    {(0, 24572.00) (1, 12830.88) (2, 11955.41) (3, 14865.22) (4, 23863.07) (5, 110799.80) (6, 553862.83) (7, 881440.46)};
                \addplot[aging2, factor25] coordinates
                    {(0, 24879.11) (1, 12632.71) (2, 12230.80) (3, 14606.87) (4, 23560.41) (5, 108607.90) (6, 563009.63) (7, 877781.04)};
                \addplot[aging2, factor50] coordinates
                    {(0, 27463.08) (1, 13488.06) (2, 11876.03) (3, 14737.48) (4, 23234.38) (5, 104864.03) (6, 564491.24) (7, 884524.59)};
                \addplot[aging2, factor75] coordinates
                    {(0, 26750.60) (1, 14230.10) (2, 11339.76) (3, 14391.62) (4, 22197.42) (5, 98365.75) (6, 565206.94) (7, 871683.63)};
                \addplot[aging5, factor10] coordinates
                    {(0, 24696.72) (1, 20672.13) (2, 13931.04) (3, 16492.65) (4, 24195.56) (5, 104128.34) (6, 565566.58) (7, 875879.67)};
                \addplot[aging5, factor25] coordinates
                    {(0, 24382.79) (1, 21142.77) (2, 13901.25) (3, 16197.79) (4, 23286.67) (5, 101415.07) (6, 566554.44) (7, 854237.82)};
                \addplot[aging5, factor50] coordinates
                    {(0, 22172.58) (1, 22288.41) (2, 16183.10) (3, 15071.92) (4, 22709.92) (5, 101311.56) (6, 568668.60) (7, 885584.98)};
                \addplot[aging5, factor75] coordinates
                    {(0, 19933.19) (1, 21803.43) (2, 16054.33) (3, 14855.02) (4, 21838.90) (5, 101383.15) (6, 567983.31) (7, 879927.67)};
                \addplot[aging10, factor10] coordinates
                    {(0, 21173.57) (1, 16567.32) (2, 16107.05) (3, 16328.90) (4, 23275.65) (5, 101983.20) (6, 568949.10) (7, 873542.37)};
                \addplot[aging10, factor25] coordinates
                    {(0, 21156.93) (1, 17045.94) (2, 14692.11) (3, 15843.30) (4, 23641.94) (5, 104729.69) (6, 570153.19) (7, 886153.35)};
                \addplot[aging10, factor50] coordinates
                    {(0, 20030.21) (1, 15300.29) (2, 14298.09) (3, 17998.28) (4, 22874.09) (5, 104934.56) (6, 568896.82) (7, 883188.29)};
                \addplot[aging10, factor75] coordinates
                    {(0, 18804.73) (1, 14373.60) (2, 11860.91) (3, 16238.28) (4, 23661.79) (5, 104948.84) (6, 565246.06) (7, 875551.76)};
                \addplot[aging1, subtractor1] coordinates
                    {(0, 22205.54) (1, 13689.20) (2, 11647.54) (3, 13185.03) (4, 21379.10) (5, 97095.02) (6, 561065.43) (7, 880034.75)};
                \addplot[aging2, subtractor1] coordinates
                    {(0, 25875.37) (1, 15068.35) (2, 11055.92) (3, 13782.20) (4, 21574.34) (5, 94173.80) (6, 564336.97) (7, 884591.21)};
                \addplot[aging2, subtractor2] coordinates
                    {(0, 25580.63) (1, 13411.26) (2, 11569.42) (3, 14101.23) (4, 22484.10) (5, 95574.59) (6, 563649.76) (7, 881626.44)};
                \addplot[aging5, subtractor1] coordinates
                    {(0, 19443.53) (1, 19042.59) (2, 16121.09) (3, 15401.18) (4, 21869.28) (5, 100206.75) (6, 564463.74) (7, 883677.31)};
                \addplot[aging5, subtractor2] coordinates
                    {(0, 21102.07) (1, 19626.83) (2, 15214.51) (3, 15101.12) (4, 21829.08) (5, 97110.92) (6, 566692.17) (7, 883334.89)};
                \addplot[aging5, subtractor5] coordinates
                    {(0, 24105.29) (1, 21103.78) (2, 14121.79) (3, 15354.45) (4, 22721.14) (5, 96840.11) (6, 564948.52) (7, 872378.13)};
                \addplot[aging10, subtractor1] coordinates
                    {(0, 18399.98) (1, 14784.47) (2, 11864.11) (3, 18062.91) (4, 24726.77) (5, 102036.64) (6, 560973.13) (7, 872965.49)};
                \addplot[aging10, subtractor2] coordinates
                    {(0, 19053.14) (1, 15259.32) (2, 12963.87) (3, 14831.29) (4, 21873.20) (5, 101063.13) (6, 566213.23) (7, 886027.09)};
                \addplot[aging10, subtractor5] coordinates
                    {(0, 20043.86) (1, 16215.95) (2, 14761.69) (3, 15769.38) (4, 22440.64) (5, 97994.19) (6, 569786.60) (7, 876719.18)};
                \addplot[aging10, subtractor10] coordinates
                    {(0, 20975.98) (1, 16271.13) (2, 15646.43) (3, 16410.83) (4, 22705.13) (5, 98975.93) (6, 567759.95) (7, 890394.41)};
           \end{axis}
        \end{tikzpicture}
        \vspace{.5em}
        \caption[Transaction throughput of LRD-V2 variants]{Transaction throughput of the \nameref{subsubsec:lrd-v2} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:lrdv2throughput}
    \end{figure}
    
    \begin{figure}[h!]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         xmin = -0.5,
                         xmax = 3.5,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[aging1, factor10] coordinates
                    {(0, 80.00) (1, 86.88) (2, 90.01) (3, 94.22) (4, 97.40) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging1, factor25] coordinates
                    {(0, 80.25) (1, 87.37) (2, 90.34) (3, 94.30) (4, 97.44) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging1, factor50] coordinates
                    {(0, 80.97) (1, 88.40) (2, 90.87) (3, 94.57) (4, 97.56) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging1, factor75] coordinates
                    {(0, 81.33) (1, 88.82) (2, 91.02) (3, 94.63) (4, 97.57) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging2, factor10] coordinates
                    {(0, 81.31) (1, 88.23) (2, 91.48) (3, 95.12) (4, 97.67) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging2, factor25] coordinates
                    {(0, 81.66) (1, 88.75) (2, 91.61) (3, 95.17) (4, 97.69) (5, 99.47) (6, 99.83) (7, 99.86)};
                \addplot[aging2, factor50] coordinates
                    {(0, 82.53) (1, 89.31) (2, 92.02) (3, 95.52) (4, 97.73) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging2, factor75] coordinates
                    {(0, 82.56) (1, 89.52) (2, 92.11) (3, 95.59) (4, 97.73) (5, 99.43) (6, 99.83) (7, 99.86)};
                \addplot[aging5, factor10] coordinates
                    {(0, 82.23) (1, 89.32) (2, 92.26) (3, 96.06) (4, 97.76) (5, 99.45) (6, 99.83) (7, 99.86)};
                \addplot[aging5, factor25] coordinates
                    {(0, 82.26) (1, 89.48) (2, 92.32) (3, 96.10) (4, 97.77) (5, 99.44) (6, 99.83) (7, 99.86)};
                \addplot[aging5, factor50] coordinates
                    {(0, 82.14) (1, 89.59) (2, 92.34) (3, 96.26) (4, 97.81) (5, 99.44) (6, 99.83) (7, 99.86)};
                \addplot[aging5, factor75] coordinates
                    {(0, 81.86) (1, 89.67) (2, 92.32) (3, 96.29) (4, 97.82) (5, 99.45) (6, 99.83) (7, 99.86)};
                \addplot[aging10, factor10] coordinates
                    {(0, 82.13) (1, 89.33) (2, 92.27) (3, 96.23) (4, 97.81) (5, 99.44) (6, 99.83) (7, 99.86)};
                \addplot[aging10, factor25] coordinates
                    {(0, 82.01) (1, 89.47) (2, 92.29) (3, 96.23) (4, 97.86) (5, 99.44) (6, 99.83) (7, 99.86)};
                \addplot[aging10, factor50] coordinates
                    {(0, 81.90) (1, 89.49) (2, 92.30) (3, 96.32) (4, 97.92) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging10, factor75] coordinates
                    {(0, 81.53) (1, 89.54) (2, 92.25) (3, 96.31) (4, 97.95) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging1, subtractor1] coordinates
                    {(0, 81.78) (1, 89.05) (2, 91.01) (3, 94.54) (4, 97.49) (5, 99.41) (6, 99.83) (7, 99.86)};
                \addplot[aging2, subtractor1] coordinates
                    {(0, 82.83) (1, 89.40) (2, 91.94) (3, 95.50) (4, 97.69) (5, 99.42) (6, 99.83) (7, 99.86)};
                \addplot[aging2, subtractor2] coordinates
                    {(0, 82.35) (1, 89.36) (2, 91.71) (3, 95.14) (4, 97.63) (5, 99.41) (6, 99.83) (7, 99.86)};
                \addplot[aging5, subtractor1] coordinates
                    {(0, 81.64) (1, 89.42) (2, 91.91) (3, 96.25) (4, 97.85) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging5, subtractor2] coordinates
                    {(0, 81.89) (1, 89.43) (2, 91.94) (3, 96.11) (4, 97.74) (5, 99.43) (6, 99.83) (7, 99.86)};
                \addplot[aging5, subtractor5] coordinates
                    {(0, 82.47) (1, 89.53) (2, 92.10) (3, 96.00) (4, 97.70) (5, 99.42) (6, 99.83) (7, 99.86)};
                \addplot[aging10, subtractor1] coordinates
                    {(0, 81.35) (1, 89.43) (2, 92.05) (3, 96.25) (4, 97.99) (5, 99.47) (6, 99.83) (7, 99.86)};
                \addplot[aging10, subtractor2] coordinates
                    {(0, 81.67) (1, 89.42) (2, 92.02) (3, 96.22) (4, 97.87) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging10, subtractor5] coordinates
                    {(0, 81.91) (1, 89.46) (2, 92.01) (3, 96.12) (4, 97.78) (5, 99.43) (6, 99.83) (7, 99.86)};
                \addplot[aging10, subtractor10] coordinates
                    {(0, 82.17) (1, 89.48) (2, 92.10) (3, 96.14) (4, 97.77) (5, 99.43) (6, 99.83) (7, 99.86)};
            \end{axis}
        \end{tikzpicture} \\
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         xmin = 3.5,
                         xmax = 7.5,
                         xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
                         legend entries = {$1 \cdot 0.1$, $1 \cdot 0.25$, $1 \cdot 0.5$, $1 \cdot 0.75$, $2 \cdot 0.1$, $2 \cdot 0.25$, $2 \cdot 0.5$, $2 \cdot 0.75$, $5 \cdot 0.1$, $5 \cdot 0.25$, $5 \cdot 0.5$, $5 \cdot 0.75$, $10 \cdot 0.1$, $10 \cdot 0.25$, $10 \cdot 0.5$, $10 \cdot 0.75$, $1 - 1$, $2 - 1$, $2 - 2$, $5 - 1$, $5 - 2$, $5 - 5$, $10 - 1$, $10 - 2$, $10 - 5$, $10 - 10$},
                         legend style = {font = \scriptsize,
                                         legend columns = 7,
                                         /tikz/every even column/.append style = {column sep = 0.0625cm},
                                         at = {(0.5, -0.35)},
                                         anchor = north},
                         y coord trafo/.code = {
                            \pgfmathparse{100 - #1}
                            \pgfmathresult
                         }]
                \addplot[aging1, factor10] coordinates
                    {(0, 80.00) (1, 86.88) (2, 90.01) (3, 94.22) (4, 97.40) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging1, factor25] coordinates
                    {(0, 80.25) (1, 87.37) (2, 90.34) (3, 94.30) (4, 97.44) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging1, factor50] coordinates
                    {(0, 80.97) (1, 88.40) (2, 90.87) (3, 94.57) (4, 97.56) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging1, factor75] coordinates
                    {(0, 81.33) (1, 88.82) (2, 91.02) (3, 94.63) (4, 97.57) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging2, factor10] coordinates
                    {(0, 81.31) (1, 88.23) (2, 91.48) (3, 95.12) (4, 97.67) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging2, factor25] coordinates
                    {(0, 81.66) (1, 88.75) (2, 91.61) (3, 95.17) (4, 97.69) (5, 99.47) (6, 99.83) (7, 99.86)};
                \addplot[aging2, factor50] coordinates
                    {(0, 82.53) (1, 89.31) (2, 92.02) (3, 95.52) (4, 97.73) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging2, factor75] coordinates
                    {(0, 82.56) (1, 89.52) (2, 92.11) (3, 95.59) (4, 97.73) (5, 99.43) (6, 99.83) (7, 99.86)};
                \addplot[aging5, factor10] coordinates
                    {(0, 82.23) (1, 89.32) (2, 92.26) (3, 96.06) (4, 97.76) (5, 99.45) (6, 99.83) (7, 99.86)};
                \addplot[aging5, factor25] coordinates
                    {(0, 82.26) (1, 89.48) (2, 92.32) (3, 96.10) (4, 97.77) (5, 99.44) (6, 99.83) (7, 99.86)};
                \addplot[aging5, factor50] coordinates
                    {(0, 82.14) (1, 89.59) (2, 92.34) (3, 96.26) (4, 97.81) (5, 99.44) (6, 99.83) (7, 99.86)};
                \addplot[aging5, factor75] coordinates
                    {(0, 81.86) (1, 89.67) (2, 92.32) (3, 96.29) (4, 97.82) (5, 99.45) (6, 99.83) (7, 99.86)};
                \addplot[aging10, factor10] coordinates
                    {(0, 82.13) (1, 89.33) (2, 92.27) (3, 96.23) (4, 97.81) (5, 99.44) (6, 99.83) (7, 99.86)};
                \addplot[aging10, factor25] coordinates
                    {(0, 82.01) (1, 89.47) (2, 92.29) (3, 96.23) (4, 97.86) (5, 99.44) (6, 99.83) (7, 99.86)};
                \addplot[aging10, factor50] coordinates
                    {(0, 81.90) (1, 89.49) (2, 92.30) (3, 96.32) (4, 97.92) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging10, factor75] coordinates
                    {(0, 81.53) (1, 89.54) (2, 92.25) (3, 96.31) (4, 97.95) (5, 99.48) (6, 99.83) (7, 99.86)};
                \addplot[aging1, subtractor1] coordinates
                    {(0, 81.78) (1, 89.05) (2, 91.01) (3, 94.54) (4, 97.49) (5, 99.41) (6, 99.83) (7, 99.86)};
                \addplot[aging2, subtractor1] coordinates
                    {(0, 82.83) (1, 89.40) (2, 91.94) (3, 95.50) (4, 97.69) (5, 99.42) (6, 99.83) (7, 99.86)};
                \addplot[aging2, subtractor2] coordinates
                    {(0, 82.35) (1, 89.36) (2, 91.71) (3, 95.14) (4, 97.63) (5, 99.41) (6, 99.83) (7, 99.86)};
                \addplot[aging5, subtractor1] coordinates
                    {(0, 81.64) (1, 89.42) (2, 91.91) (3, 96.25) (4, 97.85) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging5, subtractor2] coordinates
                    {(0, 81.89) (1, 89.43) (2, 91.94) (3, 96.11) (4, 97.74) (5, 99.43) (6, 99.83) (7, 99.86)};
                \addplot[aging5, subtractor5] coordinates
                    {(0, 82.47) (1, 89.53) (2, 92.10) (3, 96.00) (4, 97.70) (5, 99.42) (6, 99.83) (7, 99.86)};
                \addplot[aging10, subtractor1] coordinates
                    {(0, 81.35) (1, 89.43) (2, 92.05) (3, 96.25) (4, 97.99) (5, 99.47) (6, 99.83) (7, 99.86)};
                \addplot[aging10, subtractor2] coordinates
                    {(0, 81.67) (1, 89.42) (2, 92.02) (3, 96.22) (4, 97.87) (5, 99.46) (6, 99.83) (7, 99.86)};
                \addplot[aging10, subtractor5] coordinates
                    {(0, 81.91) (1, 89.46) (2, 92.01) (3, 96.12) (4, 97.78) (5, 99.43) (6, 99.83) (7, 99.86)};
                \addplot[aging10, subtractor10] coordinates
                    {(0, 82.17) (1, 89.48) (2, 92.10) (3, 96.14) (4, 97.77) (5, 99.43) (6, 99.83) (7, 99.86)};
            \end{axis}
        \end{tikzpicture}
        \vspace{.5em}
        \caption[Miss rate of LRD-V2 variants]{Miss rate of the \nameref{subsubsec:lrd-v2} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:lrdv2hitrate}
    \end{figure}
\end{@empty}

    The variants of the LRD-V2 page replacement policy are named according to the scheme $f \circ x$ with the \emph{aging period} $f$, the \emph{aging function} $\circ$ and the \emph{aging operand} $x$. For a buffer pool with $b$ buffer frames, a aging period of $f$ means that the specified aging function with the given aging operand is applied to each \textit{reference count} after $b \cdot f$ global page references. For example, the $2 \cdot 0.75$ variant multiplies after every $2 \cdot b$ page references each \textit{reference count} by $0.75$. The variant $2 - 10$ subtracts $10$ from each \textit{reference count} (minimum value $0$) with the same period.

    The \emph{most striking result} of the performance evaluation of LRD-V2 is that as long as around \SI{<10}{\percent} of the initial DB fits in the buffer pool, the transaction throughput for all variants of the replacement policy shrinks as the buffer pool size increases. Despite the significant growth in page hit rate, some variants such as $2 \cdot 0.5$ perform better on a small \SI{100}{\mega\byte} buffer pool than on a large \SI{5}{\giga\byte} one, which is very surprising. In contrast, transaction throughput increases again with buffer pool size for larger buffer pools, which is in accordance with intuition.

    The \emph{optimal aging frequency} with respect to transaction throughput \emph{decreases with an increasing size of the buffer pool}. For a buffer pool size of \SI{100}{\mega\byte}, the variants with an aging period of $f = 2$ perform best, but for one with \SI{2.5}{\giga\byte}, the variants with an aging period of $f = 10$ are better. This behavior is not only the result of greater overhead from the aging process with larger buffer pools, but is also supported by the hit rates. For each buffer size, the faster LRD-V2 variants are also those with a lower page miss rate, while those with a high miss rate always perform poorer.

    For \emph{growing aging periods}, decreasing factors for multiplicative aging and increasing subtrahents for subtractive aging are required to achieve the best transaction throughput. It keeps the influence of aging stable, the \textit{reference count} values need to \emph{age more strongly} with \emph{less frequent aging}.

    For \emph{larger buffer pools} (\SI{\geq 5}{\giga\byte}), the \emph{miss rates} and \emph{transaction throughput} of the different variants of the LRD-V2 page replacement policy are almost identical. The differences are statistically insignificant.

    Due to its decent performance for all buffer pool sizes the $10 - 10$ variant is used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}.

\subsection[LFU]{Least Frequently Used (LFU)} \label{subsec:lfu}

\paragraph{Introduction}

    The LFU page replacement policy is one of the \emph{oldest} approaches to page replacement. It \emph{considers only the reference frequency} when deciding on an eviction candidate. The idea behind this criterion is that hot pages are referenced very frequently.

    However, one problem with this page replacement policy is that pages that were referenced very frequently remain in the buffer pool forever, even if they left the working set a long time ago (violation of the \emph{five-minute rule}). And because the least frequently referenced page is very often also the \emph{least recently fetched page}, the LFU page replacement policy has the same problem as the \nameref{subsec:filo} page replacement policy---the page selected for eviction is often still fixed and therefore temporarily impossible to evict.
    
\paragraph{Page Reference Statistics}

    The page reference statistics maintained by the LFU page replacement policy consists of one \emph{reference count} per buffer frame. And to allow concurrent eviction of pages by multiple working threads, there is also flag for each buffer frame indicating whether another thread has \emph{already selected} the contained page for eviction.

\paragraph{Updates of Page Reference Statistics}

    When a page is \emph{fetched} into the buffer pool, the corresponding reference count is set to $1$ and the corresponding buffer frame is marked as not already selected. Whenever this page is \emph{referenced again}, the reference count is incremented by $1$.

    If a page selected for eviction is \emph{temporarily impossible to evict}, its \textit{reference count} is incremented so that it is not selected over and over again. It is marked as not already selected for eviction.

    If a page selected for eviction \emph{cannot be evicted permanently}, its \textit{reference count} is set to half the maximum value of the data type used, both to prevent further selection for eviction and to ensure that there is no overflow to $0$ the next time the page is referenced.

\paragraph{Page Eviction}

    The algorithm used by the LFU page replacement policy to select an eviction candidate is shown in Algorithm \ref{alg:lfuselect}. It is similar to the one used by the \nameref{subsec:lrd} page replacement policies, and therefore its computational complexity \emph{grows linearly with the number of buffer frames}.

    The algorithm \emph{searches linearly} in the buffer pool for the page with the least reference frequency. {\scriptsize minIndex} is the index of the buffer frame with the least reference frequency among those already examined. The reference frequency of the page in the buffer frame {\scriptsize minIndex} is stored in {\scriptsize minReferences} (must be $\infty$ at the beginning). By comparing {\scriptsize minReferences} with the current reference count of the buffer frame {\scriptsize minIndex}, it is verified at the end that the page in the buffer frame {\scriptsize minIndex} was not \emph{referenced again during the search}.

\begin{@empty}
    \begin{algorithm}[h]
        \scriptsize
        \begin{algorithmic}[1]
            \Function{select}{}
                \State $\text{minIndex} \gets -1$
                \State $\text{minReferences} \gets \infty$
                \While{$\text{true}$}
                    \For{$i \gets 0$ to $\text{maxBufferIndex}$}
                        \If{$\text{referenceCount}\left[i\right] < \text{minReferences}$}
                            \If{NOT $\text{alreadySelected}\left[i\right].$\Call{$\text{test\_and\_set}$}{}}
                                \State $\text{alreadySelected}\left[\text{minIndex}\right].$\Call{$\text{clear}$}{}
                                \State $\text{minIndex} \gets i$
                                \State $\text{minReferences} \gets \text{referenceCount}\left[i\right]$
                            \EndIf
                        \EndIf
                    \EndFor
                    \If{$\text{minReferences} \neq \text{referenceCount}\left[\text{minIndex}\right]$}
                        \State $\text{alreadySelected}\left[\text{minIndex}\right].$\Call{$\text{clear}$}{}
                        \State $\text{minReferences} \gets \infty$
                        \State $\textbf{continue}$
                    \Else
                        \State \Return $\text{minIndex}$
                    \EndIf
                \EndWhile
            \EndFunction
        \end{algorithmic}
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{select}} of LFU]{Selection of eviction candidates by the LFU page replacement strategy}
        \label{alg:lfuselect}
    \end{algorithm}
\end{@empty}

    A working thread searching for a page with the least reference frequency will always \emph{flag} the buffer frame {\scriptsize minIndex} as already selected to ensure that multiple working threads concurrently searching for an eviction candidate will find \emph{unique pages}. The flag is also used to exclude \emph{unused buffer frames}---e.g. explicitly evicted ones---from this process. If the found page \emph{temporarily cannot be evicted}, the flag is removed again, and to prevent \emph{an infinite loop} in which this page would be selected over and over again, its reference counter is incremented. The reference counter corresponding to a page that \emph{cannot be evicted permanently} is set to half the maximum value of the data type used. If the maximum value of the used integer data type was used, the next reference to this page would cause an overflow (to $0$) of the reference counter.

\subsection[LFUDA]{LFU With Dynamic Aging (LFUDA)} \label{subsec:lfuda}

\paragraph{Introduction}

    The LFUDA page replacement policy is an extension of the \nameref{subsec:lfu} page replacement policy that was proposed by Arlitt et al. in \cite{Arlitt:2000-2}. It tries to \emph{solve the main problem of the \nameref{subsec:lfu}} page replacement policy---the pollution of the buffer pool with pages that were referenced very frequently, possibly a long time ago. The LFUDA page replacement policy does this by setting the initial reference count of a page just fetched to a \emph{dynamically growing inflation factor} instead of $1$---thus the reference count of pages just fetched can exceed the value of older pages that were very frequently fetched.

\paragraph{Page Reference Statistics}

    In addition to the page reference statistics maintained by the \nameref{subsec:lfu} page replacement algorithm (reference counts and ``already selected'' flags per buffer frame), the LFUDA page replacement algorithm also manages the \emph{inflation factor}, which is updated each time a page is selected for eviction.

\paragraph{Updates of Page Reference Statistics}

    When a page is \emph{fetched} into the buffer pool, the corresponding reference count is set to the \emph{current value of the inflation factor} and the corresponding buffer frame is marked as not already selected. In all other situations, the LFUDA page replacement algorithm updates its page reference statistics in the same way as the \nameref{subsec:lfu} page replacement algorithm.

\paragraph{Page Eviction}

    The LFUDA page replacement algorithm selects eviction candidates in the same manner as the \nameref{subsec:lfu} page replacement algorithm (Algorithm \ref{alg:lfuselect}), but before returning the buffer index of the eviction candidate, it \emph{sets the inflation factor to the reference count of the eviction candidate}.

%\subsection[2Q]{Two Queue (2Q)} \label{subsec:2q}

    % Not yet implemented

%\subsection[MQ]{Multi Queue (MQ)} \label{subsec:mq}

    % Not yet implemented

%\subsection[ARC]{Adaptive Replacement Cache (ARC)} \label{subsec:arc}

    % Not yet implemented

%\subsection[CAR]{Clock With Adaptive Replacement (CAR)} \label{subsec:car}

    % Not yet implemented

%\subsubsection[CART]{CAR With Temporal Filtering (CART)} \label{subsubsec:cart}

    % Not yet implemented

%\subsection[LIRS]{Low Inter-Reference Recency Set (LIRS)} \label{subsec:lirs}

    % Not yet implemented

%\subsection{CLOCK-Pro} \label{subsec:clock-pro}

    % Not yet implemented

\subsection[LeanStore]{LeanStore Replacement} \label{subsec:leanstore}

\paragraph{Introduction}

    The LeanStore page replacement algorithm was proposed by Leis et al. in \cite{Leis:2018}. It is based on pointer swizzling in the buffer pool proposed by Graefe et al. in \cite{Graefe:2014} and selects eviction candidates based on randomly unswizzled pages that have not been recently used. With this technique it approximates the behavior of the \nameref{subsec:zclock} page replacement algorithm. In most cases, there is no need to update the page reference statistics on page hits.

\paragraph{Page Reference Statistics}

    The LeanStore page replacement algorithm \emph{does not keep page reference statistics in the usual sense for each page}. Instead, it uses a FIFO queue---the \emph{cooling stage}---which contains a fraction of the buffer indexes that refer to pages that have not been recently referenced. To allow multiple working threads to enqueue and dequeue buffer frame indexes concurrently, a latch (mutex) must be acquired before each operation on the cooling stage. It also uses the information---stored in the pointer to a page contained in the parent page (within the B tree) of that page---\emph{whether that page is swizzled} (for a detailed description of the pointer swizzling technique, see subsection \ref{subsec:looking_glass_swizzling}). The buffer frame containing a page that is not swizzled is included in the cooling stage.

    As an additional optimization, it flags pages that cannot be evicted permanently as ``not evictable''.

\paragraph{Updates of Page Reference Statistics}

    When a page is \emph{fetched} into the buffer pool, the corresponding pointer within the parent page will usually be swizzled. Accordingly, the corresponding buffer frame index is not added to the cooling stage.

    But \emph{at a random point in time}, this pointer (if the page is not marked as ``not evictable'') gets unswizzled during the page eviction of other pages, and therefore enters the cooling stage. If that page is then \emph{re-referenced} (\emph{page hit}) after the unswizzling, it is removed from the cooling stage and its pointer within the parent page is again swizzled. In other cases, no update of the page reference statistics is required when a \emph{page hit} occurs.

    If a page selected for eviction \emph{cannot be evicted permanently}, it is flagged ``not evictable''.

\paragraph{Page Eviction}

    The algorithm used by the LeanStore page replacement algorithm to fill the cooling stage and select an eviction candidate is provided in Algorithm \ref{alg:leanstore}.

\begin{@empty}
    \begin{algorithm}[ht!]
        \scriptsize
        \resizebox*{!}{\dimexpr\textheight-5\baselineskip\relax}{%
            \begin{minipage}{\linewidth}%
                \begin{algorithmic}[1]
                    \Function{select}{}
                        \While{\text{true}}
                            \If{$\left|\text{coolingStage}\right| < \sfrac{\text{maxCoolingStageSize}}{2}$}
                                \While{$\left|\text{coolingStage}\right| < \text{maxCoolingStageSize}$}
                                    \State $\text{coolingCandidate} \gets r \text{ randomly } \in \left\{x \in \mathbb{N}\|0    \leq x \leq \text{maxBufferIndex}\right\}$
                                    \State $\text{coolingStageLatch}.$\Call{$\text{acquire}$}{}
                                    \If{$\left|\text{coolingStage}\right| \geq \text{maxCoolingStageSize}$}
                                        \State $\text{coolingStageLatch}.$\Call{$\text{release}$}{}
                                        \State $\textbf{continue}$
                                    \EndIf
                                    \If{$\text{coolingCandidate} \in \text{coolingStage} \vee \text{notEvictable}\left[\text{coolingCandidate}\right]$}
                                        \State $\text{coolingStageLatch}.$\Call{$\text{release}$}{}
                                        \State $\textbf{continue}$
                                    \Else
                                        \State $\text{coolingStageLatch}.$\Call{$\text{release}$}{}
                                        \If{$\neg$\Call{$\text{isSwizzled}$}{$\text{coolingCandidate}$} $\vee$ \Call{$\text{isLatched}$}{$\text{coolingCandidate}$}}
                                            \State $\textbf{continue}$
                                        \EndIf
                                        \If{$\neg$\Call{$\text{acquireLatch}$}{$\text{coolingCandidate}, \text{X}$}}
                                            \State $\textbf{continue}$
                                        \EndIf
                                        \If{$\neg$\Call{$\text{isEvictable}$}{$\text{coolingCandidate}$}}
                                            \State \Call{$\text{releaseLatch}$}{$\text{coolingCandidate}$}
                                            \State $\textbf{continue}$
                                        \EndIf
                                        \State $\text{coolingCandidateParent} \gets $ \Call{$\text{getParent}$}{$\text{coolingCandidate}$}
                                        \If{$\neg$\Call{$\text{acquireLatch}$}{$\text{coolingCandidateParent}, \text{S}$}}
                                            \State \Call{$\text{releaseLatch}$}{$\text{coolingCandidate}$}
                                            \State $\textbf{continue}$
                                        \EndIf
                                        \If{\Call{$\text{unswizzle}$}{$\text{coolingCandidateParent}$}}
                                            \State $\text{coolingStageLatch}.$\Call{$\text{acquire}$}{}
                                            \State $\text{coolingStage}.$\Call{$\text{enqueue}$}{$\text{coolingCandidate}$}
                                            \State $\text{coolingStageLatch}.$\Call{$\text{release}$}{}
                                            \State \Call{$\text{releaseLatch}$}{$\text{coolingCandidateParent}$}
                                            \State \Call{$\text{releaseLatch}$}{$\text{coolingCandidate}$}
                                        \Else
                                            \State \Call{$\text{releaseLatch}$}{$\text{coolingCandidateParent}$}
                                            \State \Call{$\text{releaseLatch}$}{$\text{coolingCandidate}$}
                                            \State $\textbf{continue}$
                                        \EndIf
                                    \EndIf
                                \EndWhile
                            \EndIf
                            \State $\text{coolingStageLatch}.$\Call{$\text{acquire}$}{}
                            \State $\text{evictionCandidate} \gets \text{coolingStage}.$\Call{$\text{dequeue}$}{}
                            \State $\text{coolingStageLatch}.$\Call{$\text{release}$}{}
                            \If{$\text{evictionCandidate} \neq \text{NULL}$}
                                \State \Return $\text{evictionCandidate}$
                            \Else
                                \State $\textbf{continue}$
                            \EndIf
                        \EndWhile
                    \EndFunction
                \end{algorithmic}%
            \end{minipage}%
        }
        \vspace{1em}
        \caption[{\footnotesize \textbf{function} \textsc{select}} of LeanStore]{Selection of eviction candidates by the LeanStore page replacement algorithm}
        \label{alg:leanstore}
    \end{algorithm}
\end{@empty}

    As soon as the \emph{cooling stage is half empty}, it is refilled until it contains {\scriptsize maxCoolingStageSize} buffer frame indexes. The working threads do this before they start to reclaim buffer frames. To \emph{add a page to the cooling stage}, a random buffer frame index is picked---the cooling candidate---, an attempt is made to unswizzle the pointer to the contained page, and on success, the cooling candidate is enqueued to the cooling stage.

    More specifically, this means that once a working thread has \emph{randomly selected} a buffer frame using the SplitMix32 PRNG, it checks if this cooling candidate is already in the cooling stage or if the contained page cannot be evicted. If the buffer frame \emph{could be reclaimed} and is \emph{not already in the cooling} stage, the working thread tries to \emph{acquire the latch} of the cooling candidate in \emph{exclusive mode}. If the latch is held by another working thread, the contained page is probably not cold and should therefore not be added to the cooling stage---another cooling candidate must be picked at random. Now, in order to unswizzle the pointer in the \emph{parent page}, the corresponding buffer frame must be \emph{latched in shared mode} to ensure that the page is not changed until the pointer is unswizzled. If the latch cannot be acquired, the unswizzling cannot be performed, and therefore another cooling candidate must be picked randomly. However, if both latches---the one for the cooling candidate and the one for the parent page---have been acquired, the \emph{pointer will be unswizzled}. If successful, the buffer index of the cooling candidate is enqueued in the cooling stage queue and the latches are released. Otherwise, the latches must be released and another cooling candidate must be randomly picked.

    If the cooling stage contains enough pages, the page that has been \emph{in the cooling stage for the longest time} (FIFO) is taken out of the queue and returned as an \emph{eviction candidate}. If it \emph{cannot be evicted temporarily}, it is again enqueued to the cooling stage queue for a later retry.

\paragraph{Performance Evaluation}

    A large cooling stage---containing a larger fraction of the buffer frame indexes when full---results in a lot of unnecessary unswizzling and swizzling operations. But if the cooling stage is too small, pages are evicted very quickly after being added to the cooling stage. That way, the cooling stage cannot be used to verify that a page is not used. For this reason, the performance evaluation of the LeanStore page replacement algorithm covers cooling stage sizes from \SI{1}{\percent} of the buffer pool up to \SI{25}{\percent} thereof.

    Figure \ref{fig:leanstorethroughput} shows transaction throughput and figure \ref{fig:leanstorehitrate} shows the miss rate achieved with different variants of the LeanStore page replacement algorithm for different buffer pool sizes. Details of the benchmark setup can be found in section \ref{sec:page_evictioners_performance_evaluation}.

\begin{@empty}
    \pgfplotsset{%
        every axis/.append style = {
            xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
            ylabel near ticks,
            y label style = {font = \small},
            yticklabel style = {font = \scriptsize},
            ymode = normal,
            scaled y ticks = false,
            ybar = .8pt,
            xmin = -0.75,
            xmax = 6.75,
            bar width = .25em,
            xtick style = {draw = none},
            xtick = {0, 1, 2, 3, 4, 5, 6},
            xticklabels = {{\SI{500}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2.5}{\giga\byte}}, {\SI{5}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{30}{\giga\byte}}},
            x tick label style = {align = center, font = \footnotesize},
            xlabel near ticks,
            x label style = {font = \small},
            ymajorgrids = true,
            legend entries = {\SI{1}{\percent}, \SI{2.5}{\percent}, \SI{5}{\percent}, \SI{7.5}{\percent}, \SI{10}{\percent}, \SI{15}{\percent}, \SI{20}{\percent}, \SI{25}{\percent}},
            legend style = {font = \footnotesize,
                            legend columns = 4,
                            /tikz/every even column/.append style = {column sep = 0.5cm}},
            width = \textwidth,
            height = .4\textheight
        }
    }
    
    \tikzset{%
        p10/.style = {thick},
        p25/.style = {thick},
        p50/.style = {thick},
        p75/.style = {thick},
        p100/.style = {thick},
        p150/.style = {thick},
        p200/.style = {thick},
        p250/.style = {thick}
    }
    
    \nottoggle{bwmode}{
        \tikzset{%
            p10/.append style = {draw = Cyan, fill = Cyan!3},
            p25/.append style = {draw = Cyan, fill = Cyan!7.5},
            p50/.append style = {draw = Cyan, fill = Cyan!15},
            p75/.append style = {draw = Cyan, fill = Cyan!22.5},
            p100/.append style = {draw = Cyan, fill = Cyan!30},
            p150/.append style = {draw = Cyan, fill = Cyan!45},
            p200/.append style = {draw = Cyan, fill = Cyan!60},
            p250/.append style = {draw = Cyan, fill = Cyan!75}
        }
    }{
        \tikzset{%
            p10/.append style = {draw = black, fill = black!3},
            p25/.append style = {draw = black, fill = black!7.5},
            p50/.append style = {draw = black, fill = black!15},
            p75/.append style = {draw = black, fill = black!22.5},
            p100/.append style = {draw = black, fill = black!30},
            p150/.append style = {draw = black, fill = black!45},
            p200/.append style = {draw = black, fill = black!60},
            p250/.append style = {draw = black, fill = black!75}
        }
    }
    
    \begin{figure}[t]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Transaction throughput }\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
                         legend pos = north west]
                \addplot[p10] coordinates
                    {(0, 58567.00) (1, 58268.03) (2, 66021.36) (3, 69642.80) (4, 146078.15) (5, 575054.82) (6, 887189.46)};
                \addplot[p25] coordinates
                    {(0, 56933.28) (1, 61109.63) (2, 67583.42) (3, 72281.31) (4, 144405.91) (5, 574779.55) (6, 880128.90)};
                \addplot[p50] coordinates
                    {(0, 57264.51) (1, 60318.40) (2, 67004.82) (3, 70148.16) (4, 146441.85) (5, 575556.58) (6, 883381.32)};
                \addplot[p75] coordinates
                    {(0, 57925.46) (1, 58989.11) (2, 64552.22) (3, 69460.85) (4, 144025.08) (5, 576188.00) (6, 882856.50)};
                \addplot[p100] coordinates
                    {(0, 59563.60) (1, 60740.88) (2, 65423.43) (3, 71580.94) (4, 146095.23) (5, 575680.50) (6, 883790.28)};
                \addplot[p150] coordinates
                    {(0, 57593.60) (1, 59380.81) (2, 64941.56) (3, 70230.15) (4, 146845.52) (5, 575828.84) (6, 892140.47)};
                \addplot[p200] coordinates
                    {(0, 59598.74) (1, 60914.58) (2, 67271.97) (3, 71998.14) (4, 145349.17) (5, 574940.67) (6, 884519.24)};
                \addplot[p250] coordinates
                    {(0, 57588.15) (1, 58937.21) (2, 65513.92) (3, 68994.17) (4, 145166.72) (5, 574710.40) (6, 886323.41)};
            \end{axis}
        \end{tikzpicture}
        \caption[Transaction throughput of LeanStore variants]{Transaction throughput of the \nameref{subsec:leanstore} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:leanstorethroughput}
    \end{figure}
    
    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         legend pos = north east,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[p10] coordinates
                    {(0, 89.25) (1, 91.76) (2, 95.48) (3, 97.81) (4, 99.53) (5, 99.84) (6, 99.86)};
                \addplot[p25] coordinates
                    {(0, 89.33) (1, 91.82) (2, 95.49) (3, 97.85) (4, 99.53) (5, 99.84) (6, 99.86)};
                \addplot[p50] coordinates
                    {(0, 89.43) (1, 91.80) (2, 95.48) (3, 97.81) (4, 99.55) (5, 99.84) (6, 99.86)};
                \addplot[p75] coordinates
                    {(0, 89.24) (1, 91.75) (2, 95.46) (3, 97.78) (4, 99.52) (5, 99.84) (6, 99.86)};
                \addplot[p100] coordinates
                    {(0, 89.36) (1, 91.87) (2, 95.42) (3, 97.83) (4, 99.53) (5, 99.84) (6, 99.86)};
                \addplot[p150] coordinates
                    {(0, 89.28) (1, 91.80) (2, 95.38) (3, 97.79) (4, 99.54) (5, 99.84) (6, 99.86)};
                \addplot[p200] coordinates
                    {(0, 89.45) (1, 91.87) (2, 95.50) (3, 97.83) (4, 99.53) (5, 99.84) (6, 99.86)};
                \addplot[p250] coordinates
                    {(0, 89.43) (1, 91.80) (2, 95.46) (3, 97.79) (4, 99.53) (5, 99.84) (6, 99.86)};
            \end{axis}
        \end{tikzpicture}
        \caption[Miss rate of LeanStore variants]{Miss rate of the \nameref{subsec:leanstore} page replacement algorithm variants for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:leanstorehitrate}
    \end{figure}
\end{@empty}

    % TODO: Exchange with new values!

    Neither the \emph{miss rate} nor the \emph{transaction throughput} differ significantly for different cooling stage sizes. Neither the pointer (un)swizzling overhead for larger cooling stage sizes nor the less detailed page reference statistics for smaller ones have a significant impact.

    While any variant could have been used for the performance evaluation in section \ref{sec:page_evictioners_performance_evaluation}, the one with a cooling stage size of \SI{2.5}{\percent} of the buffer pool was chosen.

\section{Performance Evaluation} \label{sec:page_evictioners_performance_evaluation}

    As described in the introductory section (section \ref{sec:page_evictioners_purpose}) of this chapter, the page replacement algorithm used in a DBMS has a \emph{significant impact on system performance}. There are three key \emph{performance factors} of a page replacement algorithm:

    \begin{enumerate}
        \item achieved hit rate
        \item overhead on page hit (e.g. waiting on a latch)
        \item overhead on page miss (selecting an eviction candidate)
    \end{enumerate}

    When page replacement algorithms are compared in \emph{scientific papers}, the focus is usually on the $1^{\text{st}}$ of the performance factors---the hit rate. \cite{Belady:1966}, \cite{Smith:1978}, \cite{Effelsberg:1984}, \cite{ONeil:1993}, \cite{Karedla:1994}, \cite{Johnson:1994}, \cite{Arlitt:2000-1}, \cite{Arlitt:2000-2}, \cite{Jiang:2002}, \cite{Megiddo:2003}, \cite{Bansal:2004}, \cite{Li:2018} and \cite{Li:2019} compare only the hit rates achieved with different page replacement algorithms in different situations---for example for different applications or buffer pool sizes. \cite{Jiang:2005}, \cite{Zhou:2001}, and \cite{Li:2018} give some limited data on overall system performance for different page replacement algorithms and \cite{Corbato:1969} compares the hit rate and CPU overhead for different parameterizations of one page replacement algorithm.

    There are \emph{many reasons} why the overhead of page replacement algorithms is so rarely compared. Hit rates are usually measured in a \emph{simulated buffer pool} with given page reference strings---which are either synthetically generated or recorded from real software runs. In this way, the hit rates achieved with the reference behavior of \emph{many different applications} (for which a newly proposed page replacement algorithm is usually to be evaluated) can be compared without having to implement the page replacement algorithms in different applications. Furthermore, it is usually \emph{easier to implement} a page replacement algorithm for a simulated buffer pool, since fewer exceptional cases have to be considered. The results of these simulations are also easier to compare because they \emph{abstract from real-world influences} such as the system configuration and the elapsed real time between successive page references. But ignoring factors such as the overhead of page hit synchronization, which occurs, for example, in the \nameref{subsubsec:lru_traditional} implementation of the \nameref{subsec:lru} page replacement algorithm, results in a biased---wrong---\emph{ranking of page replacement algorithms}.

    To allow a more realistic estimation of the achievable performance of the page replacement algorithms described in section \ref{sec:page_replacement_strategies}, this section provides a \emph{combined comparison of the hit rate and transaction throughput} achieved with the different algorithms.

\subsection{System Configuration} \label{subsec:page_evictioners_system_configuration}

    \begin{labeleddescription}
        \item[C++ Compiler] \label{intab:compiler} GCC (GNU Compiler Collection) 7.5.0 \footnote{\url{https://gcc.gnu.org/gcc-7/}}\footnote{Used flags: -g -O3 -fexpensive-optimizations -finline-functions -flto -fno-fat-lto-objects -fno-strict-aliasing -march=native}
        \item[OS]       \label{intab:os}     GNU/Linux 4.15.0 \footnote{\url{https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/}}
        \item[Kernel]   \label{intab:kernel} Ubuntu 18.04 LTS (Bionic Beaver) \footnote{\url{https://releases.ubuntu.com/18.04/}}
        \item[CPU]      \label{intab:cpu}    $2 \times $ Intel® Xeon® X5670 @$12 \times 2.93$\si{\giga\hertz} released early 2010
        \item[RAM]      \label{intab:ram}    $12 \times 8\si{\gibi\byte}$ ($\SI{96}{\gibi\byte}$) Samsung DDR3-SDRAM @\SI{1333}{\mega\hertz}\footnote{\url{https://www.samsung.com/semiconductor/dram/module/M393B1K70CH0-CH9/}}
        \item[Storage]  \label{intab:storage} $2 \times \SI{256}{\gibi\byte}$ Samsung SSD 840 PRO\footnote{\url{https://www.samsung.com/at/support/model/MZ-7PD256BW/}}\footnote{One SSD is only used for the DB file, the other is only used for the transaction log.}
    \end{labeleddescription}

\subsection{Benchmark} \label{subsec:page_evictioners_benchmark}

    The benchmark used for this performance evaluation is the well recognized OLTP benchmark \textit{TPC-C}\footnote{\url{http://www.tpc.org/tpcc/}}. \textit{TPC-C} simulates a classical business application for an OLTP system---a \emph{wholesale supplier}. It is the successor of the much simpler and deprecated \textit{TPC-A}\footnote{\url{http://www.tpc.org/tpca/}} and the predecessor of the much more sophisticated \textit{TPC-E}\footnote{\url{http://www.tpc.org/tpce/}}.

\paragraph{Database}

    The DB consists of nine tables. The size of the database can be scaled using the \emph{scaling factor} $W$, which allows the benchmark to simulate many different \emph{business sizes}. With a scaling factor of $W = 1$ the initial database size is $\approx\SI{143}{\mebi\byte}$.

    $W$ stands for ''warehouse''. The simulated wholesale supplier operates exactly one warehouse if $W = 1$ is used. This warehouse has \num{100000} items in stock and covers \num{10} districts with \num{3000} customers each. Per customer an order history of $\mathord{\geq}1$ orders is managed. Open orders consist of \numrange{5}{15} line items from the warehouse stock and as soon as an open order is processed, it is added to the order history without details such as line items.

    There are text fields with variable (SQL VARCHAR) and fixed length (SQL CHAR), fields with signed numeric (SQL DECIMAL), date and time (SQL TIMESTAMP) and ID data types ( can be implemented with SQL INT). The NEW ORDER table consists of 3 ID fields and each tuple has a size of \SI{6}{\byte}. The CUSTOMER table consists of 22 fields of different types and each tuple is $\mathord{\leq}\SI{679}{\byte}$. The tuple sizes of the seven other tables are between these two tuple sizes. There are \emph{primary indexes} based on the (composite) primary keys, and two tables also have \emph{secondary indexes}.

\paragraph{Transactions}

    A number of simulated \emph{online terminal sessions} are used to concurrently submit transactions to the database. \emph{12 terminal sessions} (the number of physical cores available) were used for this performance evaluation. The benchmark defines five types of transactions that simulate different activities of a wholesale supplier. The transactions must meet the \emph{ACID properties}. The data accesses by these transactions follow certain non-uniform distributions that lead to \emph{contention on the data}.

    \SI{45}{\percent} of the transactions submitted to the system are NEW ORDER transactions---characterized as mid-weight read/write transactions. The light-weight read/write transaction PAYMENT is used for \SI{43}{\percent} ($\mathord{+}\SI{4}{\percent}$, because the implementation included with the used prototype DBMS \textit{Zero}\footnote{\url{https://github.com/iMax3060/zero}} also runs PAYMENT instead of DELIVERY) of the transactions submitted to the system. The only two read-only transactions defined by the \textit{TPC-C} specification---the mid-weight ORDER STATUS transaction and the heavy STOCK LEVEL transaction---each account for only \SI{4}{\percent} of the transactions making \textit{TPC-C} \emph{update-focused}.

\subsection[Limitations]{Limitations of this Performance Evaluation} \label{subsec:page_evictioners_limits}

    The configuration of the \emph{server system} used for the performance evaluation, the properties of the \emph{database prototype} used and the \emph{benchmark} limit the generalizability of the results.

    A 10 year old server with two SSDs connected via SATA and DDR3 SDRAM is no longer a typical database server today. Even cheap servers use CPUs with much more cores and CPU cache. Midrange servers often have multiple \si{\tebi\byte} DDR4 SDRAM and use much faster NVMe SSDs. Even faster NVRAM solutions for DIMM slots are also available\footnote{\url{https://www.intel.com/content/dam/www/public/us/en/documents/product-briefs/optane-dc-persistent-memory-brief.pdf}} at a much higher price.

    The DBMS prototype \textit{Zero}\footnote{\url{https://github.com/iMax3060/zero}}\footnote{See my Bachelor's thesis \cite{Gilbert:2017} for more details about the history of Zero.} supports storing data only in \emph{Foster B trees} with one B-tree per primary index. Other data structures for indexes such as hash index structures, multidimensional index structures or trie structures are not supported.  \textit{Zero}'s buffer pool uses a \emph{global buffer allocation} and only \emph{demand paging}. Hints about pages that may be used in the future by a running transaction, which could be used for prefetching, or hints about the page reference pattern (e.g. loop) of a particular transaction, which could be used for page eviction decisions, are not supported.

    \textit{Zero} is an embedded DBMS, not a relational DBMS. The \emph{logical data structures} layer, which provides a set-oriented interface, e.g. using a query language like SQL, is missing in the system. The \emph{logical access paths} layer is also not part of \textit{Zero} itself, but implemented as part of its benchmark framework. Therefore, \textit{Zero} is not representative for most DBMSs used for DBs larger-than-memory.

    The benchmark used---\textit{TPC-C}---was specified in 1992, and \emph{applications for OLTP have diversified dramatically} over the past nearly 30 years. Especially the web with the advent of e-commerce and a hardly assessable number of other online services that are indispensable today leads to many new applications for OLTP and OLAP database systems. While the traditional business applications for OLTP applications still exist almost unchanged but the new applications are very often \emph{more read-heavy} than \textit{TPC-C}. And it is almost impossible to specify a benchmark that replicates the diversity of \emph{Big Data} applications.

\subsection{Results} \label{subsec:page_evictioners_results}

\begin{@empty}
    \pgfplotsset{%
        every axis/.append style = {
            ylabel near ticks,
            y label style = {font = \small},
            yticklabel style = {font = \scriptsize},
            ymode = normal,
            scaled y ticks = false,
            ybar = .4pt,
            bar width = .275em,
            xtick style = {draw = none},
            xtick = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14},
            xticklabels = {{\SI{100}{\mega\byte}}, {\SI{200}{\mega\byte}}, {\SI{400}{\mega\byte}}, {\SI{600}{\mega\byte}}, {\SI{800}{\mega\byte}}, {\SI{1}{\giga\byte}}, {\SI{2}{\giga\byte}}, {\SI{4}{\giga\byte}}, {\SI{6}{\giga\byte}}, {\SI{8}{\giga\byte}}, {\SI{10}{\giga\byte}}, {\SI{15}{\giga\byte}}, {\SI{20}{\giga\byte}}, {\SI{25}{\giga\byte}}, {\SI{30}{\giga\byte}}},
            x tick label style = {align = center, font = \footnotesize},
            xlabel near ticks,
            x label style = {font = \small},
            ymajorgrids = true,
            width = \textwidth,
            height = .3\textheight
        }
    }

    \nottoggle{bwmode}{
        \tikzset{%
            random/.style = {thin, draw = {rgb,511:red,1; green,0; blue,103}, fill = {rgb,255:red,1; green,0; blue,103}},
            loop/.style = {thin, draw = {rgb,511:red,213; green,255; blue,0}, fill = {rgb,255:red,213; green,255; blue,0}},
            fifo/.style = {thin, draw = {rgb,511:red,255; green,0; blue,86}, fill = {rgb,255:red,255; green,0; blue,86}},
            filo/.style = {thin, draw = {rgb,511:red,158; green,0; blue,142}, fill = {rgb,255:red,158; green,0; blue,142}},
            lru/.style = {thin, draw = {rgb,511:red,14; green,76; blue,161}, fill = {rgb,255:red,14; green,76; blue,161}},
            sortlru/.style = {thin, draw = {rgb,511:red,255; green,229; blue,2}, fill = {rgb,255:red,255; green,229; blue,2}},
            lru2/.style = {thin, draw = {rgb,511:red,0; green,95; blue,57}, fill = {rgb,255:red,0; green,95; blue,57}},
            sortlru2/.style = {thin, draw = {rgb,511:red,0; green,255; blue,0}, fill = {rgb,255:red,0; green,255; blue,0}},
            lru3/.style = {thin, draw = {rgb,511:red,149; green,0; blue,58}, fill = {rgb,255:red,149; green,0; blue,58}},
            sortlru3/.style = {thin, draw = {rgb,511:red,255; green,147; blue,126}, fill = {rgb,255:red,255; green,147; blue,126}},
            lru4/.style = {thin, draw = {rgb,511:red,164; green,36; blue,0}, fill = {rgb,255:red,164; green,36; blue,0}},
            sortlru4/.style = {thin, draw = {rgb,511:red,0; green,21; blue,68}, fill = {rgb,255:red,0; green,21; blue,68}},
            mru/.style = {thin, draw = {rgb,511:red,145; green,208; blue,203}, fill = {rgb,255:red,145; green,208; blue,203}},
            slru/.style = {thin, draw = {rgb,511:red,98; green,14; blue,0}, fill = {rgb,255:red,98; green,14; blue,0}},
            clock/.style = {thin, draw = {rgb,511:red,107; green,104; blue,130}, fill = {rgb,255:red,107; green,104; blue,130}},
            zclock/.style = {thin, draw = {rgb,511:red,0; green,0; blue,255}, fill = {rgb,255:red,0; green,0; blue,255}},
            gclockv1/.style = {thin, draw = {rgb,511:red,0; green,125; blue,181}, fill = {rgb,255:red,0; green,125; blue,181}},
            gclockv2/.style = {thin, draw = {rgb,511:red,106; green,130; blue,108}, fill = {rgb,255:red,106; green,130; blue,108}},
            dgclockv1/.style = {thin, draw = {rgb,511:red,0; green,174; blue,126}, fill = {rgb,255:red,0; green,174; blue,126}},
            dgclockv2/.style = {thin, draw = {rgb,511:red,194; green,140; blue,159}, fill = {rgb,255:red,194; green,140; blue,159}},
            lrdv1/.style = {thin, draw = {rgb,511:red,190; green,153; blue,112}, fill = {rgb,255:red,190; green,153; blue,112}},
            lrdv2/.style = {thin, draw = {rgb,511:red,0; green,143; blue,156}, fill = {rgb,255:red,0; green,143; blue,156}},
            lfu/.style = {thin, draw = {rgb,511:red,95; green,173; blue,78}, fill = {rgb,255:red,95; green,173; blue,78}},
            lfuda/.style = {thin, draw = {rgb,511:red,255; green,0; blue,0}, fill = {rgb,255:red,255; green,0; blue,0}},
            leanstore/.style = {thin, draw = {rgb,511:red,255; green,0; blue,246}, fill = {rgb,255:red,255; green,0; blue,246}}
        }
    }{
        \tikzset{%
            random/.style = {thin, fill = black!80},
            loop/.style = {thin, fill = black!60},
            fifo/.style = {thin, fill = black!40},
            filo/.style = {thin, fill = black!20},
            lru/.style = {thin, fill = black!0},
            sortlru/.style = {thin, fill = black!80, postaction = {pattern = horizontal lines, pattern color = white}},
            lru2/.style = {thin, fill = black!60, postaction = {pattern = horizontal lines, pattern color = white}},
            sortlru2/.style = {thin, fill = black!40, postaction = {pattern = horizontal lines}},
            lru3/.style = {thin, fill = black!20, postaction = {pattern = horizontal lines}},
            sortlru3/.style = {thin, fill = black!0, postaction = {pattern = horizontal lines}},
            lru4/.style = {thin, densely dashed, fill = black!80},
            sortlru4/.style = {thin, densely dashed, fill = black!60},
            mru/.style = {thin, densely dashed, fill = black!40},
            slru/.style = {thin, densely dashed, fill = black!20},
            clock/.style = {thin, densely dashed, fill = black!0},
            zclock/.style = {thin, densely dashed, fill = black!80, postaction = {pattern = horizontal lines, pattern color = white}},
            gclockv1/.style = {thin, densely dashed, fill = black!60, postaction = {pattern = horizontal lines, pattern color = white}},
            gclockv2/.style = {thin, densely dashed, fill = black!40, postaction = {pattern = horizontal lines}},
            dgclockv1/.style = {thin, densely dashed, fill = black!20, postaction = {pattern = horizontal lines}},
            dgclockv2/.style = {thin, densely dashed, fill = black!0, postaction = {pattern = horizontal lines}},
            lrdv1/.style = {dotted, fill = black!80},
            lrdv2/.style = {dotted, fill = black!60},
            lfu/.style = {dotted, fill = black!40},
            lfuda/.style = {dotted, fill = black!20},
            leanstore/.style = {dotted, fill = black!0}
        }
    }
    
    \begin{figure}[h!]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {tpm-C $\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
%                         ymax = 100000,
                         xmin = -0.5,
                         xmax = 2.5]
                \addplot[random] coordinates
                    {(0, 66369.56) (1, 74553.61) (2, 81580.19) (3, 84328.74) (4, 93443.81) (5, 96880.01) (6, 125655.94) (7, 193685.35) (8, 345966.01) (9, 575737.3) (10, 745879.28) (11, 817851.23) (12, 825045.18) (13, 845368.47) (14, 883277.13)};
                \addplot[loop] coordinates
                    {(0, 70949.02) (1, 76608.40) (2, 84705.71) (3, 84816.29) (4, 93083.19) (5, 98612.02) (6, 146284.34) (7, 384662.18) (8, 536950.54) (9, 606275.16) (10, 651359.91) (11, 591419.60) (12, 651098.14) (13, 823777.55) (14, 885986.48)};
                \addplot[fifo] coordinates
                    {(0, 55342.01) (1, 42729.60) (2, 51566.13) (3, 57120.30) (4, 60370.71) (5, 8609.85) (6, 106818.15) (7, 222701.79) (8, 279046.76) (9, 318109.17) (10, 331681.30) (11, 595590.41) (12, 784744.71) (13, 861913.74) (14, 884801.25)};
                \addplot[filo] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 46523.96) (4, 56177.01) (5, 59666.59) (6, 68746.37) (7, 78524.20) (8, 100404.14) (9, 149804.57) (10, 254821.20) (11, 458817.84) (12, 637358.41) (13, 78369.27) (14, 882267.65)};
                \addplot[lru] coordinates
                    {(0, 18872.5) (1, 20487.22) (2, 23493.87) (3, 25443.28) (4, 25363.94) (5, 26448.21) (6, 31662.27) (7, 38523.47) (8, 44474.03) (9, 48070.75) (10, 51950.79) (11, 50384.85) (12, 49954.97) (13, 50575.8) (14, 50985.66)};
                \addplot[sortlru] coordinates
                    {(0, 66169.01) (1, 72628.41) (2, 84543.77) (3, 83889.85) (4, 91245.69) (5, 95589.83) (6, 126811.64) (7, 203740.37) (8, 375183.95) (9, 626535.64) (10, 743556.02) (11, 777533.02) (12, 787522.38) (13, 847635.07) (14, 882705.81)};
                \addplot[lru2] coordinates
                    {(0, 15812.95) (1, 17944.83) (2, 21143.24) (3, 0) (4, 23452.72) (5, 25635.11) (6, 0) (7, 0) (8, 68746.79) (9, 83182.4) (10, 90084.7) (11, 93021.16) (12, 93137.77) (13, 93771.43) (14, 91993.28)};
                \addplot[sortlru2] coordinates
                    {(0, 62385.85) (1, 65275.15) (2, 78600.64) (3, 79605.18) (4, 86114.27) (5, 90094.68) (6, 117201.16) (7, 190744.92) (8, 353618.74) (9, 521591.87) (10, 609571.14) (11, 750886.95) (12, 779378.88) (13, 853401.18) (14, 882643.03)};
                \addplot[lru3] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 88825.75) (12, 88439.05) (13, 90132.13) (14, 87919.7)};
                \addplot[sortlru3] coordinates
                    {(0, 63298.64) (1, 67242.07) (2, 77184.52) (3, 78231.77) (4, 83545.09) (5, 86892.65) (6, 120019.75) (7, 190695.96) (8, 332174.36) (9, 502105.23) (10, 582070.58) (11, 744621.44) (12, 780863.00) (13, 858186.76) (14, 885356.47)};
                \addplot[lru4] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84960.61) (12, 86672.97) (13, 86011.06) (14, 86711.04)};
                \addplot[sortlru4] coordinates
                    {(0, 63127.46) (1, 68682.75) (2, 78473.26) (3, 77103.49) (4, 83694.59) (5, 88463.72) (6, 107832.16) (7, 180258.68) (8, 315150.49) (9, 473159.93) (10, 598991.63) (11, 739936.15) (12, 777531.48) (13, 858993.74) (14, 882949.16)};
                \addplot[mru] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84120.15) (12, 84209.9) (13, 82220.8) (14, 84308.15)};
                \addplot[slru] coordinates
                    {(0, 13402.45) (1, 15332.79) (2, 19091.10) (3, 20393.00) (4, 20936.46) (5, 21244.53) (6, 25357.14) (7, 31599.02) (8, 37830.23) (9, 44057.08) (10, 46947.98) (11, 50071.23) (12, 51500.64) (13, 53447.12) (14, 54257.82)};
                \addplot[clock] coordinates
                    {(0, 65678.66) (1, 72894.37) (2, 85667.66) (3, 84846.12) (4, 89550.02) (5, 96966.58) (6, 124674.78) (7, 190359.77) (8, 338885.12) (9, 533097.44) (10, 640107.58) (11, 715927.50) (12, 764376.33) (13, 842440.18) (14, 882630.35)};
                \addplot[zclock] coordinates
                    {(0, 67089.83) (1, 74312.65) (2, 82556.26) (3, 84335.27) (4, 91521.58) (5, 96157.15) (6, 127058.42) (7, 195286.30) (8, 357803.60) (9, 600725.43) (10, 752314.59) (11, 823610.82) (12, 825660.26) (13, 838551.86) (14, 883868.08)};
                \addplot[gclockv1] coordinates
                    {(0, 65985.5) (1, 71670.36) (2, 81120.23) (3, 83754.09) (4, 88586.7) (5, 91878.85) (6, 115534.43) (7, 169758.58) (8, 259078.92) (9, 364973.12) (10, 476421.55) (11, 623180.22) (12, 680851.59) (13, 808326.82) (14, 884063.26)};
                \addplot[gclockv2] coordinates
                    {(0, 66780.15) (1, 72606.22) (2, 84203.25) (3, 85249.95) (4, 92069.45) (5, 95650.98) (6, 124270.01) (7, 191930.1) (8, 339709.17) (9, 534815.88) (10, 636412.55) (11, 717717.52) (12, 768695.31) (13, 844940.89) (14, 886769.52)};
                \addplot[dgclockv1] coordinates
                    {(0, 70770.81) (1, 74870.39) (2, 85946.24) (3, 84744.89) (4, 94621.84) (5, 98730.43) (6, 151594.61) (7, 407812.34) (8, 554634.31) (9, 594609.18) (10, 659508.56) (11, 604424.98) (12, 642017.59) (13, 814471.03) (14, 882040.53)};
                \addplot[dgclockv2] coordinates
                    {(0, 70867.89) (1, 75135.04) (2, 84387.36) (3, 84586.89) (4, 94341.66) (5, 99901.39) (6, 161242.15) (7, 396884.09) (8, 548662.03) (9, 611189.58) (10, 667182.23) (11, 596007.58) (12, 646545.42) (13, 814066.86) (14, 882166.96)};
                \addplot[lrdv1] coordinates
                    {(0, 16802.02) (1, 14567.02) (2, 12053.83) (3, 10497.18) (4, 9282.41) (5, 8946.49) (6, 9743.06) (7, 13860.95) (8, 24747.11) (9, 50450.68) (10, 101250.48) (11, 312698.28) (12, 569124.09) (13, 827709.37) (14, 878254.20)};
                \addplot[lrdv2] coordinates
                    {(0, 22062.91) (1, 22131.36) (2, 23944.26) (3, 21285.87) (4, 18076.78) (5, 16143.02) (6, 13939.54) (7, 18816.72) (8, 28985.49) (9, 51747.98) (10, 101608.66) (11, 315660.85) (12, 568795.71) (13, 827285.71) (14, 880416.58)};
                \addplot[lfu] coordinates
                    {(0, 0) (1, 10554.92) (2, 11709.01) (3, 12796.65) (4, 13582.12) (5, 14465.79) (6, 18056.65) (7, 28936.50) (8, 55856.34) (9, 101187.86) (10, 161100.70) (11, 356256.86) (12, 579274.70) (13, 786046.87) (14, 884339.71)};
                \addplot[lfuda] coordinates
                    {(0, 39490.59) (1, 38559.21) (2, 44340.21) (3, 41994.75) (4, 40803.21) (5, 39486.79) (6, 38684.87) (7, 45408.72) (8, 71900.23) (9, 117297.55) (10, 183630.86) (11, 388916.49) (12, 609234.52) (13, 787808.90) (14, 888557.41)};
                \addplot[leanstore] coordinates
                    {(0, 0) (1, 51990.70) (2, 59001.01) (3, 57988.31) (4, 58094.99) (5, 59516.53) (6, 61902.71) (7, 67954.34) (8, 77876.77) (9, 99322.39) (10, 139482.88) (11, 336124.21) (12, 566436.28) (13, 691799.01) (14, 884049.78)};
            \end{axis}
        \end{tikzpicture} \\
        \begin{tikzpicture}
            \begin{axis}[ylabel = {tpm-C $\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
%                         ymax = 100000,
                         xmin = 2.5,
                         xmax = 5.5]
                \addplot[random] coordinates
                    {(0, 66369.56) (1, 74553.61) (2, 81580.19) (3, 84328.74) (4, 93443.81) (5, 96880.01) (6, 125655.94) (7, 193685.35) (8, 345966.01) (9, 575737.3) (10, 745879.28) (11, 817851.23) (12, 825045.18) (13, 845368.47) (14, 883277.13)};
                \addplot[loop] coordinates
                    {(0, 70949.02) (1, 76608.40) (2, 84705.71) (3, 84816.29) (4, 93083.19) (5, 98612.02) (6, 146284.34) (7, 384662.18) (8, 536950.54) (9, 606275.16) (10, 651359.91) (11, 591419.60) (12, 651098.14) (13, 823777.55) (14, 885986.48)};
                \addplot[fifo] coordinates
                    {(0, 55342.01) (1, 42729.60) (2, 51566.13) (3, 57120.30) (4, 60370.71) (5, 8609.85) (6, 106818.15) (7, 222701.79) (8, 279046.76) (9, 318109.17) (10, 331681.30) (11, 595590.41) (12, 784744.71) (13, 861913.74) (14, 884801.25)};
                \addplot[filo] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 46523.96) (4, 56177.01) (5, 59666.59) (6, 68746.37) (7, 78524.20) (8, 100404.14) (9, 149804.57) (10, 254821.20) (11, 458817.84) (12, 637358.41) (13, 78369.27) (14, 882267.65)};
                \addplot[lru] coordinates
                    {(0, 18872.5) (1, 20487.22) (2, 23493.87) (3, 25443.28) (4, 25363.94) (5, 26448.21) (6, 31662.27) (7, 38523.47) (8, 44474.03) (9, 48070.75) (10, 51950.79) (11, 50384.85) (12, 49954.97) (13, 50575.8) (14, 50985.66)};
                \addplot[sortlru] coordinates
                    {(0, 66169.01) (1, 72628.41) (2, 84543.77) (3, 83889.85) (4, 91245.69) (5, 95589.83) (6, 126811.64) (7, 203740.37) (8, 375183.95) (9, 626535.64) (10, 743556.02) (11, 777533.02) (12, 787522.38) (13, 847635.07) (14, 882705.81)};
                \addplot[lru2] coordinates
                    {(0, 15812.95) (1, 17944.83) (2, 21143.24) (3, 0) (4, 23452.72) (5, 25635.11) (6, 0) (7, 0) (8, 68746.79) (9, 83182.4) (10, 90084.7) (11, 93021.16) (12, 93137.77) (13, 93771.43) (14, 91993.28)};
                \addplot[sortlru2] coordinates
                    {(0, 62385.85) (1, 65275.15) (2, 78600.64) (3, 79605.18) (4, 86114.27) (5, 90094.68) (6, 117201.16) (7, 190744.92) (8, 353618.74) (9, 521591.87) (10, 609571.14) (11, 750886.95) (12, 779378.88) (13, 853401.18) (14, 882643.03)};
                \addplot[lru3] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 88825.75) (12, 88439.05) (13, 90132.13) (14, 87919.7)};
                \addplot[sortlru3] coordinates
                    {(0, 63298.64) (1, 67242.07) (2, 77184.52) (3, 78231.77) (4, 83545.09) (5, 86892.65) (6, 120019.75) (7, 190695.96) (8, 332174.36) (9, 502105.23) (10, 582070.58) (11, 744621.44) (12, 780863.00) (13, 858186.76) (14, 885356.47)};
                \addplot[lru4] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84960.61) (12, 86672.97) (13, 86011.06) (14, 86711.04)};
                \addplot[sortlru4] coordinates
                    {(0, 63127.46) (1, 68682.75) (2, 78473.26) (3, 77103.49) (4, 83694.59) (5, 88463.72) (6, 107832.16) (7, 180258.68) (8, 315150.49) (9, 473159.93) (10, 598991.63) (11, 739936.15) (12, 777531.48) (13, 858993.74) (14, 882949.16)};
                \addplot[mru] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84120.15) (12, 84209.9) (13, 82220.8) (14, 84308.15)};
                \addplot[slru] coordinates
                    {(0, 13402.45) (1, 15332.79) (2, 19091.10) (3, 20393.00) (4, 20936.46) (5, 21244.53) (6, 25357.14) (7, 31599.02) (8, 37830.23) (9, 44057.08) (10, 46947.98) (11, 50071.23) (12, 51500.64) (13, 53447.12) (14, 54257.82)};
                \addplot[clock] coordinates
                    {(0, 65678.66) (1, 72894.37) (2, 85667.66) (3, 84846.12) (4, 89550.02) (5, 96966.58) (6, 124674.78) (7, 190359.77) (8, 338885.12) (9, 533097.44) (10, 640107.58) (11, 715927.50) (12, 764376.33) (13, 842440.18) (14, 882630.35)};
                \addplot[zclock] coordinates
                    {(0, 67089.83) (1, 74312.65) (2, 82556.26) (3, 84335.27) (4, 91521.58) (5, 96157.15) (6, 127058.42) (7, 195286.30) (8, 357803.60) (9, 600725.43) (10, 752314.59) (11, 823610.82) (12, 825660.26) (13, 838551.86) (14, 883868.08)};
                \addplot[gclockv1] coordinates
                    {(0, 65985.5) (1, 71670.36) (2, 81120.23) (3, 83754.09) (4, 88586.7) (5, 91878.85) (6, 115534.43) (7, 169758.58) (8, 259078.92) (9, 364973.12) (10, 476421.55) (11, 623180.22) (12, 680851.59) (13, 808326.82) (14, 884063.26)};
                \addplot[gclockv2] coordinates
                    {(0, 66780.15) (1, 72606.22) (2, 84203.25) (3, 85249.95) (4, 92069.45) (5, 95650.98) (6, 124270.01) (7, 191930.1) (8, 339709.17) (9, 534815.88) (10, 636412.55) (11, 717717.52) (12, 768695.31) (13, 844940.89) (14, 886769.52)};
                \addplot[dgclockv1] coordinates
                    {(0, 70770.81) (1, 74870.39) (2, 85946.24) (3, 84744.89) (4, 94621.84) (5, 98730.43) (6, 151594.61) (7, 407812.34) (8, 554634.31) (9, 594609.18) (10, 659508.56) (11, 604424.98) (12, 642017.59) (13, 814471.03) (14, 882040.53)};
                \addplot[dgclockv2] coordinates
                    {(0, 70867.89) (1, 75135.04) (2, 84387.36) (3, 84586.89) (4, 94341.66) (5, 99901.39) (6, 161242.15) (7, 396884.09) (8, 548662.03) (9, 611189.58) (10, 667182.23) (11, 596007.58) (12, 646545.42) (13, 814066.86) (14, 882166.96)};
                \addplot[lrdv1] coordinates
                    {(0, 16802.02) (1, 14567.02) (2, 12053.83) (3, 10497.18) (4, 9282.41) (5, 8946.49) (6, 9743.06) (7, 13860.95) (8, 24747.11) (9, 50450.68) (10, 101250.48) (11, 312698.28) (12, 569124.09) (13, 827709.37) (14, 878254.20)};
                \addplot[lrdv2] coordinates
                    {(0, 22062.91) (1, 22131.36) (2, 23944.26) (3, 21285.87) (4, 18076.78) (5, 16143.02) (6, 13939.54) (7, 18816.72) (8, 28985.49) (9, 51747.98) (10, 101608.66) (11, 315660.85) (12, 568795.71) (13, 827285.71) (14, 880416.58)};
                \addplot[lfu] coordinates
                    {(0, 0) (1, 10554.92) (2, 11709.01) (3, 12796.65) (4, 13582.12) (5, 14465.79) (6, 18056.65) (7, 28936.50) (8, 55856.34) (9, 101187.86) (10, 161100.70) (11, 356256.86) (12, 579274.70) (13, 786046.87) (14, 884339.71)};
                \addplot[lfuda] coordinates
                    {(0, 39490.59) (1, 38559.21) (2, 44340.21) (3, 41994.75) (4, 40803.21) (5, 39486.79) (6, 38684.87) (7, 45408.72) (8, 71900.23) (9, 117297.55) (10, 183630.86) (11, 388916.49) (12, 609234.52) (13, 787808.90) (14, 888557.41)};
                \addplot[leanstore] coordinates
                    {(0, 0) (1, 51990.70) (2, 59001.01) (3, 57988.31) (4, 58094.99) (5, 59516.53) (6, 61902.71) (7, 67954.34) (8, 77876.77) (9, 99322.39) (10, 139482.88) (11, 336124.21) (12, 566436.28) (13, 691799.01) (14, 884049.78)};
            \end{axis}
        \end{tikzpicture} \\
        \begin{tikzpicture}
            \begin{axis}[ylabel = {tpm-C $\left[\si{1\per\minute}\right]$},
                         ymin = 0,
%                         ymax = 1000000,
                         xmin = 5.5,
                         xmax = 8.5,
                         xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})}]
                \addplot[random] coordinates
                    {(0, 66369.56) (1, 74553.61) (2, 81580.19) (3, 84328.74) (4, 93443.81) (5, 96880.01) (6, 125655.94) (7, 193685.35) (8, 345966.01) (9, 575737.3) (10, 745879.28) (11, 817851.23) (12, 825045.18) (13, 845368.47) (14, 883277.13)};
                \addplot[loop] coordinates
                    {(0, 70949.02) (1, 76608.40) (2, 84705.71) (3, 84816.29) (4, 93083.19) (5, 98612.02) (6, 146284.34) (7, 384662.18) (8, 536950.54) (9, 606275.16) (10, 651359.91) (11, 591419.60) (12, 651098.14) (13, 823777.55) (14, 885986.48)};
                \addplot[fifo] coordinates
                    {(0, 55342.01) (1, 42729.60) (2, 51566.13) (3, 57120.30) (4, 60370.71) (5, 8609.85) (6, 106818.15) (7, 222701.79) (8, 279046.76) (9, 318109.17) (10, 331681.30) (11, 595590.41) (12, 784744.71) (13, 861913.74) (14, 884801.25)};
                \addplot[filo] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 46523.96) (4, 56177.01) (5, 59666.59) (6, 68746.37) (7, 78524.20) (8, 100404.14) (9, 149804.57) (10, 254821.20) (11, 458817.84) (12, 637358.41) (13, 78369.27) (14, 882267.65)};
                \addplot[lru] coordinates
                    {(0, 18872.5) (1, 20487.22) (2, 23493.87) (3, 25443.28) (4, 25363.94) (5, 26448.21) (6, 31662.27) (7, 38523.47) (8, 44474.03) (9, 48070.75) (10, 51950.79) (11, 50384.85) (12, 49954.97) (13, 50575.8) (14, 50985.66)};
                \addplot[sortlru] coordinates
                    {(0, 66169.01) (1, 72628.41) (2, 84543.77) (3, 83889.85) (4, 91245.69) (5, 95589.83) (6, 126811.64) (7, 203740.37) (8, 375183.95) (9, 626535.64) (10, 743556.02) (11, 777533.02) (12, 787522.38) (13, 847635.07) (14, 882705.81)};
                \addplot[lru2] coordinates
                    {(0, 15812.95) (1, 17944.83) (2, 21143.24) (3, 0) (4, 23452.72) (5, 25635.11) (6, 0) (7, 0) (8, 68746.79) (9, 83182.4) (10, 90084.7) (11, 93021.16) (12, 93137.77) (13, 93771.43) (14, 91993.28)};
                \addplot[sortlru2] coordinates
                    {(0, 62385.85) (1, 65275.15) (2, 78600.64) (3, 79605.18) (4, 86114.27) (5, 90094.68) (6, 117201.16) (7, 190744.92) (8, 353618.74) (9, 521591.87) (10, 609571.14) (11, 750886.95) (12, 779378.88) (13, 853401.18) (14, 882643.03)};
                \addplot[lru3] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 88825.75) (12, 88439.05) (13, 90132.13) (14, 87919.7)};
                \addplot[sortlru3] coordinates
                    {(0, 63298.64) (1, 67242.07) (2, 77184.52) (3, 78231.77) (4, 83545.09) (5, 86892.65) (6, 120019.75) (7, 190695.96) (8, 332174.36) (9, 502105.23) (10, 582070.58) (11, 744621.44) (12, 780863.00) (13, 858186.76) (14, 885356.47)};
                \addplot[lru4] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84960.61) (12, 86672.97) (13, 86011.06) (14, 86711.04)};
                \addplot[sortlru4] coordinates
                    {(0, 63127.46) (1, 68682.75) (2, 78473.26) (3, 77103.49) (4, 83694.59) (5, 88463.72) (6, 107832.16) (7, 180258.68) (8, 315150.49) (9, 473159.93) (10, 598991.63) (11, 739936.15) (12, 777531.48) (13, 858993.74) (14, 882949.16)};
                \addplot[mru] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84120.15) (12, 84209.9) (13, 82220.8) (14, 84308.15)};
                \addplot[slru] coordinates
                    {(0, 13402.45) (1, 15332.79) (2, 19091.10) (3, 20393.00) (4, 20936.46) (5, 21244.53) (6, 25357.14) (7, 31599.02) (8, 37830.23) (9, 44057.08) (10, 46947.98) (11, 50071.23) (12, 51500.64) (13, 53447.12) (14, 54257.82)};
                \addplot[clock] coordinates
                    {(0, 65678.66) (1, 72894.37) (2, 85667.66) (3, 84846.12) (4, 89550.02) (5, 96966.58) (6, 124674.78) (7, 190359.77) (8, 338885.12) (9, 533097.44) (10, 640107.58) (11, 715927.50) (12, 764376.33) (13, 842440.18) (14, 882630.35)};
                \addplot[zclock] coordinates
                    {(0, 67089.83) (1, 74312.65) (2, 82556.26) (3, 84335.27) (4, 91521.58) (5, 96157.15) (6, 127058.42) (7, 195286.30) (8, 357803.60) (9, 600725.43) (10, 752314.59) (11, 823610.82) (12, 825660.26) (13, 838551.86) (14, 883868.08)};
                \addplot[gclockv1] coordinates
                    {(0, 65985.5) (1, 71670.36) (2, 81120.23) (3, 83754.09) (4, 88586.7) (5, 91878.85) (6, 115534.43) (7, 169758.58) (8, 259078.92) (9, 364973.12) (10, 476421.55) (11, 623180.22) (12, 680851.59) (13, 808326.82) (14, 884063.26)};
                \addplot[gclockv2] coordinates
                    {(0, 66780.15) (1, 72606.22) (2, 84203.25) (3, 85249.95) (4, 92069.45) (5, 95650.98) (6, 124270.01) (7, 191930.1) (8, 339709.17) (9, 534815.88) (10, 636412.55) (11, 717717.52) (12, 768695.31) (13, 844940.89) (14, 886769.52)};
                \addplot[dgclockv1] coordinates
                    {(0, 70770.81) (1, 74870.39) (2, 85946.24) (3, 84744.89) (4, 94621.84) (5, 98730.43) (6, 151594.61) (7, 407812.34) (8, 554634.31) (9, 594609.18) (10, 659508.56) (11, 604424.98) (12, 642017.59) (13, 814471.03) (14, 882040.53)};
                \addplot[dgclockv2] coordinates
                    {(0, 70867.89) (1, 75135.04) (2, 84387.36) (3, 84586.89) (4, 94341.66) (5, 99901.39) (6, 161242.15) (7, 396884.09) (8, 548662.03) (9, 611189.58) (10, 667182.23) (11, 596007.58) (12, 646545.42) (13, 814066.86) (14, 882166.96)};
                \addplot[lrdv1] coordinates
                    {(0, 16802.02) (1, 14567.02) (2, 12053.83) (3, 10497.18) (4, 9282.41) (5, 8946.49) (6, 9743.06) (7, 13860.95) (8, 24747.11) (9, 50450.68) (10, 101250.48) (11, 312698.28) (12, 569124.09) (13, 827709.37) (14, 878254.20)};
                \addplot[lrdv2] coordinates
                    {(0, 22062.91) (1, 22131.36) (2, 23944.26) (3, 21285.87) (4, 18076.78) (5, 16143.02) (6, 13939.54) (7, 18816.72) (8, 28985.49) (9, 51747.98) (10, 101608.66) (11, 315660.85) (12, 568795.71) (13, 827285.71) (14, 880416.58)};
                \addplot[lfu] coordinates
                    {(0, 0) (1, 10554.92) (2, 11709.01) (3, 12796.65) (4, 13582.12) (5, 14465.79) (6, 18056.65) (7, 28936.50) (8, 55856.34) (9, 101187.86) (10, 161100.70) (11, 356256.86) (12, 579274.70) (13, 786046.87) (14, 884339.71)};
                \addplot[lfuda] coordinates
                    {(0, 39490.59) (1, 38559.21) (2, 44340.21) (3, 41994.75) (4, 40803.21) (5, 39486.79) (6, 38684.87) (7, 45408.72) (8, 71900.23) (9, 117297.55) (10, 183630.86) (11, 388916.49) (12, 609234.52) (13, 787808.90) (14, 888557.41)};
                \addplot[leanstore] coordinates
                    {(0, 0) (1, 51990.70) (2, 59001.01) (3, 57988.31) (4, 58094.99) (5, 59516.53) (6, 61902.71) (7, 67954.34) (8, 77876.77) (9, 99322.39) (10, 139482.88) (11, 336124.21) (12, 566436.28) (13, 691799.01) (14, 884049.78)};
            \end{axis}
        \end{tikzpicture}
        \vspace{-1em}
        \caption[Transaction throughput of different page eviction algorithms]{Transaction throughput of the page replacement algorithms from section \ref{sec:page_replacement_strategies} for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:throughput1}
    \end{figure}

    \begin{figure}[h!]\ContinuedFloat
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {tpm-C $\left[\si{1\per\minute}\right]$},
                         ymode = normal,
                         ymin = 0,
%                         ymax = 1000000,
                         xmin = 8.5,
                         xmax = 11.5]
                \addplot[random] coordinates
                    {(0, 66369.56) (1, 74553.61) (2, 81580.19) (3, 84328.74) (4, 93443.81) (5, 96880.01) (6, 125655.94) (7, 193685.35) (8, 345966.01) (9, 575737.3) (10, 745879.28) (11, 817851.23) (12, 825045.18) (13, 845368.47) (14, 883277.13)};
                \addplot[loop] coordinates
                    {(0, 70949.02) (1, 76608.40) (2, 84705.71) (3, 84816.29) (4, 93083.19) (5, 98612.02) (6, 146284.34) (7, 384662.18) (8, 536950.54) (9, 606275.16) (10, 651359.91) (11, 591419.60) (12, 651098.14) (13, 823777.55) (14, 885986.48)};
                \addplot[fifo] coordinates
                    {(0, 55342.01) (1, 42729.60) (2, 51566.13) (3, 57120.30) (4, 60370.71) (5, 8609.85) (6, 106818.15) (7, 222701.79) (8, 279046.76) (9, 318109.17) (10, 331681.30) (11, 595590.41) (12, 784744.71) (13, 861913.74) (14, 884801.25)};
                \addplot[filo] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 46523.96) (4, 56177.01) (5, 59666.59) (6, 68746.37) (7, 78524.20) (8, 100404.14) (9, 149804.57) (10, 254821.20) (11, 458817.84) (12, 637358.41) (13, 78369.27) (14, 882267.65)};
                \addplot[lru] coordinates
                    {(0, 18872.5) (1, 20487.22) (2, 23493.87) (3, 25443.28) (4, 25363.94) (5, 26448.21) (6, 31662.27) (7, 38523.47) (8, 44474.03) (9, 48070.75) (10, 51950.79) (11, 50384.85) (12, 49954.97) (13, 50575.8) (14, 50985.66)};
                \addplot[sortlru] coordinates
                    {(0, 66169.01) (1, 72628.41) (2, 84543.77) (3, 83889.85) (4, 91245.69) (5, 95589.83) (6, 126811.64) (7, 203740.37) (8, 375183.95) (9, 626535.64) (10, 743556.02) (11, 777533.02) (12, 787522.38) (13, 847635.07) (14, 882705.81)};
                \addplot[lru2] coordinates
                    {(0, 15812.95) (1, 17944.83) (2, 21143.24) (3, 0) (4, 23452.72) (5, 25635.11) (6, 0) (7, 0) (8, 68746.79) (9, 83182.4) (10, 90084.7) (11, 93021.16) (12, 93137.77) (13, 93771.43) (14, 91993.28)};
                \addplot[sortlru2] coordinates
                    {(0, 62385.85) (1, 65275.15) (2, 78600.64) (3, 79605.18) (4, 86114.27) (5, 90094.68) (6, 117201.16) (7, 190744.92) (8, 353618.74) (9, 521591.87) (10, 609571.14) (11, 750886.95) (12, 779378.88) (13, 853401.18) (14, 882643.03)};
                \addplot[lru3] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 88825.75) (12, 88439.05) (13, 90132.13) (14, 87919.7)};
                \addplot[sortlru3] coordinates
                    {(0, 63298.64) (1, 67242.07) (2, 77184.52) (3, 78231.77) (4, 83545.09) (5, 86892.65) (6, 120019.75) (7, 190695.96) (8, 332174.36) (9, 502105.23) (10, 582070.58) (11, 744621.44) (12, 780863.00) (13, 858186.76) (14, 885356.47)};
                \addplot[lru4] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84960.61) (12, 86672.97) (13, 86011.06) (14, 86711.04)};
                \addplot[sortlru4] coordinates
                    {(0, 63127.46) (1, 68682.75) (2, 78473.26) (3, 77103.49) (4, 83694.59) (5, 88463.72) (6, 107832.16) (7, 180258.68) (8, 315150.49) (9, 473159.93) (10, 598991.63) (11, 739936.15) (12, 777531.48) (13, 858993.74) (14, 882949.16)};
                \addplot[mru] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84120.15) (12, 84209.9) (13, 82220.8) (14, 84308.15)};
                \addplot[slru] coordinates
                    {(0, 13402.45) (1, 15332.79) (2, 19091.10) (3, 20393.00) (4, 20936.46) (5, 21244.53) (6, 25357.14) (7, 31599.02) (8, 37830.23) (9, 44057.08) (10, 46947.98) (11, 50071.23) (12, 51500.64) (13, 53447.12) (14, 54257.82)};
                \addplot[clock] coordinates
                    {(0, 65678.66) (1, 72894.37) (2, 85667.66) (3, 84846.12) (4, 89550.02) (5, 96966.58) (6, 124674.78) (7, 190359.77) (8, 338885.12) (9, 533097.44) (10, 640107.58) (11, 715927.50) (12, 764376.33) (13, 842440.18) (14, 882630.35)};
                \addplot[zclock] coordinates
                    {(0, 67089.83) (1, 74312.65) (2, 82556.26) (3, 84335.27) (4, 91521.58) (5, 96157.15) (6, 127058.42) (7, 195286.30) (8, 357803.60) (9, 600725.43) (10, 752314.59) (11, 823610.82) (12, 825660.26) (13, 838551.86) (14, 883868.08)};
                \addplot[gclockv1] coordinates
                    {(0, 65985.5) (1, 71670.36) (2, 81120.23) (3, 83754.09) (4, 88586.7) (5, 91878.85) (6, 115534.43) (7, 169758.58) (8, 259078.92) (9, 364973.12) (10, 476421.55) (11, 623180.22) (12, 680851.59) (13, 808326.82) (14, 884063.26)};
                \addplot[gclockv2] coordinates
                    {(0, 66780.15) (1, 72606.22) (2, 84203.25) (3, 85249.95) (4, 92069.45) (5, 95650.98) (6, 124270.01) (7, 191930.1) (8, 339709.17) (9, 534815.88) (10, 636412.55) (11, 717717.52) (12, 768695.31) (13, 844940.89) (14, 886769.52)};
                \addplot[dgclockv1] coordinates
                    {(0, 70770.81) (1, 74870.39) (2, 85946.24) (3, 84744.89) (4, 94621.84) (5, 98730.43) (6, 151594.61) (7, 407812.34) (8, 554634.31) (9, 594609.18) (10, 659508.56) (11, 604424.98) (12, 642017.59) (13, 814471.03) (14, 882040.53)};
                \addplot[dgclockv2] coordinates
                    {(0, 70867.89) (1, 75135.04) (2, 84387.36) (3, 84586.89) (4, 94341.66) (5, 99901.39) (6, 161242.15) (7, 396884.09) (8, 548662.03) (9, 611189.58) (10, 667182.23) (11, 596007.58) (12, 646545.42) (13, 814066.86) (14, 882166.96)};
                \addplot[lrdv1] coordinates
                    {(0, 16802.02) (1, 14567.02) (2, 12053.83) (3, 10497.18) (4, 9282.41) (5, 8946.49) (6, 9743.06) (7, 13860.95) (8, 24747.11) (9, 50450.68) (10, 101250.48) (11, 312698.28) (12, 569124.09) (13, 827709.37) (14, 878254.20)};
                \addplot[lrdv2] coordinates
                    {(0, 22062.91) (1, 22131.36) (2, 23944.26) (3, 21285.87) (4, 18076.78) (5, 16143.02) (6, 13939.54) (7, 18816.72) (8, 28985.49) (9, 51747.98) (10, 101608.66) (11, 315660.85) (12, 568795.71) (13, 827285.71) (14, 880416.58)};
                \addplot[lfu] coordinates
                    {(0, 0) (1, 10554.92) (2, 11709.01) (3, 12796.65) (4, 13582.12) (5, 14465.79) (6, 18056.65) (7, 28936.50) (8, 55856.34) (9, 101187.86) (10, 161100.70) (11, 356256.86) (12, 579274.70) (13, 786046.87) (14, 884339.71)};
                \addplot[lfuda] coordinates
                    {(0, 39490.59) (1, 38559.21) (2, 44340.21) (3, 41994.75) (4, 40803.21) (5, 39486.79) (6, 38684.87) (7, 45408.72) (8, 71900.23) (9, 117297.55) (10, 183630.86) (11, 388916.49) (12, 609234.52) (13, 787808.90) (14, 888557.41)};
                \addplot[leanstore] coordinates
                    {(0, 0) (1, 51990.70) (2, 59001.01) (3, 57988.31) (4, 58094.99) (5, 59516.53) (6, 61902.71) (7, 67954.34) (8, 77876.77) (9, 99322.39) (10, 139482.88) (11, 336124.21) (12, 566436.28) (13, 691799.01) (14, 884049.78)};
            \end{axis}
        \end{tikzpicture} \\
        \begin{tikzpicture}
            \begin{axis}[ylabel = {tpm-C $\left[\si{1\per\minute}\right]$},
                         ymin = 0,
%                         ymax = 1000000,
                         xmin = 11.5,
                         xmax = 14.5,
                         xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
                         legend entries = {RANDOM, LOOP, Quasi-FIFO, FILO, List-LRU, Sorting-LRU, List-LRU-2, Sorting-LRU-2, List-LRU-3, Sorting-LRU-3, List-LRU-4, Sorting-LRU-4, MRU, SLRU, CLOCK, ZCLOCK, GCLOCK-V1, GCLOCK-V2, DGCLOCK-V1, DGCLOCK-V2, LRD-V1, LRD-V2, LFU, LFUDA, {LeanStore\footnotemark}},
                         legend style = {font = \scriptsize,
                                         legend columns = 5,
                                         /tikz/every even column/.append style = {column sep = 0.0625cm},
                                         at = {(1, -0.35)},
                                         anchor = north east}]
                \addplot[random] coordinates
                    {(0, 66369.56) (1, 74553.61) (2, 81580.19) (3, 84328.74) (4, 93443.81) (5, 96880.01) (6, 125655.94) (7, 193685.35) (8, 345966.01) (9, 575737.3) (10, 745879.28) (11, 817851.23) (12, 825045.18) (13, 845368.47) (14, 883277.13)};
                \addplot[loop] coordinates
                    {(0, 70949.02) (1, 76608.40) (2, 84705.71) (3, 84816.29) (4, 93083.19) (5, 98612.02) (6, 146284.34) (7, 384662.18) (8, 536950.54) (9, 606275.16) (10, 651359.91) (11, 591419.60) (12, 651098.14) (13, 823777.55) (14, 885986.48)};
                \addplot[fifo] coordinates
                    {(0, 55342.01) (1, 42729.60) (2, 51566.13) (3, 57120.30) (4, 60370.71) (5, 8609.85) (6, 106818.15) (7, 222701.79) (8, 279046.76) (9, 318109.17) (10, 331681.30) (11, 595590.41) (12, 784744.71) (13, 861913.74) (14, 884801.25)};
                \addplot[filo] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 46523.96) (4, 56177.01) (5, 59666.59) (6, 68746.37) (7, 78524.20) (8, 100404.14) (9, 149804.57) (10, 254821.20) (11, 458817.84) (12, 637358.41) (13, 78369.27) (14, 882267.65)};
                \addplot[lru] coordinates
                    {(0, 18872.5) (1, 20487.22) (2, 23493.87) (3, 25443.28) (4, 25363.94) (5, 26448.21) (6, 31662.27) (7, 38523.47) (8, 44474.03) (9, 48070.75) (10, 51950.79) (11, 50384.85) (12, 49954.97) (13, 50575.8) (14, 50985.66)};
                \addplot[sortlru] coordinates
                    {(0, 66169.01) (1, 72628.41) (2, 84543.77) (3, 83889.85) (4, 91245.69) (5, 95589.83) (6, 126811.64) (7, 203740.37) (8, 375183.95) (9, 626535.64) (10, 743556.02) (11, 777533.02) (12, 787522.38) (13, 847635.07) (14, 882705.81)};
                \addplot[lru2] coordinates
                    {(0, 15812.95) (1, 17944.83) (2, 21143.24) (3, 0) (4, 23452.72) (5, 25635.11) (6, 0) (7, 0) (8, 68746.79) (9, 83182.4) (10, 90084.7) (11, 93021.16) (12, 93137.77) (13, 93771.43) (14, 91993.28)};
                \addplot[sortlru2] coordinates
                    {(0, 62385.85) (1, 65275.15) (2, 78600.64) (3, 79605.18) (4, 86114.27) (5, 90094.68) (6, 117201.16) (7, 190744.92) (8, 353618.74) (9, 521591.87) (10, 609571.14) (11, 750886.95) (12, 779378.88) (13, 853401.18) (14, 882643.03)};
                \addplot[lru3] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 88825.75) (12, 88439.05) (13, 90132.13) (14, 87919.7)};
                \addplot[sortlru3] coordinates
                    {(0, 63298.64) (1, 67242.07) (2, 77184.52) (3, 78231.77) (4, 83545.09) (5, 86892.65) (6, 120019.75) (7, 190695.96) (8, 332174.36) (9, 502105.23) (10, 582070.58) (11, 744621.44) (12, 780863.00) (13, 858186.76) (14, 885356.47)};
                \addplot[lru4] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84960.61) (12, 86672.97) (13, 86011.06) (14, 86711.04)};
                \addplot[sortlru4] coordinates
                    {(0, 63127.46) (1, 68682.75) (2, 78473.26) (3, 77103.49) (4, 83694.59) (5, 88463.72) (6, 107832.16) (7, 180258.68) (8, 315150.49) (9, 473159.93) (10, 598991.63) (11, 739936.15) (12, 777531.48) (13, 858993.74) (14, 882949.16)};
                \addplot[mru] coordinates
                    {(0, 0) (1, 0) (2, 0) (3, 0) (4, 0) (5, 0) (6, 0) (7, 0) (8, 0) (9, 0) (10, 0) (11, 84120.15) (12, 84209.9) (13, 82220.8) (14, 84308.15)};
                \addplot[slru] coordinates
                    {(0, 13402.45) (1, 15332.79) (2, 19091.10) (3, 20393.00) (4, 20936.46) (5, 21244.53) (6, 25357.14) (7, 31599.02) (8, 37830.23) (9, 44057.08) (10, 46947.98) (11, 50071.23) (12, 51500.64) (13, 53447.12) (14, 54257.82)};
                \addplot[clock] coordinates
                    {(0, 65678.66) (1, 72894.37) (2, 85667.66) (3, 84846.12) (4, 89550.02) (5, 96966.58) (6, 124674.78) (7, 190359.77) (8, 338885.12) (9, 533097.44) (10, 640107.58) (11, 715927.50) (12, 764376.33) (13, 842440.18) (14, 882630.35)};
                \addplot[zclock] coordinates
                    {(0, 67089.83) (1, 74312.65) (2, 82556.26) (3, 84335.27) (4, 91521.58) (5, 96157.15) (6, 127058.42) (7, 195286.30) (8, 357803.60) (9, 600725.43) (10, 752314.59) (11, 823610.82) (12, 825660.26) (13, 838551.86) (14, 883868.08)};
                \addplot[gclockv1] coordinates
                    {(0, 65985.5) (1, 71670.36) (2, 81120.23) (3, 83754.09) (4, 88586.7) (5, 91878.85) (6, 115534.43) (7, 169758.58) (8, 259078.92) (9, 364973.12) (10, 476421.55) (11, 623180.22) (12, 680851.59) (13, 808326.82) (14, 884063.26)};
                \addplot[gclockv2] coordinates
                    {(0, 66780.15) (1, 72606.22) (2, 84203.25) (3, 85249.95) (4, 92069.45) (5, 95650.98) (6, 124270.01) (7, 191930.1) (8, 339709.17) (9, 534815.88) (10, 636412.55) (11, 717717.52) (12, 768695.31) (13, 844940.89) (14, 886769.52)};
                \addplot[dgclockv1] coordinates
                    {(0, 70770.81) (1, 74870.39) (2, 85946.24) (3, 84744.89) (4, 94621.84) (5, 98730.43) (6, 151594.61) (7, 407812.34) (8, 554634.31) (9, 594609.18) (10, 659508.56) (11, 604424.98) (12, 642017.59) (13, 814471.03) (14, 882040.53)};
                \addplot[dgclockv2] coordinates
                    {(0, 70867.89) (1, 75135.04) (2, 84387.36) (3, 84586.89) (4, 94341.66) (5, 99901.39) (6, 161242.15) (7, 396884.09) (8, 548662.03) (9, 611189.58) (10, 667182.23) (11, 596007.58) (12, 646545.42) (13, 814066.86) (14, 882166.96)};
                \addplot[lrdv1] coordinates
                    {(0, 16802.02) (1, 14567.02) (2, 12053.83) (3, 10497.18) (4, 9282.41) (5, 8946.49) (6, 9743.06) (7, 13860.95) (8, 24747.11) (9, 50450.68) (10, 101250.48) (11, 312698.28) (12, 569124.09) (13, 827709.37) (14, 878254.20)};
                \addplot[lrdv2] coordinates
                    {(0, 22062.91) (1, 22131.36) (2, 23944.26) (3, 21285.87) (4, 18076.78) (5, 16143.02) (6, 13939.54) (7, 18816.72) (8, 28985.49) (9, 51747.98) (10, 101608.66) (11, 315660.85) (12, 568795.71) (13, 827285.71) (14, 880416.58)};
                \addplot[lfu] coordinates
                    {(0, 0) (1, 10554.92) (2, 11709.01) (3, 12796.65) (4, 13582.12) (5, 14465.79) (6, 18056.65) (7, 28936.50) (8, 55856.34) (9, 101187.86) (10, 161100.70) (11, 356256.86) (12, 579274.70) (13, 786046.87) (14, 884339.71)};
                \addplot[lfuda] coordinates
                    {(0, 39490.59) (1, 38559.21) (2, 44340.21) (3, 41994.75) (4, 40803.21) (5, 39486.79) (6, 38684.87) (7, 45408.72) (8, 71900.23) (9, 117297.55) (10, 183630.86) (11, 388916.49) (12, 609234.52) (13, 787808.90) (14, 888557.41)};
                \addplot[leanstore] coordinates
                    {(0, 0) (1, 51990.70) (2, 59001.01) (3, 57988.31) (4, 58094.99) (5, 59516.53) (6, 61902.71) (7, 67954.34) (8, 77876.77) (9, 99322.39) (10, 139482.88) (11, 336124.21) (12, 566436.28) (13, 691799.01) (14, 884049.78)};
            \end{axis}
        \end{tikzpicture}
        \vspace{-.5em}
        \caption[]{Transaction throughput of the page replacement algorithms from section \ref{sec:page_replacement_strategies} for the \textit{TPC-C} benchmark on 100 warehouses (continued)}
        \label{fig:throughput2}
    \end{figure}

    \begin{figure}[h!]
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         xmin = -0.5,
                         xmax = 2.5,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[random] coordinates
                    {(0, 77.1) (1, 80.01) (2, 83.7) (3, 86.42) (4, 88.47) (5, 90.22) (6, 94.92) (7, 97.4) (8, 98.67) (9, 99.33) (10, 99.64) (11, 99.82) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[loop] coordinates
                    {(0, 77.28) (1, 80.63) (2, 85.17) (3, 87.82) (4, 90.07) (5, 91.68) (6, 95.68) (7, 98.66) (8, 99.15) (9, 99.44) (10, 99.61) (11, 99.72) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[fifo] coordinates
                    {(0, 78.67) (1, 76.84) (2, 78.94) (3, 81.42) (4, 82.51) (5, 86.02) (6, 88.39) (7, 92.55) (8, 94.18) (9, 95.63) (10, 96.66) (11, 99.43) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[filo] coordinates
                    {(3, 83.77) (4, 85.89) (5, 87.11) (6, 90.48) (7, 94.72) (8, 98.03) (9, 99.38) (10, 99.7) (11, 99.81) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[lru] coordinates
                    {(0, 81.33) (1, 83.66) (2, 86.69) (3, 89.08) (4, 90.76) (5, 92.02) (6, 95.67) (7, 97.48) (8, 98.49) (9, 99.05) (10, 99.16) (11, 99.14) (12, 99.13) (13, 99.14) (14, 99.15)};
                \addplot[sortlru] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru2] coordinates
                    {(0, 77.97) (1, 80.74) (2, 84.19) (4, 87.66) (5, 88.74) (8, 98.58) (9, 99.23) (10, 99.44) (11, 99.46) (12, 99.46) (13, 99.46) (14, 99.45)};
                \addplot[sortlru2] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru3] coordinates
                    {(11, 99.44) (12, 99.44) (13, 99.45) (14, 99.43)};
                \addplot[sortlru3] coordinates
                    {(0, 80.75) (1, 84.79) (2, 88.67) (3, 90.25) (4, 91.46) (5, 92.51) (6, 95.86) (7, 97.75) (8, 98.8) (9, 99.4) (10, 99.69) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[lru4] coordinates
                    {(11, 99.42) (12, 99.43) (13, 99.42) (14, 99.43)};
                \addplot[sortlru4] coordinates
                    {(0, 80.64) (1, 84.63) (2, 88.7) (3, 90.22) (4, 91.43) (5, 92.48) (6, 95.89) (7, 97.74) (8, 98.8) (9, 99.41) (10, 99.68) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[mru] coordinates
                    {(11, 99.42) (12, 99.42) (13, 99.41) (14, 99.43)};
                \addplot[slru] coordinates
                    {(0, 80.44) (1, 83.49) (2, 86.87) (3, 89.15) (4, 90.8) (5, 92.04) (6, 95.63) (7, 97.45) (8, 98.43) (9, 98.99) (10, 99.08) (11, 99.12) (12, 99.14) (13, 99.17) (14, 99.18)};
                \addplot[clock] coordinates
                    {(0, 78.22) (1, 81.2) (2, 85.63) (3, 88.86) (4, 90.74) (5, 92.12) (6, 95.66) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[zclock] coordinates
                    {(0, 78.57) (1, 81.57) (2, 85.66) (3, 88.42) (4, 90.25) (5, 91.72) (6, 95.57) (7, 97.65) (8, 98.77) (9, 99.36) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[gclockv1] coordinates
                    {(0, 80.53) (1, 84.18) (2, 88.38) (3, 90.1) (4, 91.19) (5, 92.13) (6, 95.36) (7, 97.28) (8, 98.36) (9, 99.08) (10, 99.47) (11, 99.75) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[gclockv2] coordinates
                    {(0, 78.22) (1, 81.22) (2, 85.64) (3, 88.87) (4, 90.76) (5, 92.12) (6, 95.67) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv1] coordinates
                    {(0, 77.37) (1, 80.72) (2, 85.24) (3, 87.88) (4, 90.07) (5, 91.71) (6, 95.79) (7, 98.71) (8, 99.15) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv2] coordinates
                    {(0, 77.35) (1, 80.74) (2, 85.23) (3, 87.81) (4, 90.07) (5, 91.68) (6, 95.97) (7, 98.67) (8, 99.14) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[lrdv1] coordinates
                    {(0, 81.09) (1, 85.83) (2, 88.77) (3, 90.07) (4, 91.12) (5, 92.08) (6, 95.43) (7, 97.2) (8, 98.3) (9, 99.06) (10, 99.47) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lrdv2] coordinates
                    {(0, 82.13) (1, 86.05) (2, 88.86) (3, 90.26) (4, 91.39) (5, 92.34) (6, 95.65) (7, 97.29) (8, 98.27) (9, 99) (10, 99.44) (11, 99.76) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfu] coordinates
                    {(1, 84.1) (2, 87.53) (3, 89.26) (4, 90.71) (5, 91.85) (6, 95.14) (7, 97.58) (8, 98.72) (9, 99.26) (10, 99.54) (11, 99.78) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfuda] coordinates
                    {(0, 78.51) (1, 82.89) (2, 88.26) (3, 89.49) (4, 90.53) (5, 91.49) (6, 95.29) (7, 97.58) (8, 98.71) (9, 99.27) (10, 99.55) (11, 99.78) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[leanstore] coordinates
                    {(1, 86.59) (2, 88.62) (3, 89.93) (4, 90.95) (5, 91.82) (6, 94.59) (7, 97.12) (8, 98.35) (9, 99.11) (10, 99.5) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
            \end{axis}
        \end{tikzpicture} \\
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         xmin = 2.5,
                         xmax = 5.5,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[random] coordinates
                    {(0, 77.1) (1, 80.01) (2, 83.7) (3, 86.42) (4, 88.47) (5, 90.22) (6, 94.92) (7, 97.4) (8, 98.67) (9, 99.33) (10, 99.64) (11, 99.82) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[loop] coordinates
                    {(0, 77.28) (1, 80.63) (2, 85.17) (3, 87.82) (4, 90.07) (5, 91.68) (6, 95.68) (7, 98.66) (8, 99.15) (9, 99.44) (10, 99.61) (11, 99.72) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[fifo] coordinates
                    {(0, 78.67) (1, 76.84) (2, 78.94) (3, 81.42) (4, 82.51) (5, 86.02) (6, 88.39) (7, 92.55) (8, 94.18) (9, 95.63) (10, 96.66) (11, 99.43) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[filo] coordinates
                    {(3, 83.77) (4, 85.89) (5, 87.11) (6, 90.48) (7, 94.72) (8, 98.03) (9, 99.38) (10, 99.7) (11, 99.81) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[lru] coordinates
                    {(0, 81.33) (1, 83.66) (2, 86.69) (3, 89.08) (4, 90.76) (5, 92.02) (6, 95.67) (7, 97.48) (8, 98.49) (9, 99.05) (10, 99.16) (11, 99.14) (12, 99.13) (13, 99.14) (14, 99.15)};
                \addplot[sortlru] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru2] coordinates
                    {(0, 77.97) (1, 80.74) (2, 84.19) (4, 87.66) (5, 88.74) (8, 98.58) (9, 99.23) (10, 99.44) (11, 99.46) (12, 99.46) (13, 99.46) (14, 99.45)};
                \addplot[sortlru2] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru3] coordinates
                    {(11, 99.44) (12, 99.44) (13, 99.45) (14, 99.43)};
                \addplot[sortlru3] coordinates
                    {(0, 80.75) (1, 84.79) (2, 88.67) (3, 90.25) (4, 91.46) (5, 92.51) (6, 95.86) (7, 97.75) (8, 98.8) (9, 99.4) (10, 99.69) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[lru4] coordinates
                    {(11, 99.42) (12, 99.43) (13, 99.42) (14, 99.43)};
                \addplot[sortlru4] coordinates
                    {(0, 80.64) (1, 84.63) (2, 88.7) (3, 90.22) (4, 91.43) (5, 92.48) (6, 95.89) (7, 97.74) (8, 98.8) (9, 99.41) (10, 99.68) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[mru] coordinates
                    {(11, 99.42) (12, 99.42) (13, 99.41) (14, 99.43)};
                \addplot[slru] coordinates
                    {(0, 80.44) (1, 83.49) (2, 86.87) (3, 89.15) (4, 90.8) (5, 92.04) (6, 95.63) (7, 97.45) (8, 98.43) (9, 98.99) (10, 99.08) (11, 99.12) (12, 99.14) (13, 99.17) (14, 99.18)};
                \addplot[clock] coordinates
                    {(0, 78.22) (1, 81.2) (2, 85.63) (3, 88.86) (4, 90.74) (5, 92.12) (6, 95.66) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[zclock] coordinates
                    {(0, 78.57) (1, 81.57) (2, 85.66) (3, 88.42) (4, 90.25) (5, 91.72) (6, 95.57) (7, 97.65) (8, 98.77) (9, 99.36) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[gclockv1] coordinates
                    {(0, 80.53) (1, 84.18) (2, 88.38) (3, 90.1) (4, 91.19) (5, 92.13) (6, 95.36) (7, 97.28) (8, 98.36) (9, 99.08) (10, 99.47) (11, 99.75) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[gclockv2] coordinates
                    {(0, 78.22) (1, 81.22) (2, 85.64) (3, 88.87) (4, 90.76) (5, 92.12) (6, 95.67) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv1] coordinates
                    {(0, 77.37) (1, 80.72) (2, 85.24) (3, 87.88) (4, 90.07) (5, 91.71) (6, 95.79) (7, 98.71) (8, 99.15) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv2] coordinates
                    {(0, 77.35) (1, 80.74) (2, 85.23) (3, 87.81) (4, 90.07) (5, 91.68) (6, 95.97) (7, 98.67) (8, 99.14) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[lrdv1] coordinates
                    {(0, 81.09) (1, 85.83) (2, 88.77) (3, 90.07) (4, 91.12) (5, 92.08) (6, 95.43) (7, 97.2) (8, 98.3) (9, 99.06) (10, 99.47) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lrdv2] coordinates
                    {(0, 82.13) (1, 86.05) (2, 88.86) (3, 90.26) (4, 91.39) (5, 92.34) (6, 95.65) (7, 97.29) (8, 98.27) (9, 99) (10, 99.44) (11, 99.76) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfu] coordinates
                    {(1, 84.1) (2, 87.53) (3, 89.26) (4, 90.71) (5, 91.85) (6, 95.14) (7, 97.58) (8, 98.72) (9, 99.26) (10, 99.54) (11, 99.78) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfuda] coordinates
                    {(0, 78.51) (1, 82.89) (2, 88.26) (3, 89.49) (4, 90.53) (5, 91.49) (6, 95.29) (7, 97.58) (8, 98.71) (9, 99.27) (10, 99.55) (11, 99.78) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[leanstore] coordinates
                    {(1, 86.59) (2, 88.62) (3, 89.93) (4, 90.95) (5, 91.82) (6, 94.59) (7, 97.12) (8, 98.35) (9, 99.11) (10, 99.5) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
            \end{axis}
        \end{tikzpicture} \\
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         xmin = 5.5,
                         xmax = 8.5,
                         xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[random] coordinates
                    {(0, 77.1) (1, 80.01) (2, 83.7) (3, 86.42) (4, 88.47) (5, 90.22) (6, 94.92) (7, 97.4) (8, 98.67) (9, 99.33) (10, 99.64) (11, 99.82) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[loop] coordinates
                    {(0, 77.28) (1, 80.63) (2, 85.17) (3, 87.82) (4, 90.07) (5, 91.68) (6, 95.68) (7, 98.66) (8, 99.15) (9, 99.44) (10, 99.61) (11, 99.72) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[fifo] coordinates
                    {(0, 78.67) (1, 76.84) (2, 78.94) (3, 81.42) (4, 82.51) (5, 86.02) (6, 88.39) (7, 92.55) (8, 94.18) (9, 95.63) (10, 96.66) (11, 99.43) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[filo] coordinates
                    {(3, 83.77) (4, 85.89) (5, 87.11) (6, 90.48) (7, 94.72) (8, 98.03) (9, 99.38) (10, 99.7) (11, 99.81) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[lru] coordinates
                    {(0, 81.33) (1, 83.66) (2, 86.69) (3, 89.08) (4, 90.76) (5, 92.02) (6, 95.67) (7, 97.48) (8, 98.49) (9, 99.05) (10, 99.16) (11, 99.14) (12, 99.13) (13, 99.14) (14, 99.15)};
                \addplot[sortlru] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru2] coordinates
                    {(0, 77.97) (1, 80.74) (2, 84.19) (4, 87.66) (5, 88.74) (8, 98.58) (9, 99.23) (10, 99.44) (11, 99.46) (12, 99.46) (13, 99.46) (14, 99.45)};
                \addplot[sortlru2] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru3] coordinates
                    {(11, 99.44) (12, 99.44) (13, 99.45) (14, 99.43)};
                \addplot[sortlru3] coordinates
                    {(0, 80.75) (1, 84.79) (2, 88.67) (3, 90.25) (4, 91.46) (5, 92.51) (6, 95.86) (7, 97.75) (8, 98.8) (9, 99.4) (10, 99.69) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[lru4] coordinates
                    {(11, 99.42) (12, 99.43) (13, 99.42) (14, 99.43)};
                \addplot[sortlru4] coordinates
                    {(0, 80.64) (1, 84.63) (2, 88.7) (3, 90.22) (4, 91.43) (5, 92.48) (6, 95.89) (7, 97.74) (8, 98.8) (9, 99.41) (10, 99.68) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[mru] coordinates
                    {(11, 99.42) (12, 99.42) (13, 99.41) (14, 99.43)};
                \addplot[slru] coordinates
                    {(0, 80.44) (1, 83.49) (2, 86.87) (3, 89.15) (4, 90.8) (5, 92.04) (6, 95.63) (7, 97.45) (8, 98.43) (9, 98.99) (10, 99.08) (11, 99.12) (12, 99.14) (13, 99.17) (14, 99.18)};
                \addplot[clock] coordinates
                    {(0, 78.22) (1, 81.2) (2, 85.63) (3, 88.86) (4, 90.74) (5, 92.12) (6, 95.66) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[zclock] coordinates
                    {(0, 78.57) (1, 81.57) (2, 85.66) (3, 88.42) (4, 90.25) (5, 91.72) (6, 95.57) (7, 97.65) (8, 98.77) (9, 99.36) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[gclockv1] coordinates
                    {(0, 80.53) (1, 84.18) (2, 88.38) (3, 90.1) (4, 91.19) (5, 92.13) (6, 95.36) (7, 97.28) (8, 98.36) (9, 99.08) (10, 99.47) (11, 99.75) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[gclockv2] coordinates
                    {(0, 78.22) (1, 81.22) (2, 85.64) (3, 88.87) (4, 90.76) (5, 92.12) (6, 95.67) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv1] coordinates
                    {(0, 77.37) (1, 80.72) (2, 85.24) (3, 87.88) (4, 90.07) (5, 91.71) (6, 95.79) (7, 98.71) (8, 99.15) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv2] coordinates
                    {(0, 77.35) (1, 80.74) (2, 85.23) (3, 87.81) (4, 90.07) (5, 91.68) (6, 95.97) (7, 98.67) (8, 99.14) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[lrdv1] coordinates
                    {(0, 81.09) (1, 85.83) (2, 88.77) (3, 90.07) (4, 91.12) (5, 92.08) (6, 95.43) (7, 97.2) (8, 98.3) (9, 99.06) (10, 99.47) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lrdv2] coordinates
                    {(0, 82.13) (1, 86.05) (2, 88.86) (3, 90.26) (4, 91.39) (5, 92.34) (6, 95.65) (7, 97.29) (8, 98.27) (9, 99) (10, 99.44) (11, 99.76) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfu] coordinates
                    {(1, 84.1) (2, 87.53) (3, 89.26) (4, 90.71) (5, 91.85) (6, 95.14) (7, 97.58) (8, 98.72) (9, 99.26) (10, 99.54) (11, 99.78) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfuda] coordinates
                    {(0, 78.51) (1, 82.89) (2, 88.26) (3, 89.49) (4, 90.53) (5, 91.49) (6, 95.29) (7, 97.58) (8, 98.71) (9, 99.27) (10, 99.55) (11, 99.78) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[leanstore] coordinates
                    {(1, 86.59) (2, 88.62) (3, 89.93) (4, 90.95) (5, 91.82) (6, 94.59) (7, 97.12) (8, 98.35) (9, 99.11) (10, 99.5) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
            \end{axis}
        \end{tikzpicture}
%        \vspace{-.5em}
        \caption[Miss rates of different page eviction algorithms]{Miss rates of the page replacement algorithms from section \ref{sec:page_replacement_strategies} for the \textit{TPC-C} benchmark on 100 warehouses}
        \label{fig:hitrate1}
    \end{figure}

    \begin{figure}[h!]\ContinuedFloat
        \centering
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         xmin = 8.5,
                         xmax = 11.5,
                         y coord trafo/.code = {
                             \pgfmathparse{100 - #1}
                             \pgfmathresult
                         }]
                \addplot[random] coordinates
                    {(0, 77.1) (1, 80.01) (2, 83.7) (3, 86.42) (4, 88.47) (5, 90.22) (6, 94.92) (7, 97.4) (8, 98.67) (9, 99.33) (10, 99.64) (11, 99.82) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[loop] coordinates
                    {(0, 77.28) (1, 80.63) (2, 85.17) (3, 87.82) (4, 90.07) (5, 91.68) (6, 95.68) (7, 98.66) (8, 99.15) (9, 99.44) (10, 99.61) (11, 99.72) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[fifo] coordinates
                    {(0, 78.67) (1, 76.84) (2, 78.94) (3, 81.42) (4, 82.51) (5, 86.02) (6, 88.39) (7, 92.55) (8, 94.18) (9, 95.63) (10, 96.66) (11, 99.43) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[filo] coordinates
                    {(3, 83.77) (4, 85.89) (5, 87.11) (6, 90.48) (7, 94.72) (8, 98.03) (9, 99.38) (10, 99.7) (11, 99.81) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[lru] coordinates
                    {(0, 81.33) (1, 83.66) (2, 86.69) (3, 89.08) (4, 90.76) (5, 92.02) (6, 95.67) (7, 97.48) (8, 98.49) (9, 99.05) (10, 99.16) (11, 99.14) (12, 99.13) (13, 99.14) (14, 99.15)};
                \addplot[sortlru] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru2] coordinates
                    {(0, 77.97) (1, 80.74) (2, 84.19) (4, 87.66) (5, 88.74) (8, 98.58) (9, 99.23) (10, 99.44) (11, 99.46) (12, 99.46) (13, 99.46) (14, 99.45)};
                \addplot[sortlru2] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru3] coordinates
                    {(11, 99.44) (12, 99.44) (13, 99.45) (14, 99.43)};
                \addplot[sortlru3] coordinates
                    {(0, 80.75) (1, 84.79) (2, 88.67) (3, 90.25) (4, 91.46) (5, 92.51) (6, 95.86) (7, 97.75) (8, 98.8) (9, 99.4) (10, 99.69) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[lru4] coordinates
                    {(11, 99.42) (12, 99.43) (13, 99.42) (14, 99.43)};
                \addplot[sortlru4] coordinates
                    {(0, 80.64) (1, 84.63) (2, 88.7) (3, 90.22) (4, 91.43) (5, 92.48) (6, 95.89) (7, 97.74) (8, 98.8) (9, 99.41) (10, 99.68) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[mru] coordinates
                    {(11, 99.42) (12, 99.42) (13, 99.41) (14, 99.43)};
                \addplot[slru] coordinates
                    {(0, 80.44) (1, 83.49) (2, 86.87) (3, 89.15) (4, 90.8) (5, 92.04) (6, 95.63) (7, 97.45) (8, 98.43) (9, 98.99) (10, 99.08) (11, 99.12) (12, 99.14) (13, 99.17) (14, 99.18)};
                \addplot[clock] coordinates
                    {(0, 78.22) (1, 81.2) (2, 85.63) (3, 88.86) (4, 90.74) (5, 92.12) (6, 95.66) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[zclock] coordinates
                    {(0, 78.57) (1, 81.57) (2, 85.66) (3, 88.42) (4, 90.25) (5, 91.72) (6, 95.57) (7, 97.65) (8, 98.77) (9, 99.36) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[gclockv1] coordinates
                    {(0, 80.53) (1, 84.18) (2, 88.38) (3, 90.1) (4, 91.19) (5, 92.13) (6, 95.36) (7, 97.28) (8, 98.36) (9, 99.08) (10, 99.47) (11, 99.75) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[gclockv2] coordinates
                    {(0, 78.22) (1, 81.22) (2, 85.64) (3, 88.87) (4, 90.76) (5, 92.12) (6, 95.67) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv1] coordinates
                    {(0, 77.37) (1, 80.72) (2, 85.24) (3, 87.88) (4, 90.07) (5, 91.71) (6, 95.79) (7, 98.71) (8, 99.15) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv2] coordinates
                    {(0, 77.35) (1, 80.74) (2, 85.23) (3, 87.81) (4, 90.07) (5, 91.68) (6, 95.97) (7, 98.67) (8, 99.14) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[lrdv1] coordinates
                    {(0, 81.09) (1, 85.83) (2, 88.77) (3, 90.07) (4, 91.12) (5, 92.08) (6, 95.43) (7, 97.2) (8, 98.3) (9, 99.06) (10, 99.47) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lrdv2] coordinates
                    {(0, 82.13) (1, 86.05) (2, 88.86) (3, 90.26) (4, 91.39) (5, 92.34) (6, 95.65) (7, 97.29) (8, 98.27) (9, 99) (10, 99.44) (11, 99.76) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfu] coordinates
                    {(1, 84.1) (2, 87.53) (3, 89.26) (4, 90.71) (5, 91.85) (6, 95.14) (7, 97.58) (8, 98.72) (9, 99.26) (10, 99.54) (11, 99.78) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfuda] coordinates
                    {(0, 78.51) (1, 82.89) (2, 88.26) (3, 89.49) (4, 90.53) (5, 91.49) (6, 95.29) (7, 97.58) (8, 98.71) (9, 99.27) (10, 99.55) (11, 99.78) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[leanstore] coordinates
                    {(1, 86.59) (2, 88.62) (3, 89.93) (4, 90.95) (5, 91.82) (6, 94.59) (7, 97.12) (8, 98.35) (9, 99.11) (10, 99.5) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
            \end{axis}
        \end{tikzpicture} \\
        \begin{tikzpicture}
            \begin{axis}[ylabel = {$\text{Miss rate }\left[\si{\percent}\right]$},
                         ymode = normal,
                         ymin = 100,
                         xmin = 11.5,
                         xmax = 14.5,
                         xlabel = {Buffer pool size (DB size: Initially \SI{\approx 14.3}{\gibi\byte} but increasing to \SI{< 30}{\gibi\byte})},
                         legend entries = {RANDOM, LOOP, Quasi-FIFO, FILO, List-LRU, Sorting-LRU, List-LRU-2, Sorting-LRU-2, List-LRU-3, Sorting-LRU-3, List-LRU-4, Sorting-LRU-4, MRU, SLRU, CLOCK, ZCLOCK, GCLOCK-V1, GCLOCK-V2, DGCLOCK-V1, DGCLOCK-V2, LRD-V1, LRD-V2, LFU, LFUDA, {LeanStore\footnotemark[\value{footnote}]}},
                         legend style = {font = \scriptsize,
                                         legend columns = 5,
                                         /tikz/every even column/.append style = {column sep = 0.0625cm},
                                         at = {(1, -0.35)},
                                         anchor = north east},
                         y coord trafo/.code = {
                            \pgfmathparse{100 - #1}
                            \pgfmathresult
                         }]
                \addplot[random] coordinates
                    {(0, 77.1) (1, 80.01) (2, 83.7) (3, 86.42) (4, 88.47) (5, 90.22) (6, 94.92) (7, 97.4) (8, 98.67) (9, 99.33) (10, 99.64) (11, 99.82) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[loop] coordinates
                    {(0, 77.28) (1, 80.63) (2, 85.17) (3, 87.82) (4, 90.07) (5, 91.68) (6, 95.68) (7, 98.66) (8, 99.15) (9, 99.44) (10, 99.61) (11, 99.72) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[fifo] coordinates
                    {(0, 78.67) (1, 76.84) (2, 78.94) (3, 81.42) (4, 82.51) (5, 86.02) (6, 88.39) (7, 92.55) (8, 94.18) (9, 95.63) (10, 96.66) (11, 99.43) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[filo] coordinates
                    {(3, 83.77) (4, 85.89) (5, 87.11) (6, 90.48) (7, 94.72) (8, 98.03) (9, 99.38) (10, 99.7) (11, 99.81) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[lru] coordinates
                    {(0, 81.33) (1, 83.66) (2, 86.69) (3, 89.08) (4, 90.76) (5, 92.02) (6, 95.67) (7, 97.48) (8, 98.49) (9, 99.05) (10, 99.16) (11, 99.14) (12, 99.13) (13, 99.14) (14, 99.15)};
                \addplot[sortlru] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru2] coordinates
                    {(0, 77.97) (1, 80.74) (2, 84.19) (4, 87.66) (5, 88.74) (8, 98.58) (9, 99.23) (10, 99.44) (11, 99.46) (12, 99.46) (13, 99.46) (14, 99.45)};
                \addplot[sortlru2] coordinates
                    {(0, 78.96) (1, 81.95) (2, 86.38) (3, 89.24) (4, 90.92) (5, 92.24) (6, 95.73) (7, 97.64) (8, 98.74) (9, 99.36) (10, 99.68) (11, 99.85) (12, 99.86) (13, 99.86) (14, 99.86)};
                \addplot[lru3] coordinates
                    {(11, 99.44) (12, 99.44) (13, 99.45) (14, 99.43)};
                \addplot[sortlru3] coordinates
                    {(0, 80.75) (1, 84.79) (2, 88.67) (3, 90.25) (4, 91.46) (5, 92.51) (6, 95.86) (7, 97.75) (8, 98.8) (9, 99.4) (10, 99.69) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[lru4] coordinates
                    {(11, 99.42) (12, 99.43) (13, 99.42) (14, 99.43)};
                \addplot[sortlru4] coordinates
                    {(0, 80.64) (1, 84.63) (2, 88.7) (3, 90.22) (4, 91.43) (5, 92.48) (6, 95.89) (7, 97.74) (8, 98.8) (9, 99.41) (10, 99.68) (11, 99.84) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[mru] coordinates
                    {(11, 99.42) (12, 99.42) (13, 99.41) (14, 99.43)};
                \addplot[slru] coordinates
                    {(0, 80.44) (1, 83.49) (2, 86.87) (3, 89.15) (4, 90.8) (5, 92.04) (6, 95.63) (7, 97.45) (8, 98.43) (9, 98.99) (10, 99.08) (11, 99.12) (12, 99.14) (13, 99.17) (14, 99.18)};
                \addplot[clock] coordinates
                    {(0, 78.22) (1, 81.2) (2, 85.63) (3, 88.86) (4, 90.74) (5, 92.12) (6, 95.66) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[zclock] coordinates
                    {(0, 78.57) (1, 81.57) (2, 85.66) (3, 88.42) (4, 90.25) (5, 91.72) (6, 95.57) (7, 97.65) (8, 98.77) (9, 99.36) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[gclockv1] coordinates
                    {(0, 80.53) (1, 84.18) (2, 88.38) (3, 90.1) (4, 91.19) (5, 92.13) (6, 95.36) (7, 97.28) (8, 98.36) (9, 99.08) (10, 99.47) (11, 99.75) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[gclockv2] coordinates
                    {(0, 78.22) (1, 81.22) (2, 85.64) (3, 88.87) (4, 90.76) (5, 92.12) (6, 95.67) (7, 97.61) (8, 98.72) (9, 99.34) (10, 99.65) (11, 99.83) (12, 99.85) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv1] coordinates
                    {(0, 77.37) (1, 80.72) (2, 85.24) (3, 87.88) (4, 90.07) (5, 91.71) (6, 95.79) (7, 98.71) (8, 99.15) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[dgclockv2] coordinates
                    {(0, 77.35) (1, 80.74) (2, 85.23) (3, 87.81) (4, 90.07) (5, 91.68) (6, 95.97) (7, 98.67) (8, 99.14) (9, 99.4) (10, 99.59) (11, 99.71) (12, 99.82) (13, 99.86) (14, 99.86)};
                \addplot[lrdv1] coordinates
                    {(0, 81.09) (1, 85.83) (2, 88.77) (3, 90.07) (4, 91.12) (5, 92.08) (6, 95.43) (7, 97.2) (8, 98.3) (9, 99.06) (10, 99.47) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lrdv2] coordinates
                    {(0, 82.13) (1, 86.05) (2, 88.86) (3, 90.26) (4, 91.39) (5, 92.34) (6, 95.65) (7, 97.29) (8, 98.27) (9, 99) (10, 99.44) (11, 99.76) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfu] coordinates
                    {(1, 84.1) (2, 87.53) (3, 89.26) (4, 90.71) (5, 91.85) (6, 95.14) (7, 97.58) (8, 98.72) (9, 99.26) (10, 99.54) (11, 99.78) (12, 99.83) (13, 99.86) (14, 99.86)};
                \addplot[lfuda] coordinates
                    {(0, 78.51) (1, 82.89) (2, 88.26) (3, 89.49) (4, 90.53) (5, 91.49) (6, 95.29) (7, 97.58) (8, 98.71) (9, 99.27) (10, 99.55) (11, 99.78) (12, 99.84) (13, 99.86) (14, 99.86)};
                \addplot[leanstore] coordinates
                    {(1, 86.59) (2, 88.62) (3, 89.93) (4, 90.95) (5, 91.82) (6, 94.59) (7, 97.12) (8, 98.35) (9, 99.11) (10, 99.5) (11, 99.77) (12, 99.83) (13, 99.86) (14, 99.86)};
            \end{axis}
        \end{tikzpicture}
        \vspace{.5em}
        \caption[]{Miss rates of the page replacement algorithms from section \ref{sec:page_replacement_strategies} for the \textit{TPC-C} benchmark on 100 warehouses (continued)}
        \label{fig:hitrate2} 
    \end{figure}
\end{@empty}

    % TODO: Replace values for LeanStore!

    Figure \ref{fig:throughput1} shows the transaction throughput and figure \ref{fig:hitrate1} shows the miss rate achieved with all the evaluated page replacement algorithms for different buffer pool sizes.

    \nameref{subsec:filo}, \nameref{subsec:mru} and the \nameref{subsubsec:lru-k_traditional} implementation of \nameref{subsec:lru-k} do not work for small buffer pools. The latter two even stalled the DBS if the buffer pool is not large enough for the entire DB.

    The \nameref{subsubsec:lru_traditional} implementation of \nameref{subsec:lru}---called List-LRU here---and \nameref{subsec:slru} do not scale with respect to the \emph{transaction throughput}. For \emph{larger buffer pool sizes}, they perform \SI{\approx 94}{\percent} worse than the fastest competing page replacement algorithms. Their performance does not increase at all with buffer pool size for buffer pools \SI{>10}{\giga\byte}. They are also slower than most of the competition for \emph{smaller buffer pools}, but the gap is smaller---in both absolute and relative terms.

    For the buffer pool sizes where the \nameref{subsubsec:lru-k_traditional} implementation of \nameref{subsec:lru-k} works, List-LRU-2, List-LRU-3, and List-LRU-4 achieve almost twice the \emph{transaction throughput} as the \nameref{subsubsec:lru_traditional} implementation of \nameref{subsec:lru}. But even the fastest of the three variants---List-LRU-2---is almost \SI{90}{\percent} slower than most of the competition.

    \nameref{subsubsec:quasi-fifo} and \nameref{subsec:filo} are in the midrange for \emph{buffer pools smaller than the initial DB} in terms of \emph{transaction throughput}, but they are among the fastest page replacement algorithms when (almost) no pages are evicted. But both algorithms show \emph{random drops} in their \emph{transaction throughput}---\nameref{subsubsec:quasi-fifo} for a buffer pool with \SI{1}{\giga\byte} size and \nameref{subsec:filo} for one with \SI{25}{\giga\byte} size.

    For \emph{very small buffer pools} (\SI{\leq 1}{\giga\byte}), \nameref{subsec:lfu} is one of the slowest page replacement policies in the competition---\nameref{subsec:lfuda} is in the mid-range for these buffer pool sizes. Both policies are amongst the slowest for \emph{medium-sized buffer pools} (\SIrange{2}{20}{\giga\byte}) and amongst the fastest when the buffer pool has the size of the DB. \nameref{subsec:lfuda} is \emph{constantly faster} than \nameref{subsec:lfu}.

\footnotetext{LeanStore uses the pointer swizzling technique described in subsection \ref{subsec:looking_glass_swizzling}.}

    \nameref{subsubsec:lrd-v1} and \nameref{subsubsec:lrd-v2} perform very similar to \nameref{subsec:lfu} and \nameref{subsec:lfuda}, but they are consistently slower than at least the latter one.

    The \nameref{subsubsec:lru-k_timestamp} implementation of \nameref{subsec:lru-k}---here referred to as Sorting-LRU-2, Sorting-LRU-3, and Sorting-LRU-4---is almost one of the fastest page replacement policies in the competition. Except for the smallest buffer pool sizes, Sorting-LRU-2 is the fastest of the three.

    \nameref{subsec:random}, the \nameref{subsubsec:lru_timestamp} implementation of \nameref{subsec:lru}, \nameref{subsec:clock}, \nameref{subsec:zclock}, \nameref{subsubsec:gclock-v1} and \nameref{subsubsec:gclock-v2} are all among the fastest page replacement algorithms for \emph{most of the buffer pool sizes}. But the \nameref{subsec:fifo} implementation \nameref{subsubsec:loop} and \nameref{subsubsec:dgclock-v1} and \nameref{subsubsec:dgclock-v2} are almost twice as fast for \SI{4}{\giga\byte} and \SI{6}{\giga\byte} buffer pools.

    The \emph{transaction throughput} achieved with \nameref{subsec:leanstore} is for \emph{small buffer pools} of \SI{\leq 2}{\giga\byte} as decent as that of \nameref{subsubsec:quasi-fifo} and for \emph{larger buffer pools} as bad as that of \nameref{subsec:lfu}.

    Especially for \emph{smaller buffer pool sizes}, the \nameref{subsubsec:lru_traditional} implementation of \nameref{subsec:lru}, the \nameref{subsubsec:lru-k_timestamp} implementation of \nameref{subsec:lru-k}, \nameref{subsubsec:gclock-v1}, \nameref{subsubsec:lrd-v1} and \nameref{subsubsec:lrd-v2} achieve a lower \emph{miss rate} than the competition.

    For buffer pools smaller than \SI{4}{\giga\byte}, the \emph{miss rate} of \nameref{subsec:filo} is \SI{\approx 4}{\percent} higher than that of most competitors, and \nameref{subsubsec:quasi-fifo} maintains an even higher \emph{miss rate} for buffer pools of \SI{\leq 10}{\giga\byte} size. But once the \emph{initial DB fits in the buffer pool}, both algorithms are among the best in terms of \emph{miss rate}.

    The \emph{miss rates} achieved with most page replacement algorithms is below \SI{0.2}{\percent} once the \emph{DB fits in the buffer pool}. The responsible page misses are the result of cold starting the DBS---with an empty buffer pool---which is part of each \SI{10}{\minute} benchmark run used to gather this data. The page miss rates would converge for a continuously running system to \SI{0}{\percent}. The higher page miss rates of approximately \SI{0.9}{\percent} of the \nameref{subsubsec:lru_traditional} implementation of \nameref{subsec:lru}, the \nameref{subsubsec:lru-k_traditional} implementation of \nameref{subsec:lru-k}, \nameref{subsec:mru} and \nameref{subsec:slru} are the result of a lower total number of page fixes due to the lower transaction throughput achieved with these page replacement algorithms.

    % Consideration regarding cold start compensation:
    % - Simplest solution (used here): Let the DBS run for 10mins to reduce impact
    % - For DBs larger than the buffer: Reset fix/hit counters after first eviction -> fine
    % - For DBs smaller than the buffer: Reset counters once all pages are in the buffer -> there might be pages never accessed
    % - Use counter for evictions -> page fixes counted during cold start, but no potential evictions if the buffer pool wound not have been empty

\subsection{Analysis} \label{subsec:page_evictioners_analysis}

    The \nameref{subsubsec:lru_traditional} implementation of \nameref{subsec:lru}, the \nameref{subsubsec:lru-k_traditional} implementation of \nameref{subsec:lru-k}, \nameref{subsec:mru}, and \nameref{subsec:slru} scale very poorly regarding \emph{transaction throughput} due to the synchronization required for multithreaded execution. A global latch must be acquired on each page hit---regardless of whether pages are evicted or not. However, this cannot explain the exceptionally high \emph{miss rates} for \emph{buffer pools \SI{\geq 15}{\giga\byte}}.

    It is no surprise that the sloppy selection of eviction candidates by \nameref{subsec:leanstore} does not result in high \emph{hit rates}, but although it does not require an update of the page reference statistics on most page hits, the overhead for pointer (un)swizzling is high, keeping the \emph{transaction throughput} relatively low \emph{even with large buffer pools}. The overhead for adding pages to and removing pages from the cooling stage is particularly high when pages are infrequently evicted.

    The very low \emph{hit rates} achieved by \nameref{subsubsec:quasi-fifo} and especially by \nameref{subsec:filo} are to be expected in consideration of their suboptimal eviction decisions when used with B-trees. But because of the very low overhead (no overhead on page hits), the \emph{transaction throughput} they achieve is very decent.

    Considering the expected pollution of the buffer pool with pages referenced very frequently for a short period of time when using the \nameref{subsec:lfu} page replacement policy, it reached surprisingly low \emph{miss rates}. However, this may be a result of short (\SI{10}{\minute}) benchmark runs, where pages that are referenced very frequently remain hot until the end of the benchmark. The simple reference counter results in a competitive \emph{transaction throughput} when the \emph{DB fits into the buffer pool}, but the slow selection of eviction candidates slows down \nameref{subsec:lfu} when page evictions actually take place. The lower \emph{miss rate} of \nameref{subsec:lfuda} for \emph{small buffer pools} suggests that some pollution of the buffer pool can be prevented by ageing, but for \emph{bigger buffer pools} the way the dynamic aging of \nameref{subsec:lfuda} works leads to higher \emph{miss rates}. Because of the identical overhead imposed by both algorithms, the \emph{transaction throughput} roughly reflects the differences in \emph{miss rates} between the two algorithms.

    The good idea behind the \nameref{subsec:lrd} page replacement strategies results in the lowest \emph{miss rates} of all page replacement algorithms for \emph{smaller buffer pools}. However, due to the slow selection of eviction candidates, neither \nameref{subsubsec:lrd-v1} nor \nameref{subsubsec:lrd-v2} will achieve high \emph{transaction throughput} when the \emph{DB fits into the buffer pool}. However, the atomic counters that are incremented on a page hit do not cause significant overhead, resulting in a competitive \emph{transaction throughput} for the \emph{biggest buffer pool sizes}.

    For the \emph{most buffer pool sizes} (small and large buffer pools), the \nameref{subsubsec:lru-k_timestamp} implementation of the \nameref{subsec:lru-k} page replacement strategy achieves the lowest \emph{miss rates}. In particular, Sorting-LRU-3 and Sorting-LRU-4 achieve very high \emph{hit rates} for \emph{smaller buffer pools}. For \emph{larger ones}, the \nameref{subsubsec:lru_timestamp} implementation of \nameref{subsec:lru} achieves the same \emph{hit rates}. These high hit rates also lead to a high \emph{transaction throughput}---especially with Sorting-LRU, which has a particularly low overhead. Only few competitors can beat these algorithms in terms of \emph{hit rates} or \emph{transaction throughput}.

    The higher \emph{miss rates} of \nameref{subsec:random} and \nameref{subsubsec:loop} compared to \nameref{subsec:clock}, \nameref{subsec:zclock}, \nameref{subsec:gclock} and \nameref{subsec:dgclock} are no surprise. But due to the complete lack of overhead and the quick eviction candidate selection, they perform just as well as the others---for some buffer pool sizes even better.

    When comparing \nameref{subsec:clock}, \nameref{subsec:zclock}, \nameref{subsec:gclock}, and \nameref{subsec:dgclock}, they all perform very similarly well on \emph{very small buffer pools}. On \emph{medium size buffer pools}, the ones with more detailed page reference statistics---\nameref{subsubsec:dgclock-v1} and \nameref{subsubsec:dgclock-v2}---perform better than the others. But low overhead and simplicity are king when the \emph{hit rates are high anyways}, resulting in \nameref{subsec:clock} and \nameref{subsec:zclock} outperforming the others on \emph{big buffer pools}. A reason why \nameref{subsubsec:gclock-v1} is usually slower than \nameref{subsubsec:gclock-v2}, while \nameref{subsubsec:dgclock-v1} and \nameref{subsubsec:dgclock-v2} perform almost identically, could not be found.

\section{Conclusion} \label{sec:page_evictioners_outro}

    The performance evaluation of the different page replacement algorithms showed that a low overhead per page hit and a fast selection of eviction candidates are as important for good performance as a high hit rate. In this context, it was demonstrated that the \nameref{subsubsec:lru_timestamp} implementation of the \nameref{subsec:lru} page replacement policy performed significantly better than the \nameref{subsubsec:lru_traditional} implementation of the same page replacement policy due to its more scalable page reference statistic updating function on page hits.

    The very low transaction throughput achieved with the relatively new \nameref{subsec:leanstore} page eviction algorithm was surprising. Especially considering the fact that it was the only candidate in competition with enabled pointer swizzling in the buffer pool.

    In most cases, the \nameref{subsubsec:lru_timestamp} implementation of \nameref{subsec:lru} may actually be recommended due to its consistently high transaction throughput. But due to concerns about the scalability of the sorting process for much larger buffer pools and more CPU cores, using \nameref{subsec:zclock} or a cleverly tuned \nameref{subsec:dgclock} is probably safer.

\subsection{Future Work} \label{subsec:page_evictioners_future}

    Future work should focus on eliminating the limitations mentioned in subsection \ref{subsec:page_evictioners_limits}. Other, more modern benchmarks such as \emph{YSCB}\footnote{\url{https://github.com/brianfrankcooper/YCSB/}} or \emph{TPC-E}\footnote{\url{http://www.tpc.org/tpce/}} should also be used and run on a more up-to-date server system. \emph{GIS applications} also benefit from a well-optimized buffer pool---a comprehensive comparison of page replacement algorithms in this context would also be interesting.

    The implementation of \emph{many page replacement algorithms}, listed in section \ref{sec:page_replacement_strategies}, was beyond the scope of this thesis---especially CAR \cite{Bansal:2004}, CART \cite{Bansal:2004}, CLOCK-Pro \cite{Jiang:2005} and CLOCK-Pro+ \cite{Li:2019} look very promising.

    Hints from higher DBMS layers about the current and future page reference behavior together with \emph{page prefetching} should also be combined in such a comprehensive evaluation.
